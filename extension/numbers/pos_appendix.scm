(display "loading pos.scm extension")(newline)

;; Appendix
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;_____APPENDIX_____;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;(set-goal "all n exl p p=NatToPos n")
;;(assume "n")
;;(intro 0 (pt "NatToPos n"))
;;(use "Truth")
;;;; Proof finished.
;;(save "NatPos")


(add-program-constant "PosToNatA" (py "pos=>nat"))
(add-computation-rules "PosToNatA One" "Zero"
	"PosToNatA(SZero p)" "Succ(NatDouble((PosToNatA p)))"
	"PosToNatA(SOne p)" "(Succ((PosToNatA(SZero p))))"
	)

(set-totality-goal "PosToNatA")
(use "AllTotalElim")
(ind)
(ng #t)
(use "NatTotalVar")
(assume "p")
(assume "Ih")
(ng #t)
(use "TotalNatSucc")
(use "NatDoubleTotal")
(use "Ih")
(assume "p")
(assume "Ih")
(ng #t)
(use "TotalNatSucc")
(use "TotalNatSucc")
(use "NatDoubleTotal")
(use "Ih")
(save-totality)

(add-program-constant "NatToPosA" (py "nat=>pos"))
(add-computation-rules "NatToPosA Zero" "One"
	"NatToPosA (Succ n)" "PosS(NatToPosA n)"
	)


(set-totality-goal "NatToPosA")
(use "AllTotalElim")
(ind)
(ng #t)
(use "PosTotalVar")
(assume "n")
(assume "Ih")
(ng #t)
(use "PosSTotal")
(use "Ih")
(save-totality)

;;(animate "NatPos")
;;
;;;; NatPosExFree
;;(set-goal "all n cNatPos n=NatToPos n")
;;(assume "n")
;;(use "Truth")
;;;; Proof finished.
;;(save "NatPosExFree")
;;
;;(deanimate "NatPos")

;; SZeroPosLtPosLt
(set-goal "all p,q(SZero p<q-> p<q)")
(assume "p" "q")
(assume "Ineq")
(use "PosLtTrans" (pt "SZero p"))
(use "Truth")
(use "Ineq")
(save "SZeroPosLtPosLt")

;; SOnePosLtPosLt
(set-goal "all p,q(SOne p<q->p<q)")
(assume "p" "q")
(assume "Ineq")
(use "PosLtTrans" (pt "SOne p"))
(use "PosLtTrans" (pt "SZero p"))
(use "Truth")
(use "Truth")
(use "Ineq")
(save "SOnePosLtPosLt")

(add-program-constant "PosSIteratedNat" (py "nat=>pos=>pos"))

(add-computation-rules 
	"PosSIteratedNat Zero p" "p" 
	"PosSIteratedNat (Succ n) p" "PosS(PosSIteratedNat n p)"
	)

;(pp (nt (pt "PosSIteratedNat 6 p")))

(set-totality-goal "PosSIteratedNat")
(use "AllTotalElim")
(ind)
(use "AllTotalElim")
(assume "p")
(ng #t)
(use "PosTotalVar")
(assume "n" "Ih")
(use "AllTotalElim")
(assume "p")
(ng #t)
(use "PosSTotal")
(use "Ih")
(use "PosTotalVar")
(save-totality)

(set-goal "all n,p p<=PosSIteratedNat n p")
(ind)
(assume "p")
(ng #t)
(use "Truth")
(assume "n")
(assume "Ih")
(assume "p")
(ng #t)
(use "PosLeTrans" (pt "PosSIteratedNat n p"))
(use "Ih")
(ng #t)
(use "Truth")
(save "PosLePosSIteratedNat")

(set-goal "all p 2**p<2**PosS p")
(assume "p")
(simp (pf "PosS p=p+One"))
(simp "<-" "PosExpTwoPosPlus")
(ng #t)
(use "Truth")
(ng #t)
(use "Truth")
(save "PosExpLtPosSExp")

(set-goal "all p,q ( (p=q) = (q=p)) ")
(assume "p" "q")
(use "BooleAeqToEq")
(assume "p=q")
(simp "p=q")
(use "Truth")
(assume "q=p")
(simp "q=p")
(use "Truth")
(save "PosEqSym")

(set-goal "all p SOne p =PosS(p+p) ")
(ind)
(auto)
(assume "p" "Ih")
(ng #t)
(use "SZeroPosPlus")
(assume "p" "Ih")
(ng #t)
(use "Ih")
(save "SOnePosPlus")

(set-goal "all n(2**NatDouble n = 2**n*2**n)")
  (ind)
  (use "Truth")
  (assume "n" "IHn")
  (ng #t)
  (use "IHn")
(save "PosExpNatDoubleToPosTimes")

(set-goal "all p(2**PosS p = 2*2**p)")
  (ind)
  (ng #t)
  (use "Truth")
  (assume "p" "IHp")
  (use "Truth")
  (assume "p" "IHp")
  (ng #t)
  (simp "PosExpNatDoubleToPosTimes")
  (simp "PosExpNatDoubleToPosTimes")
  (simp "IHp")
  (use "Truth")
(save "PosTwoExpPosSToPosTimesTwo")

(set-goal "all p (SZero p = 2*p)")
  (ng #t)
  (assume "p")
  (use "Truth")
(save "PosSZeroEqTimes")

(set-goal "all n,m(n<= m -> 2**n<=2**m)")
  (ind)
  (ng #t)
  (auto)
  (assume "n" "IHn")
  (cases)
  (ng #t)
  (use "Efq")
  (assume "m")
  (assume "Rel1")
  (ng #t)
  (use "IHn")
  (use "Rel1")
(save "PosExpNatLeMon")

(set-goal "all p(Succ Zero <= p)")
  (ind)
  (use "Truth")
  (assume "p" "IHp")
  (ng #t)
    (assert "all n(Succ Zero <= n -> Succ Zero <= NatDouble n)")
      (ind)
      (ng #t)
      (assume "useless")
      (use "useless")
      (assume "n" "IHn")
      (ng #t)
      (auto)
(save "NatLeSuccZeroPosTaut")
(add-rewrite-rule "Succ Zero <= p" "T") 

(set-goal "all p(NatDouble (PosToNat p) <= Succ Zero -> F)")
  (ind)
  (ng #t)
  (use "Efq")
  (assume "p" "IHp")
  (ng #t)
  (assume "Const")
  (use "IHp")
  (use "NatLeTrans" (pt "NatDouble(NatDouble(PosToNat p))"))
  (ng #t)
  (use "Truth")
  (use "Const")
  (assume "p" "IHp")
  (ng #t)
  (use "Efq")
(save "NatDoublePostLeSuccZeroFalse")

(set-goal "all n((NatDouble n = Zero) = (n = Zero))")
  (ind)
  (use "Truth")
  (assume "n" "IHn")
  (use "Truth")
(save "NatDoubleExt")

(set-goal "all p(NatDouble (PosToNat p) = Zero -> F)")
  (ind)
  (ng #t)
  (use "Efq")
  (assume "p" "IHp")
  (ng #t)
  (assume "Const")
  (use "IHp")
  (simp "<-" "NatDoubleExt")
  (use "Const")
  (assume "p" "IHp")
  (ng #t)
  (use "Efq")
(save "NatDoublePostEqZeroFalse")

(set-goal "all n,m((NatDouble n <= NatDouble m )= (n <= m))")
  (ind)
  (ng #t)
  (assume "m")
  (use "Truth")
  (assume "n" "IHn")
  (cases)
  (ng #t)
  (use "Truth")
  (assume "m")
  (ng #t)
  (use "Truth")
(save "NatDoubleLeToId")
(add-rewrite-rule "NatDouble n <= NatDouble m " "n <= m")

(set-goal "all n(n+n = NatDouble n)")
  (ind)
  (auto)
(save "NatPlusIdEqNatDouble")

(set-goal "all n,m((NatDouble n <= Succ(NatDouble m)) = (n<=m))")
  (ind)
  (ng #t)
  (assume "m")
  (use "Truth")
  (assume "n" "IHn")
  (ng #t)
  (cases)
  (ng #t)
  (use "Truth")
  (assume "m")
  (ng #t)
  (use "IHn")
(save "NatToPosLeCompRule4")
(add-rewrite-rule "(NatDouble n <= Succ(NatDouble m))" "(n<=m)")

(set-goal "all n,m((NatDouble n < NatDouble m) = (n < m))")
  (ind)
  (cases)
  (use "Truth")
  (assume "m")
  (use "Truth")
  (assume "n" "IHn")
  (cases)
  (ng #t)
  (use "Truth")
  (assume "m")
  (ng #t)
  (use "IHn")
(save "NatDoubleLtToId")
(add-rewrite-rule "NatDouble n < NatDouble m" "n < m")

(set-goal "all p(p<NatDouble(PosToNat p))")
  (ind)
  (use "Truth")
  (assume "p" "IHp")
  (ng #t)
  (use "IHp")
  (assume "p" "IHp")
  (ng #t)
  (use "Truth")
(save "PosLtNatDoublePosToNatTaut")
(add-rewrite-rule "p<NatDouble(PosToNat p)" "T")

(set-goal "all p(Succ Zero<NatDouble (PosToNat p))")
  (ind)
  (use "Truth")
  (assume "p" "IHp")
  (ng #t)
  (use "NatLtTrans" (pt "NatDouble(PosToNat p)"))
  (use "IHp")
  (ng #t)
  (use "Truth")
  (assume "p" "IHp")
  (ng #t)
  (use "Truth")
(save "NatSuccZeroLtDoublePosToNatTaut")
(add-rewrite-rule "Succ Zero<NatDouble (PosToNat p)" "T")

(set-goal "all p( Zero<NatDouble (PosToNat p))")
  (ind)
  (use "Truth")
  (assume "p" "IHp")
  (ng #t)
  (use "NatLtTrans" (pt "NatDouble(PosToNat p)"))
  (use "IHp")
  (ng #t)
  (use "Truth")
  (assume "p" "IHp")
  (ng #t)
  (use "Truth")
(save "NatZeroLtDoublePosToNatTaut")
(add-rewrite-rule "Zero<NatDouble (PosToNat p)" "T")

(set-goal "all p(Succ Zero<=NatDouble (PosToNat p))")
  (ind)
  (use "Truth")
  (assume "p" "IHp")
  (ng #t)
  (use "NatLeTrans" (pt "NatDouble(PosToNat p)"))
  (use "IHp")
  (ng #t)
  (use "Truth")
  (assume "p" "IHp")
  (ng #t)
  (use "Truth")
(save "NatSuccZeroLeDoublePosToNatTaut")
(add-rewrite-rule "Succ Zero<=NatDouble (PosToNat p)" "T")

(set-goal "all p(NatDouble(PosToNat p)<=Succ Zero -> F)")
  (ind)
  (ng #t)
  (use "Efq")
  (assume "p" "IHp")
  (ng #t)
  (assume "Const")
  (use "IHp")
  (use "NatLeTrans" (pt "NatDouble(NatDouble(PosToNat p))"))
  (use "Truth")
  (use "Const")
  (assume "p" "IHp")
  (ng #t)
  (use "Efq")
(save "NatDoublePosToNatLeSuccZeroContra")

(set-goal "all p,q((NatLe(PosToNat p) (PosToNat q)) = (p<=q) andi (NatLt(PosToNat p) (PosToNat q)) = (p<q) andi (NatLt(Succ(NatDouble(PosToNat p)))(NatDouble(PosToNat q)))=(p<q))")
  (ind)
  (cases)
  (ng #t)
  (split)
  (use "Truth")
  (split)
  (use "Truth")
  (use "Truth")
  (assume "q")
  (ng #t)
  (split)
  (use "Truth")
  (split)
  (use "Truth")
    (assert "all n( Succ Zero <= n -> Succ(Succ(Succ Zero))< NatDouble(NatDouble n))")
      (cases)
      (ng #t)
      (use "Efq")
      (assume "l")
      (ng #t)
      (assume "Ta")
      (use "Truth")
    (assume "A1")
  (simp "A1")
  (use "Truth")
  (use "Truth")
  (assume "q")
  (ng #t)
  (split)
  (use "Truth")
  (split)
  (use "Truth")
    (assert "all n(Succ Zero <= n -> Succ Zero < NatDouble(NatDouble n))")
      (cases)
      (auto)
    (assume "A1")
  (simp "A1")
  (use "Truth")
  (use "Truth")
  (assume "p" "IHp")
  (cases)
  (ng #t)
  (simp "NatDoublePosToNatLeSuccZeroContra")
  (simp "NatDoublePostEqZeroFalse")
    (assert "all n(Succ Zero <= n -> NatDouble(NatDouble n ) = Zero -> F)")
      (cases)
      (ng #t)
      (auto)
    (assume "A1")
  (simp "A1")
  (split)
  (use "Truth")
  (split)
  (use "Truth")
  (use "Truth")
  (use "Truth")
  (assume "q")
  (ng #t)
  (split)
  (use "IHp")
  (split)
  (use "IHp")
    (assert "all m,n((n < m) =  (Succ(NatDouble n) < NatDouble m) )")
      (ind)
      (assume "n")
      (ng #t)
      (use "Truth")
      (assume "m" "IHn")
      (cases)
      (ng #t)
      (use "Truth")
      (assume "n")
      (ng #t)
      (use "IHn")
    (assume "A1")
  (simp "<-" "A1")
  (ng #t)
  (use "IHp")
  (assume "q")
  (ng #t)
  (split)
  (use "IHp")
  (split)
  (use "IHp")
  (use "IHp")
  (assume "p" "IHp")
  (cases)
  (ng #t)
  (simp "NatDoublePostEqZeroFalse")
  (split)
  (use "Truth")
  (split)
  (use "Truth")
  (use "Truth")
  (assume "q")
  (ng #t)
  (split)
  (simp "NatSuccLeEqLt")
  (use "IHp")
  (split)
  (use "IHp")
  (ng #t)
  (simp (pf "(Succ(Succ(Succ(NatDouble(NatDouble(PosToNat p)))))) =(Succ(NatDouble(Succ(NatDouble(PosToNat p)))))"))
    (assert "all m,n((n < m) =  (Succ(NatDouble n) < NatDouble m) )")
      (ind)
      (assume "n")
      (ng #t)
      (use "Truth")
      (assume "m" "IHn")
      (cases)
      (ng #t)
      (use "Truth")
      (assume "n")
      (ng #t)
      (use "IHn")
    (assume "A1")
  (simp "<-" "A1")
  (simp "<-" "A1")
  (use "IHp")
  (use "Truth")
  (assume "q")
  (ng #t)
  (split)
  (use "IHp")
  (split)
  (use "IHp")
    (assert "all m,n((n < m) =  (Succ(NatDouble n) < NatDouble m) )")
      (ind)
      (assume "n")
      (ng #t)
      (use "Truth")
      (assume "m" "IHn")
      (cases)
      (ng #t)
      (use "Truth")
      (assume "n")
      (ng #t)
      (use "IHn")
    (assume "A1")
  (simp "<-" "A1")
  (ng #t)
  (use "IHp")
(save "NatLtLeToPos")

(set-goal "all p,q((NatLe(PosToNat p) (PosToNat q)) = (p<=q))")
  (assume "p" "q")
  (inst-with "NatLtLeToPos")
  (use 1)
(save "NatLeToPos")

(set-goal "all p,q((NatLt(PosToNat p) (PosToNat q)) = (p<q))")
  (assume "p" "q")
  (inst-with "NatLtLeToPos")
  (use 1)
(save "NatLtToPos")

(set-goal "all q,p(p<=q -> 2**p <= 2**q)")
  (assume "q" "p" "Rel")
  (inst-with "PosExpNatLeMon" (pt "PosToNat p") (pt "PosToNat q"))
  (use 2)
  (simp "NatLeToPos")
  (use "Rel")
(save "PosExpLeMon")

(set-goal "all p SZero p<=2**p")
(ind)
(ng #t)
(auto)
(assume "p")
(assume "Ih")
(simp (pf "SZero(SZero p)=SZero p + SZero p"))
(simp (pf "2**SZero p=2**p*2**p"))
(use "PosLeTrans" (pt "2**p + 2**p"))
(use "PosLeMonPlus")
(auto)
(simp (pf "2**p+2**p=2*2**p"))
(use "PosLeMonTimes")
(auto)
(ng #t)
(inst-with-to "SZeroPosPlus" (pt "2**p") "Inst")
(simp "<-" "Inst")
(auto)
(simp (pf "SZero p=p+p"))
(simp "PosExpTwoPosPlus")
(auto)
(use "SZeroPosPlus")
(use "SZeroPosPlus")
(assume "p")
(assume "Ih")
(ng #t)
(simp (pf "SOne p = SZero p + 1"))
(simp (pf "2**NatDouble(PosToNat p)=2**SZero p"))
(use "PosLeTrans" (pt "2**p +2"))
(use "PosLeMonPlus")
(auto)
(use "PosLeTrans" (pt "2**p + 2**p"))
(use "PosLeMonPlus")
(auto)
(simp (pf "2**p+2**p=2*2**p"))
(simp (pf "2**SZero p=2**p*2**p"))
(use "PosLeMonTimes")
(auto)
(simp (pf "SZero p=p+p"))
(simp "PosExpTwoPosPlus")
(auto)
(use "SZeroPosPlus")
(ng #t)
(inst-with-to "SZeroPosPlus" (pt "2**p") "Inst")
(simp "Inst")
(auto)
(save "SZeroPosLePosExp")

(set-goal "all p,q,r( q=r->p*q=p*r)")
(assume "p" "q" "r" "q=p")
(simp "q=p")
(ng #t)
(use "Truth")
(save "PosTimesCancelL1")

(set-goal "all p,q,r( q=r->q*p=r*p)")
(assume "p" "q" "r" "q=r")
(simp "q=r")
(ng #t)
(use "Truth")
(save "PosTimesCancelR1")


(set-goal "all p,q,r(p+q<r+q)=(p<r)") ;as rewrite rule
(assume "p" "q" "r")
(simp "PosPlusComm")
(simp (pf "r+q=q+r"))
(ng)
(use "Truth")
(use "PosPlusComm")
;; Proof finished.
(save "PosLtPlusCancelRRule")

;; (set-goal "(p=q -> F) -> (p<q -> F) -> (p<=q -> F)")
; (assume "p")
; (ind)
; (ng #t)
; (auto)
; (ng #t)
; (assume "p0")
; (assume "Ih")
; (assume "1""2")

; (assume "p" "q")
; (ng #t)
; (assume "1" "2")
; (use "PosNotLeToLt")

; (assume "p")
; (cases)
; (ng #t)
; (assume "1" "2")



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; list pos extensions

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


(add-var-name "pls" (py "list pos"))

(add-program-constant "PosProdList" (py "list pos=>pos") t-deg-zero)
(add-computation-rules
 	"PosProdList (Nil pos)" "One"
 	"PosProdList (p::pls) " "p*PosProdList pls")

(set-totality-goal "PosProdList")
(use "AllTotalElim")
(ind)
(ng #t)
(use "PosTotalVar")
(assume "p")
(assume "pls")
(assume "Ih")
(ng #t)
(use "PosTimesTotal")
(use "PosTotalVar")
(use "Ih")
(save-totality)


(set-goal "p1*p2 = PosProdList(p1:)*p2")
(ng #t)
(auto)
(save "PosProdListElim0")


(set-goal "p1*p2 = PosProdList(p1::p2:)")
(ng #t)
(auto)
(save "PosProdListElim1")


(set-goal "PosProdList(p1::(p2*p3):)=PosProdList(p1::p2::p3:)")
(ng #t)
(auto)
(save "PosProdListElim2")

(set-goal "all p,q,r (p=q->r+p=r+q)")
(assume "p" "q" "r")
(assume "Eqv")
(simp "Eqv")
(auto)
(save "PosPlusCancelL1Thm")

(set-goal "all p,q( q<=p -> (p<q -> F))")
(assume "p" "q")
(assume "q<=p")
(simp "<-" "NatToPosToNatId")
(assert "NatToPos(PosToNat q)=q")
 (use "NatToPosToNatId")
(assume "NatToPos(PosToNat q)=q")
(simp "<-" "NatToPos(PosToNat q)=q")
(simp "NatToPosLt")
(use "NatLeToNotLt")
(simp "<-" "NatToPosLe")
(simp "NatToPosToNatId")
(simp "NatToPosToNatId")
(auto)
(use "NatLt0Pos")
(use "NatLt0Pos")
(use "NatLt0Pos")
(use "NatLt0Pos")
(save "PosLeToNotLt")

(set-goal  "all p,q,r((q<r)->(p*q<p*r))") ;as thm
(assume "p" "q" "r")
(ng #t)
(auto)
(save "PosLtTimesCancelLThm")

(set-goal  "all p,q,r((q<r)->(q*p<r*p))") ;as thm
(assume "p" "q" "r")
(ng #t)
(auto)
(save "PosLtTimesCancelRThm")

(set-goal  "all p,q,r((q<=r)->(q*p<=r*p))") ;as thm
(assume "p" "q" "r")
(ng #t)
(auto)
(save "PosLeTimesCancelRThm")

(set-goal  "all p,q,r((q<=r)->(p*q<=p*r))") ;as thm
(assume "p" "q" "r")
(ng #t)
(auto)
(save "PosLeTimesCancelLThm")

(set-goal "all p,q( q<p -> (p<=q -> F))")
(assume "p" "q")
(assume "q<p")
(simp "<-" "NatToPosToNatId")
(assert "NatToPos(PosToNat q)=q")
 (use "NatToPosToNatId")
(assume "NatToPos(PosToNat q)=q")
(simp "<-" "NatToPos(PosToNat q)=q")
(simp "NatToPosLe")
(use "NatLtToNotLe")
(simp "<-" "NatToPosLt")
(simp "NatToPosToNatId")
(simp "NatToPosToNatId")
(auto)
(use "NatLt0Pos")
(use "NatLt0Pos")
(use "NatLt0Pos")
(use "NatLt0Pos")
(save "PosLtToNotLe")

;; PosToNatEqToPos
(set-goal "all p,q(p=q -> (PosToNat p) = (PosToNat q))")
(assume "p" "q")
(assume 1)
(simp 1)
(use "Truth")
(save "PosToNatEqToPos")

;; NatToPosEqToNatEq
(set-goal "all n,m(n=m -> (NatToPos n) = (NatToPos m))")
(cases)
(assume "m")
(assume 1)
(simp 1)
(use "Truth")
(assume "n" "m")
(assume 1)
(simp 1)
(use "Truth")
(save "NatToPosEqToNatEq")

;; PosTimesCancelLInv
(set-goal "all p,q,r((p*q = p*r) = (q = r))")
(ind)
(cases)
(cases)
(ng #t)
(use "Truth")
(ng #t)
(assume "p")
(use "Truth")
(assume "p")
(ng #t)
(use "Truth")
(assume "p" "r")
(ng #t)
(use "Truth")
(assume "p" "r")
(ng #t)
(use "Truth")
(assume "p")
(assume "IH")
(assume "q" "r")
(ng #t)
(use "IH")
(assume "p")
(assume "IH")
(assume "q" "r")
(simp "BooleAeqToEq")
(use "Truth")
(assume 1)
(simp 2)
(use "Truth")
(assume 1)
(inst-with "PosTimesCancelL" (pt "SOne p") (pt "q") (pt "r"))
(use 3)
(use 2)
(save "PosTimesCancelLInv")

;; PosLeTimesCancelL
(set-goal  "all p,q,r(p*q<=p*r)=(q<=r)") ;as thm
(assume "p" "q" "r")
(simp "PosTimesComm")
(simp (pf "p*r=r*p"))
(use "Truth")
(use "PosTimesComm")
(save "PosLeTimesCancelL")

;; PosLeTimesCancelL
(set-goal  "all p,q,r(q*p<=r*p)=(q<=r)") ;as thm
(assume "p" "q" "r")
(simp "PosTimesComm")
(simp (pf "r*p=p*r"))
(use "Truth")
(use "PosTimesComm")
(save "PosLeTimesCancelR")

;; PosLePlusCancelR
(set-goal "all p,q,r(p+q<=r+q)=(p<=r)") ;as thm
(assume "p" "q" "r")
(simp "PosPlusComm")
(simp (pf "r+q=q+r"))
(ng)
(use "Truth")
(use "PosPlusComm")
(save "PosLePlusCancelR")

(set-goal "all p,q,r(p+q<=p+r)=(q<=r)")
  (ng #t)
  (strip)
  (use "Truth")
(save "PosLePlusCancelL")

;; PosLtTimesCancelL
(set-goal "all p,q,r((p*q<p*r)=(q<r))") ;as thm
(assume "p" "q" "r")
(simp "PosTimesComm")
(simp (pf "p*r=r*p"))
(use "Truth")
(use "PosTimesComm")
(save "PosLtTimesCancelL")

;; PosLtPlusCancelR
(set-goal "all p,q,r(p+q<r+q)=(p<r)") ;as thm
(assume "p" "q" "r")
(simp "PosPlusComm")
(simp (pf "r+q=q+r"))
(ng)
(use "Truth")
(use "PosPlusComm")
(save "PosLtPlusCancelR")

;; PosMaxLePosSMax
(set-goal "all p,q(p max q <= p max PosS(q))")
(assume "p" "q")
(inst-with "NatMaxLeSuccMax" (pt "PosToNat(p)") (pt "PosToNat(q)"))
(simp "<-" "PosToNatLe")
(simp "PosToNatMax")
(simp "PosToNatMax")
(simp "PosSSucc")
(use 1)
(save "PosMaxLePosSMax")

(set-goal "all p,q (p<PosS q)=(p<=q)")
(use "PosLtPosS")
(add-rewrite-rule "p<PosS q" "p <= q")


;; PosSEqPlusOne

;


;;(set-goal "")



(set-goal "all p ( PosS p = p+1)")
(ng #t)
(assume "p1")
(use "Truth")
(save "PosSEqPlusOne")

;; PosSZeroEqPlus
(set-goal "all p (SZero p = p+p)")
(ind)
(use "Truth")
(assume "p")
(assume "IH")
(ng #t)
(use "IH")
(assume "p")
(assume "IH")
(ng #t)
(simp "<-" "IH")
(use "Truth")
(save "PosSZeroEqPlus")

(set-goal "all p(p*One = p)")
(strip)
(ng #t)
(use "Truth")
(save "PosTimesOne")
(add-rewrite-rule "p*One" "p")

(set-goal "all p(One * p = p)")
(strip)
(ng #t)
(use "Truth")
(save "PosTimesOne1")
(add-rewrite-rule "One*p" "p")

(set-goal "p <= p+p")
(ind)
(use "Truth")
(assume "p" "IH")
(ng #t)
(use "Truth")
(assume "p" "IH")
(ng #t)
(use "Truth")
(save "PosLeTransTaut")
(add-rewrite-rules "p<=p+p" "T")

(set-goal "NatLe(PosToNat p)(PosToNat(p+p))")
(ind)
(ng #t)
(use "Truth")
(assume "p" "IH")
(ng #t)
(use "IH")
(assume "p" "IHp")
(ng #t)
(assert "all n(NatDouble n = n+n)")
    (ind)
    (use "Truth")
    (assume "n" "IHa")
    (ng #t)
    (use "IHa")
  (assume "as1")
(simp "as1")
(simp "as1")
  (assert "all p (PosToNat(PosS p) = Succ(PosToNat p))")
    (ind)
    (ng #t)
    (use "Truth")
    (assume "q")
    (assume "IHa")
    (ng #t)
    (use "Truth")
    (assume "q" "IHa")
    (ng #t)
    (simp "IHa")
    (ng #t)
    (use "Truth")
  (assume "as2")
(simp "as2")
(ng #t)
(use "NatLeTrans" (pt "NatPlus(PosToNat(p+p))(PosToNat(p+p))"))
(use "NatLeTrans" (pt "NatPlus(PosToNat p)(PosToNat(p+p))"))
(ng #t)
(use "IHp")
(ng #t)
(use "IHp")
(ng #t)
(use "Truth")
(save "NatPosToNatLePosPlus")

(set-goal "all p(Zero < p)")
(ind)
(use "Truth")
(assume "p")
(assume "IH")
(simp "PosSZeroEqPlus")
(use "NatLtLeTrans" (pt "PosToNat p"))
(use "IH")
(simp "NatLeToPos")
(use "Truth")
(assume "p" "IH")
(ng #t)
(use "Truth")
(save "PosZeroLtPos")
(add-rewrite-rule "Zero<p" "T")

(set-goal "all p(Succ Zero < NatDouble(PosToNat p))")
(ind)
(ng #t)
(use "Truth")
(assume "p" "IH")
(simp "<-" "NatPlusEqDouble")
(use "NatLtLeTrans" (pt "PosToNat(SZero p)"))
(ng #t)
(use "IH")
(ng #t)
(use "Truth")
(assume "p")
(assume "IH")
(ng #t)
(use "Truth")
(save "NatNatDoublePosLtSZero")
(add-rewrite-rule "Succ Zero < NatDouble(PosToNat p )" "T")


(set-goal "all p(Zero < NatDouble(PosToNat p))")
(assume "p")
(use "NatLtTrans" (pt "Succ Zero"))
(use "Truth")
(use "Truth")
(save "NatNatDoublePosLtZero")
(add-rewrite-rule "Zero < NatDouble(PosToNat p)" "T")

(set-goal "all p(p<=SZero p)")
(cases)
(use "Truth")
(ng #t)
(assume "p")
(use "Truth")
(ng #t)
(assume "p")
(simp (pf "SOne p = (SZero p + One)"))
(use "PosLtLeTrans" (pt "p+1"))
(use "Truth")
(simp "PosLePlusCancelR")
(use "Truth")
(use "Truth")
(save "PosLeSZeroId")
(add-rewrite-rule "p<=SZero p" "T")

(set-goal "all p(SOne p = SZero p +1)")
(assume "p")
(ng #t)
(use "Truth")
(save "PosSOneRewrite")

(set-goal "all p (p < SOne p)")
(cases)
(use "Truth")
(assume "p")
(use "Truth")
(assume "p")
(ng #t)
(simp "PosSOneRewrite")
(use "PosLtTrans" (pt "SZero p"))
(use "Truth")
(use "Truth")
(save "PosLtSOneTaut")
(add-rewrite-rule "p<SOne p" "T")

(set-goal "all p(2**PosLog(2*p) = 2*2**PosLog(p))")
(assume "p")
(use "Truth")
(save "PosLogTimesEqTimes")

(set-goal "all p,q((p=q->F)->(p<q)->(q<=p ->F))")
(cases)
(cases)
(ng #t)
(assume 1)
(use "Efq")
(assume "p")
(ng #t)
(assume 1 1 1)
(use 3)
(assume "p")
(ng #t)
(assume 1 1 1)
(use 3)
(assume "p" "q")
(ng #t)
(assume 1 1 1)
(use 1)
(use "PosLeAntiSym")
(use "PosLtToLe")
(use 2)
(use 3)
(assume "p" "q")
(ng #t)
(assume 1 1 1)
(use 1)
(use "PosLeAntiSym")
(use "PosLtToLe")
(use 2)
(use 3)
(save "PosNotLeCases")

(set-goal "all p,q((p=q->F)->(p<q)->(q<p ->F))")
(cases)
(cases)
(ng #t)
(assume 1)
(use "Efq")
(assume "p")
(ng #t)
(assume 1 1 1)
(use 3)
(assume "p")
(ng #t)
(assume 1 1 1)
(use 3)
(assume "p" "q")
(ng #t)
(assume 1 1 1)
(use 1)
(use "PosLeAntiSym")
(use "PosLtToLe")
(use 2)
(use "PosLtToLe")
(use 3)
(assume "p" "q")
(ng #t)
(assume 1 1 1)
(use 1)
(use "PosLeAntiSym")
(use "PosLtToLe")
(use 2)
(use "PosLtToLe")
(use 3)
(save "PosNotLtCases")

(set-goal "all p,q(PosToNat(p+q) = NatPlus(PosToNat p)(PosToNat q))")  
  (assert "all p(PosToNat(PosS p) = Succ(PosToNat p))")
    (ind)
    (use "Truth")
    (assume "r" "IH")
    (use "Truth")
    (assume "r" "IH")
    (ng #t)
    (simp "IH")
    (use "Truth")
  (assume "Ass1")
  (assert "all p(PosToNat(SZero p) = NatDouble p)")
    (ind)
    (use "Truth")
    (assume "r" "IH")
    (use "Truth")
    (assume "r" "IH")
    (use "Truth")
  (assume "Ass2")
  (assert "all p,q(PosToNat (p+q) = NatPlus p q)")
    (ind)
    (ng #t)
    (use "Ass1")
    (assume "r" "IH")
    (ng #t)
    (assume "q")
    (simp (pf "SZero r+q = r+r+q") )
    (inst-with "IH" (pt "r+q"))
    (simp (pf "r+r+q=r+(r+q)"))
    (simp "IH")
    (simp "IH")
    (ng #t)
    (inst-with "NatPlusEqDouble" (pt "PosToNat r"))
    (simp 5)
    (use "Truth")
    (use "Truth")
    (simp "PosSZeroEqPlus")
    (use "Truth")
    (assume "r" "IH")
    (ng #t)
    (assume "q")
    (simp "PosSOneRewrite")
    (simp (pf "PosToNat(SZero r+1+q) = Succ(PosToNat(SZero r+q))"))
    (ng #t)
    (simp "PosSZeroEqPlus")
    (simp (pf "r+r+q=r+(r+q)"))
    (simp "IH")
    (simp "IH")
    (ng #t)
    (inst-with "NatPlusEqDouble" (pt "PosToNat r"))
    (simp 4)
    (use "Truth")
    (use "Truth")
    (simp (pf "SZero r+1+q = SZero r+q+1"))
    (ng #t)
    (simp "Ass1")
    (use "Truth")
    (use "PosLeAntiSym")
    (simp "PosPlusComm")
    (simp "PosPlusAssoc")
    (simp "PosLePlusCancelR")
    (simp "PosPlusComm")
    (use "Truth")
    (simp "PosPlusComm")
    (simp "PosPlusAssoc")
    (simp "PosLePlusCancelR")
    (simp "PosPlusComm")
    (use "Truth")
  (assume "Ass3")
(cases)
(ng #t)
(cases)
(use "Truth")
(assume "p")
(ng #t)
(use "Truth")
(assume "p")
(ng #t)
(simp "Ass1")
(ng #t)
(use "Truth")
(assume "p" "q")
(ng #t)
(simp "Ass3")
(simp "Ass2")
(use "Truth")
(assume "p" "q")
(simp "Ass3")
(use "Truth")
(save "PosPlusEqNatPlus")

(set-goal "all p((Succ Zero < p)= (One < p))")
(cases)
(use "Truth")
(assume "p")
(ng #t)
(use "Truth")
(assume "p")
(ng #t)
(use "Truth")
(save "PosSuccZeroLtOne")

(set-goal "all p(1=PosS p -> F)")
(cases)
(ng #t)
(assume 1)
(use 1)
(assume "p")
(ng #t)
(assume 1)
(use 1)
(ng #t)
(assume "p" 1)
(use 1)
(save "PosSNotEqOne")

(set-goal "all p(PosS(p+p) = SOne p)")
(ind)
(use "Truth")
(ng #t)
(assume "p" "IH")
(simp "PosEqSym")
(use "SZeroPosPlus")
(ng #t)
(assume "p" "IH")
(use "IH")
(save "PosSpPluspEqSOne")
(add-rewrite-rule "PosS(p+p)" "SOne p")


;; PosPosSLe
(set-goal "all p,q((PosS q <= p)=(q<p))")
(ind)
(cases)
(ng #t)
(use "Truth")
(assume "p")
(ng #t)
(use "Truth")
(assume "q")
(ng #t)
(use "Truth")
(assume "p" "IH")
(cases)
(ng #t)
(use "Truth")
(assume "q")
(ng #t)
(use "Truth")
(ng #t)
(assume "p0")
(use "IH")
(assume "p" "IH")
(cases)
(ng #t)
(use "Truth")
(assume "p0")
(ng #t)
(use "Truth")
(assume "p0")
(ng #t)
(use "IH")
(add-rewrite-rule "PosS q <= p" "q < p")
(save "PosPosSLe")





(set-goal "all p,q ((PosS p <= q) = (p <q))")
(ind)
(cases)
(ng #t)
(use "Truth")
(assume "q")
(use "Truth")
(assume "q")
(use "Truth")
(assume "p" "IH")
(cases)
(use "Truth")
(assume "q")
(use "Truth")
(assume "q")
(use "Truth")
(assume "p" "IHq")
(cases)
(use "Truth")
(assume "q")
(ng #t)
;; 
(use "Truth")
(assume "q")
(ng #t)
(use "Truth")
(save "PosSLeEqLt")

(set-goal "all p,q,r((p*q=p*r) = (q=r))")
(assume "p" "q" "r")
(use "BooleAeqToEq")
(assume "EqHyp")
(use "PosTimesCancelL" (pt "p"))
(use "EqHyp")
(assume "EqHyp")
(simp "EqHyp")
(use "Truth")
(save "PosTimesCancelLSW")

(set-goal "all p,q(Zero<NatPlus(PosToNat p)(PosToNat q))")
  (assert "all n,m(Zero < n -> Zero < m -> Zero < NatPlus n m)")
    (ind)
    (assume "l1")
    (ng #t)
    (use "Efq")
    (assume "l1" "IHA1")
    (cases)
    (ng #t)
    (assume 1)
    (use "Efq")
    (assume "l2")
    (ng #t)
    (auto)
(save "NatZeroLtPosToNatPlus")
(add-rewrite-rule "Zero<NatPlus(PosToNat p)(PosToNat q)" "T")

; _________________ Trans Lib Ext ____________________

(set-goal "all r,p,q((p*r = q*r) = (p = q))")
  (ind)
  (cases)
  (cases)
  (ng #t)
  (use "Truth")
  (ng #t)
  (assume "p")
  (use "Truth")
  (assume "p")
  (ng #t)
  (use "Truth")
  (assume "p" "r")
  (ng #t)
  (use "Truth")
  (assume "p" "r")
  (ng #t)
  (use "Truth")
  (assume "p")
  (assume "IH")
  (assume "q" "r")
  (ng #t)
  (use "IH")
  (assume "p")
  (assume "IH")
  (assume "q" "r")
  (simp "BooleAeqToEq")
  (use "Truth")
  (assume 1)
  (simp 2)
  (use "Truth")
  (assume 1)
  (inst-with "PosTimesCancelL" (pt "SOne p") (pt "q") (pt "r"))
  (use 3)
  (simp "PosTimesComm")
  (simp-with "PosTimesComm" (pt "SOne p") (pt "r"))
  (use 2)
(save "PosTimesCancelRInv")

(set-goal "all p,q (p<PosS q)=(p<=q)")
  (use "PosLtPosS")
(add-rewrite-rule "p<PosS q" "p <= q")
(save "PosLtPosSEqLe")

(set-goal "all p,q((PosS q <= p)=(q<p))")
  (ind)
  (cases)
  (ng #t)
  (use "Truth")
  (assume "p")
  (ng #t)
  (use "Truth")
  (assume "q")
  (ng #t)
  (use "Truth")
  (assume "p" "IH")
  (ng #t)
  (cases)
  (ng #t)
  (use "Truth")
  (auto)
(add-rewrite-rule "PosS q <= p" "q < p")
(save "PosLtEqPosSLe")

(set-goal "all p (SZero p = p+p)")
  (ind)
  (use "Truth")
  (assume "p")
  (assume "IH")
  (ng #t)
  (use "IH")
  (assume "p")
  (assume "IH")
  (ng #t)
  (simp "<-" "IH")
  (use "Truth")
(save "PosSZeroPlus")

(set-goal "all p,q((p<q->F)->(p=q ->F) -> p<=q -> F)")
  (ind)
  (cases)
  (ng #t)
  (assume 1 1)
  (use 2)
  (ng #t)
  (assume "p" 1 1)
  (use 1)
  (ng #t)
  (assume "q" 1 1)
  (use 1)
  (assume "p" "IH")
  (cases)
  (ng #t)
  (assume 1 1)
  (use 2)
  (assume "q")
  (ng #t)
  (use "IH")
  (assume "q")
  (ng #t)
  (assume 1 1)
  (use 2)
  (assume "p" "IH")
  (cases)
  (ng #t)
  (assume 1 1)
  (use 2)
  (assume "q")
  (ng #t)
  (assume 1 1)
  (use 2)
  (assume "q")
  (ng #t)
  (use "IH")
(save "PosNotLeCases1")

(set-goal "all p,q(p<=q -> (p=q ->F) -> p<q)")
  (ind)
  (cases)
  (ng #t)
  (assume 1 1)
  (use 2)
  (use 1)
  (ng #t)
  (assume "q" 1 1)
  (use 1)
  (assume "q")
  (ng #t)
  (assume 1 1)
  (use 1)
  (assume "p" "IH")
  (cases)
  (ng #t)
  (assume 1 1)
  (use 2)
  (assume "q")
  (ng #t)
  (use "IH")
  (assume "q")
  (ng #t)
  (assume 1 1)
  (use 2)
  (assume "p" "IH")
  (cases)
  (ng #t)
  (assume  1 1)
  (use 2)
  (assume "q")
  (ng #t)
  (assume 1 1)
  (use 2)
  (assume "q")
  (ng #t)
  (use "IH")
(save "PosLtCases")

(set-goal "all p,q(p<q  -> q < p -> F)")
  (ind)
  (cases)
  (ng #t)
  (use "Efq")
  (assume "q")
  (ng #t)
  (assume "Ta")
  (use "Efq")
  (assume "q")
  (ng #t)
  (assume "Ta")
  (use "Efq")
  (assume "p" "IHp")
  (cases)
  (ng #t)
  (auto)
  (assume "q")
  (ng #t)
  (assume "Rel")
  (use "PosLeToNotLt")
  (use "Rel")
  (assume "p" "IHp")
  (cases)
  (ng #t)
  (use "Efq")
  (assume "q")
  (ng #t)
  (assume "Rel")
  (use "PosLtToNotLe")
  (use "Rel")
  (assume "q")
  (ng #t)
  (use "IHp")
(save "PosLtToNotLt")

(set-goal "all p (SZero p = 2*p)")
  (ng #t)
  (assume "p")
  (use "Truth")
(save "PosSZeroTimes")

(set-goal "all p,q((p=q->F)->(p<q)->(q<=p ->F))")
  (cases)
  (cases)
  (ng #t)
  (assume 1)
  (use "Efq")
  (assume "p")
  (ng #t)
  (assume 1 1 1)
  (use 3)
  (assume "p")
  (ng #t)
  (assume 1 1 1)
  (use 3)
  (assume "p" "q")
  (ng #t)
  (assume 1 1 1)
  (use 1)
  (use "PosLeAntiSym")
  (use "PosLtToLe")
  (use 2)
  (use 3)
  (assume "p" "q")
  (ng #t)
  (assume 1 1 1)
  (use 1)
  (use "PosLeAntiSym")
  (use "PosLtToLe")
  (use 2)
  (use 3)
(save "PosNotLeCases2")

(set-goal "all p((SZero p< p) = F)")
  (ind)
  (ng #t)
  (use "Truth")
  (assume "p" "IH")
  (ng #t)
  (use "IH")
  (assume "p" "IH")
  (ng #t)
  (simp "PosSOneRewrite")
  (simp (pf "(SZero p+1<= p)=(SZero p < p)"))
  (use "IH")
  (ng #t)
  (use "BooleAeqToEq")
  (assume 1)
  (ng #t)
  (use "PosLtLeTrans" (pt "SOne p"))
  (use "Truth")
  (use 2)
  (assume 1)
  (use "PosLeTrans" (pt "SZero p"))
  (ng #t)
  (simphyp-with 2 "IH")
  (use 3)
  (use "PosLtToLe")
  (use 2)
(add-rewrite-rule "SZero p<p" "F")
(save "PosSZeroLtIdContra")

(set-goal "all p (PosToNat p = Zero -> F)")
  (ind)
  (ng #t)
  (assume 1)
  (use 1)
  (ng #t)
  (assume "p" "IH")
  (assume "Fa")
  (use "IH")
  (simp "<-" "NatDoubleZeroRWRule")
  (use "Fa")
  (assume "p" "IH")
  (ng #t)
  (assume 1)
  (use 2)
(save "PosToNatEqZeroContraRWRule")

(set-goal "all p(PosS p = 1 -> F)")
  (cases)
  (ng #t)
  (use "Efq")
  (ng #t)
  (assume "q")
  (use "Efq")
  (assume "p")
  (ng #t)
  (use "Efq")
(save "PosSEqOneContra")

(set-goal "all p,q(((PosS p) <= (PosS q)) = (p <= q))")
  (cases)
  (cases)
  (ng #t)
  (use "Truth")
  (assume "q")
  (ng #t)
  (use "Truth")
  (assume "q")
  (ng #t)
  (use "Truth")
  (assume "p")
  (cases)
  (ng #t)
  (use "Truth")
  (assume "q")
  (ng #t)
  (use "Truth")
  (assume "q")
  (ng #t)
  (use "Truth")
  (assume "p")
  (cases)
  (ng #t)
  (use "BooleAeqToEq")
  (assume "Contra")
  (use "PosSEqOneContra" (pt "p"))
  (use "Contra")
  (use "Efq")
  (assume "q")
  (ng #t)
  (use "Truth")
  (assume "q")
  (ng #t)
  (use "Truth")
(save "PosSLeEqLe")

(set-goal "all q(One < q -> (PosPred (q+q)) = (PosPred q+q))")
  (cases)
  (ng #t)
  (assume 1)
  (use 1)
  (assume "p")
  (ng #t)
  (assume "Tau")
  (use "PosLeAntiSym")
  (ng #t)
  (simp "<-" "PosLePlusCancelR" (pt "One"))
  (simp (pf "PosPred(SZero(p+p))+1 = PosS(PosPred(SZero(p+p)))"))
  (simp (pf "PosPred(SZero p)+SZero p+1 = 1+PosPred(SZero p)+SZero p"))
  (use "Truth")
  (simp "PosPlusComm")
  (use "PosPlusAssoc")
  (use "Truth")
  (simp "<-" "PosLePlusCancelR" (pt "One"))
  (simp (pf "PosPred(SZero(p+p))+1 = PosS(PosPred(SZero(p+p)))"))
  (simp (pf "PosPred(SZero p)+SZero p+1 = 1+PosPred(SZero p)+SZero p"))
  (use "Truth")
  (simp "PosPlusComm")
  (use "PosPlusAssoc")
  (use "Truth")
  (assume "p")
  (ng #t)
  (assume 1)
  (simp "PosSZeroPlus")
  (use 1)
(save "PosPredPlusDistL")

(set-goal "all q,p (One < q -> (p <= (PosPred q)) = (p <q))")
  (ind)
  (assume "p")
  (ng #t)
  (use "Efq")
  (assume "q" "IH")
  (cases)
  (ng #t)
  (assume 1)
  (use 2)
  (assume "p")
  (ng #t)
  (assume "Tau")
  (cases (pt "q=One"))
  (assume "C1")
  (simp "C1")
  (ng #t)
  (use "Truth")
  (assume "nC1")
  (use "BooleAeqToEq")
  (assume "Rel")
  (simp "<-" "PosLtTimesCancelL" (pt "2"))
  (simp "<-" "PosSZeroTimes")
  (simp "<-" "PosSZeroTimes")
  (use "PosLeLtTrans" (pt "PosPred(SZero q)"))
  (use "Rel")
    (assert "all q(PosPred(SZero q)<SZero q)")
      (ind)
      (ng #t)
      (use "Truth")
      (assume "r" "IH1")
      (ng #t)
      (use "IH1")
      (assume "r" "IH1")
      (ng #t)
      (use "Truth")
    (assume "A1")
  (use "A1")
  (assume "Rel")
  (simp "PosSZeroPlus")
  (simp "PosSZeroPlus")
  (simp (pf "PosPred (q+q) = PosPred q +q"))
  (use "PosLeTrans" (pt "p+q"))
  (use "PosLtToLe")
  (use "Rel")
  (simp "PosLePlusCancelR")
  (simp "IH")
  (use "Rel")
  (use "PosNotLeToLt")
  (use "nC1")
  (use "PosPredPlusDistL")
  (use "PosNotLeToLt")
  (use "nC1")
  (assume "p")
  (ng #t)
  (assume "Tau")
  (cases (pt "q = One"))
  (assume "C1")
  (simp "C1")
  (ng #t)
  (use "Truth")
  (assume "nC1")
  (use "BooleAeqToEq")
  (assume "Rel")
  (simp "<-" "PosLtTimesCancelL" (pt "2"))
  (simp "<-" "PosSZeroTimes")
  (simp "<-" "PosLtPlusCancelR" (pt "One"))
  (simp (pf "SZero p+1 = SOne p"))
  (use "PosLeLtTrans" (pt "PosPred(SZero q)"))
  (use "Rel")
  (ng #t)
  (use "PosLtTrans" (pt "SZero q"))
    (assert "all q(PosPred(SZero q)<SZero q)")
      (ind)
      (ng #t)
      (use "Truth")
      (assume "r" "IH1")
      (ng #t)
      (use "IH1")
      (assume "r" "IH1")
      (ng #t)
      (use "Truth")
    (assume "A1")
  (use "A1")
  (use "Truth")
  (use "Truth")
  (assume "Rel")
  (simp "PosSOneRewrite")
  (simp "PosSZeroPlus")
  (simp "PosSZeroPlus")
  (simp "PosPredPlusDistL")
  (use "PosLeTrans" (pt "p+q"))
  (inst-with "PosLePlusCancelL" (pt "p") (pt "p+1") (pt "q"))
  (ng)
  (simp 5)
  (use "Rel")
  (simp "PosLePlusCancelR")
  (simp "IH")
  (use "Rel")
  (use "PosNotLeToLt")
  (use "nC1")
  (use "PosNotLeToLt")
  (use "nC1")
  (assume "q" "IH")
  (cases)
  (ng #t)
  (auto)
(save "PosLePredEqLt")

(set-goal "(q=1 -> F)->(q<=Succ Zero -> F)")
  (cases)
  (ng #t)
  (assume 1)
  (use 1)
  (assume "p")
  (ng #t)
  (assume 1)
    (assert "all n(Zero < n -> NatDouble(n)<= Succ Zero -> F)")
      (ind)
      (ng #t)
      (use "Efq")
      (assume "n")
      (assume "IH")
      (assume "Tau")
      (ng #t)
      (use "Efq")
    (assume "Fa")
  (use "Fa")
  (use "Truth")
  (assume "p")
  (ng #t)
  (assume 1)
  (use "NatDoubleEqZeroRule")
  (use "Truth")
(save "PosNotOneToNotSuccZero")

(set-goal "all p,q((p<=q)->(PosToNat p <= PosToNat q))")
  (ind)
  (ng #t)
  (assume "q")
  (assume "Tau")
  (use "Truth")
  (assume "p" "IH")
  (cases)
  (ng #t)
  (use "Efq")
  (assume "q")
  (ng #t)
  (use "IH")
  (assume "q")
  (ng #t)
  (assume "Rel")
  (use "IH")
  (use "Rel")
  (assume "p" "IH")
  (cases)
  (ng #t)
  (use "Efq")
  (assume "q")
  (ng #t)
  (assume "Rel")
  (simp "NatSuccLeEqLt")
  (ng #t)
  (simp "<-" "NatSuccLeEqLt")
    (assert "all p(PosToNat(PosS p) = Succ(PosToNat p))")
      (ind)
      (use "Truth")
      (assume "r" "IH2")
      (use "Truth")
      (assume "r" "IH2")
      (ng #t)
      (simp "IH2")
      (ng #t)
      (use "Truth")
    (assume "A1")
  (cases (pt "q = One"))
  (assume "C1")
  (simp "C1")
  (ng #t)
  (assert "F")
  (simphyp-with-to "Rel" "C1" "Contra")
  (ng "Contra")
  (use "Contra")
  (use "Efq")
  (assume "nC1")
  (simp (pf "Succ(PosToNat p) = (PosToNat p)+1"))
  (use "NatLeMinusToPlusLe")
  (ng #t)
  (simp (pf "Pred(PosToNat q) = PosToNat(PosPred q)"))
  (use "IH")
  (simp "PosLePredEqLt")
  (use "Rel")
  (use "PosNotLeToLt")
  (use "nC1")
  (use "PredPosPred")
  (use "PosNotLeToLt")
  (use "nC1")
  (ng #t)
  (use "Truth")
  (ng #t)
  (use "Truth")
  (use "IH")
(save "PosLeToPosToNatLe")

(set-goal "all n,m(n<=m -> 2**n <= 2**m)")
  (ind)
  (ng #t)
  (auto)
  (assume "n" "IH")
  (cases)
  (ng #t)
  (assume "EFQ")
  (use "EFQ")
  (assume "m")
  (ng #t)
  (use "IH")
(save "PosExpTwoNatLe")

(set-goal "all p,q(p<=q -> 2**p <= 2**q)")
  (assume "p" "q")
  (assume "Rel")
  (use "PosExpTwoNatLe")
  (use "PosLeToPosToNatLe")
  (use "Rel")
(save "PosExpTwoPosLe")

(set-goal "all p,q((PosS p = PosS q)=(p=q))")
  (assume "p" "q")
    (assert "all p,q(PosS p=PosS q -> p=q)")
      (ind)
      (cases)
      (auto)
      (assume "q1")
      (ng #t)
      (simp "PosEqSym")
      (simp "PosSEqOneContra")
      (use "Efq")
      (assume "p1" "IHp1")
      (cases)
      (ng #t)
      (use "Efq")
      (assume "q1")
      (ng #t)
      (assume "pEq")
      (use "pEq")
      (assume "q1")
      (ng #t)
      (use "Efq")
      (assume "p1" "IHp")
      (cases)
      (ng #t)
      (simp "PosSEqOneContra")
      (use "Efq")
      (assume "q1")
      (ng #t)
      (use "Efq")
      (assume "q1")
      (ng #t)
      (use "IHp")
    (assume "A1")
  (use "BooleAeqToEq")
  (auto)
  (assume "pEq")
  (simp "pEq")
  (use "Truth")
(save "PosSEq")

(set-goal "all p,q,r((p+r=q+r)=(p=q))")
  (assert "all r,p,q((p+r=q+r)=(p=q))")
  (ind)
  (ng #t)
  (assume "p" "q")
  (use "BooleAeqToEq")
  (assume 1)
  (simp "<-" "PosSEq")
  (use 1)
  (assume "eq")
  (simp "eq")
  (use "Truth")
  (assume "r" "IH")
  (assume "p" "q")
  (simp "PosSZeroPlus")
  (simp "PosPlusAssoc")
  (simp "PosPlusAssoc")
  (inst-with "IH" (pt "p+r") (pt "q+r"))
  (simp 2)
  (use "IH")
  (assume "r" "IH")
  (assume "p" "q")
  (simp (pf "SOne r = r+r+1"))
  (simp "PosPlusAssoc")
  (simp "PosPlusAssoc")
  (simp "PosPlusAssoc")
  (simp "PosPlusAssoc")
  (inst-with "IH" (pt "p+r+1") (pt "q+r+1"))
  (simp (pf "p+r+r+1 = p+r+1+r"))
  (simp (pf "q+r+r+1 = q+r+1+r"))
  (simp "IH")
  (ng #t)
  (simp "PosSEq")
  (use "IH")
  (use "Truth")
  (use "Truth")
  (simp "<-" "PosSZeroPlus")
  (use "Truth")
  (assume "A1")
(assume "p" "q" "r")
(use "A1")
(save "PosEqPlusElimR")

(set-goal "all p(SZero p = p -> F)")
(ind)
(auto)
(save "PosSZeroContra")

(set-goal "all p(PosS(p+p) = (SOne p))")
  (ind)
  (use "Truth")
  (assume "p1" "IHp1")
  (ng #t)
  (simp "PosSZeroPlus")
  (use "Truth")
  (assume "p1" "IHp1")
  (ng #t)
  (use "IHp1")
(save "PosSOnePlusS")
(add-rewrite-rule "PosS(p+p)" "SOne p")

(set-goal "all q,p((SOne p <= (SOne p)*q) = (p <= p*q) andi p <= p*q andi q <= p*q)")
  (assert "all p,q((SZero p <= SZero q) = (p<=q))")
    (auto)
  (assume "A1")
  (ind)
  (ng #t)
  (assume "p")
  (split)
  (use "Truth")
  (split)
  (use "Truth")
  (use "Truth")
  (assume "q" "IHq")
  (cases)
  (ng #t)
  (split)
  (use "BooleAeqToEq")
  (assume "Cond")
  (use "Truth")
  (assume "Ta")
  (use "PosLtTrans" (pt "SZero q"))
  (use "Truth")
  (use "Truth")
  (split)
  (use "Truth")
  (use "Truth")
  (assume "p")
  (ng #t)
  (split)
  (use "BooleAeqToEq")
  (assume "Cond")
  (use "PosLeTrans" (pt "SZero p"))
  (use "Truth")
  (ng #t)
  (use "IHq")
  (assume "Cond")
  (use "PosLtTrans" (pt "SZero p+q"))
  (use "Truth")
  (ng #t)
  (use "PosLtLeTrans" (pt "SZero p"))
  (use "Truth")
  (simp "A1")
  (use "IHq")
  (split)
  (use "PosLeTrans" (pt "SZero p"))
  (use "Truth")
  (simp "A1")
  (use "IHq")
  (use "PosLeTrans" (pt "SZero q"))
  (use "Truth")
  (use "IHq")
  (assume "p")
  (ng #t)
  (split)
  (use "BooleAeqToEq")
  (assume "Cond")
  (use "PosLtTrans" (pt "SZero p"))
  (use "Truth")
  (use "PosLtLeTrans" (pt "SZero p +q"))
  (use "Truth")
  (ng #t)
  (use "IHq")
  (assume "Cond")
  (use "PosLtLeTrans" (pt "SOne p +q"))
  (use "Truth")
  (ng #t)
  (use "PosLtLeTrans" (pt "p+q"))
  (use "Truth")
  (ng #t)
  (use "PosLeTrans" (pt "SZero p"))
  (use "Truth")
  (simp "A1")
  (use "IHq")
  (split)
  (use "PosLtLeTrans" (pt "p+q"))
  (use "Truth")
  (ng #t)
  (use "PosLeTrans" (pt "SZero p"))
  (use "Truth")
  (ng #t)
  (use "IHq")
  (use "Truth")
  (assume "q" "IHq")
  (ng #t)
  (assume "p")
  (split)
  (use "Truth")
  (split)
  (use "Truth")
    (assert "all r1,r2(SOne r1 <= SZero r1 +r2)")
      (ind)
      (cases)
      (ng #t)
      (use "Truth")
      (assume "r2")
      (use "Truth")
      (assume "r2")
      (use "Truth")
      (assume "r1" "IHr1")
      (cases)
      (use "Truth")
      (assume "r2")
      (use "Truth")
      (assume "r2")
      (use "Truth")
      (assume "r1" "IHr1")
      (cases)
      (use "Truth")
      (assume "r2")
      (use "Truth")
      (assume "r2")
      (ng #t)
      (use "Truth")
    (assume "A2")
  (use "PosLeTrans" (pt "SZero q+p"))
  (use "A2")
  (ng #t)
  (use "IHq")
(save "PosLeRuleSet")

(set-goal "all p,q (SOne p <= (SOne p)*q) = (p <= p*q)")
  (assume "p" "q")
  (use "PosLeRuleSet")
(save "PosLeRuleSet1")
(add-rewrite-rule "SOne p <= (SOne p)*q" "p <= p*q")

(set-goal "all p,q(p <= q*p)")
  (assume "p" "q")
  (use "PosLeRuleSet")
(save "PosLeRuleSet2")
(add-rewrite-rule "p <= q*p" "T")

(set-goal "all p,q(q <= q*p)")
  (assume "p" "q")
  (use "PosLeRuleSet")
(save "PosLeRuleSet3")
(add-rewrite-rule "q <= q*p" "T")

(set-goal "all p,q ((p*q<= p) = (q <= 1) andi (p*q<= q) = (p <= 1))")
  (ind)
  (assume "q")
  (split)
  (use "Truth")
  (use "Truth")
  (assume "p" "IHp")
  (ng #t)
  (assume "r2")
  (split)
  (use "IHp")
  (use "BooleAeqToEq")
  (assume "Cond")
  (use "PosLeToNotLt" (pt "r2") (pt "SZero(p*r2)"))
  (use "Cond")
  (use "PosLtLeTrans" (pt "SZero r2"))
  (use "Truth")
  (ng #t)
  (use "Truth")
  (use "Efq")
  (assume "p" "IHp")
  (cases)
  (ng #t)
  (split)
  (use "Truth")
  (use "Truth")
  (assume "q")
  (ng #t)
  (split)
  (use "BooleAeqToEq")
  (assume "Cond")
  (use "PosLeToNotLt" (pt "p") (pt "SZero(p*q)+q"))
  (use "Cond")
  (use "PosLtTrans" (pt "p+q"))
  (use "Truth")
  (ng #t)
  (use "PosLtLeTrans" (pt "SZero p"))
  (use "Truth")
  (use "Truth")
  (use "Efq")
  (use "Truth")
  (assume "q")
  (ng #t)
  (split)
  (use "Truth")
  (use "BooleAeqToEq")
  (assume "Cond")
  (use "PosLeToNotLt" (pt "q") (pt "SZero(p*q)+q+p"))
  (use "Cond")
  (use "PosLtTrans" (pt "q+p"))
  (use "Truth")
  (ng #t)
  (use "Truth")
  (use "Efq")
(save "PosLeTimesCancleRulesLight")

(set-goal "all p,q ((p*q<=p)=(q=1))")
  (assume "p" "q")
  (ng #t)
  (use "PosLeTimesCancleRulesLight")
(save "PosLeTimesCancelRulesLight1")
(add-rewrite-rule "(p*q<= p)" "(q = 1)")

(set-goal "all p,q ((p*q<=q)=(p=1))")
  (assume "p" "q")
  (ng #t)
  (use "PosLeTimesCancleRulesLight")
(save "PosLeTimesCancelRulesLight2")
(add-rewrite-rule "(p*q<= q)" "(p = 1)")


(set-goal "all p,q (p<=q -> PosLog p<=PosLog q )")
(ind)
(ng #t)
(auto)
(assume "p")
(assume "Ih")
(ng #t)
(cases)
(ng #t)
(auto)
(assume "p" "Ih")
(cases)
(ng #t)
(auto)
(ng #t)
(assume "q")
(assume "pltq")
(use "Ih")
(use "PosLtToLe")
(auto)
(save "PosLogLeMon")


(set-goal "(p=q -> F) -> (p<q -> F) -> (p<=q -> F)")
(assume "p" "q")
(strip)
(use "PosLeCases" (pt "p") (pt "q"))
(auto)
(save "PQNotLeCases")



;; Compat from actual Minlog

(set-goal "all n,m(n<m -> 2**n<2**m)")
(ind)
;; 3,4
(cases)
(assume "Absurd")
(use "EfAtom")
(use "Absurd")
(assume "n" "Useless")
(use "Truth")
;; 4
(assume "n" "IH")
(cases)
(assume "Absurd")
(use "EfAtom")
(use "Absurd")
(assume "m")
(ng)
(use "IH")
;; Proof finished.
;; (cdp)
(save "PosLtMonPosExpTwo")


(set-goal "all q,p(p<q -> 2**p < 2**q)")
  (assume "q" "p" "Rel")
  (inst-with "PosLtMonPosExpTwo" (pt "PosToNat p") (pt "PosToNat q"))
  (use 2)
  (simp "NatLtToPos")
  (use "Rel")
(save "PosExpLtMon")