(display "loading int.scm extension")(newline)

;; Appendix
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;_____APPENDIX_____;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; PairConstrRewRule
(set-goal "all kj kj=(lft kj pair rht kj)")
(cases)
(ng #t)
(strip)
(use "Truth")
(save "PairConstrRewRule")

;; IntPlusCompat
(set-goal "all k0,k1,j0,j1(k0=k1 -> j0=j1-> k0+j0=k1+j1)")
(strip)
(simp 1)
(simp 2)
(use "Truth")
(save "IntPlusCompat")

(set-goal "all p,q,k,j(PosQR p q=(k pair j) -> p<q -> k=0 andnc p=j)")
(ind)
(cases)
(ng)
(assume "k" "j")
(simp "<-" "IfAndb")
(cases (pt "1=k"))
(ng)
(assume "0=k" "0=j" "Falsity")
(simp "<-""0=j")
(simp "<-" "0=k")
(ng #t)
(split)
(use "Falsity")
(use "Falsity")
(strip)
(use "Efq")
(use 3)
(ng)
(assume "p" "k" "j")
(simp "<-" "IfAndb")
(cases (pt "0=k"))
(assume "0=k")
(ng #t)
(assume "1=j")
(assume "Useless")
(split)
(simp "<-" "0=k")
(use "Truth")
(simp "<-""1=j")
(use "Truth")
(strip)
(ng)
(use "Efq")
(use 2)
(ng #t)
(assume "p" "k" "j")
(simp "<-" "IfAndb")
(cases (pt "0=k"))
(ng)
(assume "0=k" "1=j" "Useless")
(split)
(simp "0=k")
(use "Truth")
(simp "1=j")
(use "Truth")
(ng)
(assume "(0=k -> F)")
(use "Efq")
(assume "p" "Ih")
(assume "q" "k" "j")
(ng #t)
(inst-with-to "PairConstrRewRule" (pt "(PosQR p q)") "InstAssertion")
(simp "InstAssertion")
(cases (pt "2*rht(PosQR p q)<q"))
(assume "2*rht(PosQR p q)<q")
(ng #t)
(inst-with-to "Ih" (pt "q") (pt "lft(PosQR p q)") (pt "rht(PosQR p q)") "InstAssertion" "InstIh")
(cases (pt "2*lft(PosQR p q)=k"))
(assume "2*lft(PosQR p q)=k")
(ng #t)
(simp "2*rht(PosQR p q)<q")
(ng #t)
(simp "<-" "IfAndb")
(simp "<-" "2*lft(PosQR p q)=k")
(ng #t)
(assume "2*Rem")
(assume "SzeroIneq")
(split)
(assert "lft(PosQR p q)=0")
(use "InstIh")
(use "SZeroPosLtPosLt")
(use "SzeroIneq")
(assume "Assertion")
(simp "<-" "2*lft(PosQR p q)=k")
(simp "Assertion")
(ng #t)
(use "Truth")
(assert "p=rht(PosQR p q)")
(use "InstIh")
(use "SZeroPosLtPosLt")
(use "SzeroIneq")
(assume "p=rht(PosQR p q)")
(simp "<-" "2*Rem")
(simp  "<-" "p=rht(PosQR p q)")
(ng #t)
(use "Truth")
(assume "(2*lft(PosQR p q)=k -> F)")
(simp "2*rht(PosQR p q)<q")
(simp "(2*lft(PosQR p q)=k -> F)")
(ng #t)
(use "Efq")
(assume "(2*rht(PosQR p q)<q -> F)")
(ng #t)
(simp "(2*rht(PosQR p q)<q -> F)")
(ng #t)
(simp "<-" "IfAndb")
(cases (pt "(2*lft(PosQR p q)+1=k)"))
(assume "(2*lft(PosQR p q)+1=k)")
(ng #t)
(inst-with-to "Ih" (pt "q") (pt "lft(PosQR p q)") (pt "rht(PosQR p q)") "InstAssertion" "InstIh")
(assume "2*rht(PosQR p q)+IntN q=j")
(assume "SZero p<q")
(use "Efq")
(use "(2*rht(PosQR p q)<q -> F)")
(assert "p=rht(PosQR p q)")
(use "InstIh")
(use "SZeroPosLtPosLt")
(use "SZero p<q")
(assume "Assertion")
(simp "<-" "Assertion")
(ng #t)
(use "SZero p<q")
(assume "(2*lft(PosQR p q)+1=k -> F)")
(ng #t)
(use "Efq")
(assume "p" "Ih" "q" "k" "j")
(ng #t)
(inst-with-to "PairConstrRewRule" (pt "PosQR p q") "InstAssertion" )
(simp "InstAssertion")
(ng #t)
(inst-with-to "Ih" (pt "q") (pt "lft(PosQR p q)") (pt "rht(PosQR p q)") "InstAssertion" "InstIh")
(cases (pt "(2*rht(PosQR p q)+1<q)"))
(assume "(2*rht(PosQR p q)+1<q)")
(ng #t)
(simp "<-" "IfAndb")
(cases (pt "(2*lft(PosQR p q)=k)"))
(assume "(2*lft(PosQR p q)=k)")
(ng #t)
(assume "2*rht(PosQR p q)+1=j")
(assume "SOne p<q")
(assert "lft(PosQR p q)=0")
(use "InstIh")
(use "SOnePosLtPosLt")
(use "SOne p<q")
(assume "Assertion")
(simp "<-" "(2*lft(PosQR p q)=k)")
(simp "Assertion")
(ng #t)
(split)
(use "Truth")
(simp "<-" "2*rht(PosQR p q)+1=j")
(assert "p=rht(PosQR p q)")
(use "InstIh")
(use "SOnePosLtPosLt")
(use "SOne p<q")
(assume "p=rht(PosQR p q)")
(assert "SOne p=2*p+1")
(ng #t)
(use "Truth")
(assume "SOneToInt")
(simp "SOneToInt")
(simp "<-" "p=rht(PosQR p q)")
(ng #t)
(use "Truth")
(assume "(2*lft(PosQR p q)=k -> F)")
(ng #t)
(use "Efq")
(assume "(2*rht(PosQR p q)+1<q -> F)")
(ng #t)
(simp "<-" "IfAndb")
(ng #t)
(cases (pt "(2*lft(PosQR p q)+1=k)"))
(assume "2*lft(PosQR p q)+1=k")
(ng #t)
(assume "2*rht(PosQR p q)+1+IntN q=j")
(assume "SOne p<q")
(simp "<-" "2*rht(PosQR p q)+1+IntN q=j")
(ng #t)
(use "Efq")
(use "(2*rht(PosQR p q)+1<q -> F)")
(assert "p=rht(PosQR p q)")
(use "InstIh")
(use "SOnePosLtPosLt")
(use "SOne p<q")
(assume "p=rht(PosQR p q)")
(simp-with (pf "2=IntP 1+IntP 1"))
(ng #t)
(simp "<-" "p=rht(PosQR p q)")
(simp-with (pf "2=IntP 1+IntP 1"))
(ng #t)
(auto)
;;clear
(assume "(2*lft(PosQR p q)+1=k -> F)")
(ng #t)
(use "Efq")
(save "PosQREqPSpec")

(set-goal "all p,q(p<q->lft((PosQR p q))=0 andnc p=rht(PosQR p q))")
(assume "p" "q")
(assume "Ineq")
(use "PosQREqPSpec" (pt "q")) 
(ng)
(use "Truth")
(use "Ineq")
(save "PosQREqSpecCorr")

(add-program-constant "PosQuot" (py "pos=>pos=>int"))
(add-program-constant "PosRem" (py "pos=>pos=>int"))
(add-computation-rules "PosQuot p q" "lft(PosQR p q)")
(add-computation-rules "PosRem p q" "rht(PosQR p q)")

(set-totality-goal "PosQuot")
(use "AllTotalElim")
(assume "p")
(use "AllTotalElim")
(assume "p0")
(ng)
(use "IntTotalVar")
(save "PosQuotTotal")

(set-totality-goal "PosRem")
(use "AllTotalElim")
(assume "p")
(use "AllTotalElim")
(assume "p0")
(ng)
(use "IntTotalVar")
(save "PosRemTotal")

(set-goal "all p,q((p<q)->PosQuot p q=0)")
(assume "p" "q")
(assume "Ineq")
(ng #t)
(use "PosQREqSpecCorr")
(use "Ineq")
(save "PosQuotSpecCorr")

(set-goal "all p,q((p<q)->p=PosRem p q)")
(assume "p" "q")
(assume "Ineq")
(ng #t)
(use "PosQREqSpecCorr")
(use "Ineq")
(save "PosRemSpecCorr")

;; ;; PosQRCorr
;; (set-goal
;;  "all p,q(p=(PosQuot p q)*q+PosRem p q andnc 0<=PosRem p q andnc PosRem p q<q)")
;; (assume "p" "q")
;; (use "PosQRCorrAux")
;; (cases (pt "PosQR p q"))
;; (assume "k" "j" "EqHyp")
;; (ng)
;; (simp "EqHyp")
;; (use "Truth")
;; ;; Proof finished.
;; (save "PosQRCorr")

(set-goal "all k,j(k=j->k<=j)")
(cases)
(assume "p")
(cases)
(assume "p0")
(assume "eq")
(simp "eq")
(ng)
(use "Truth")
(ng)
(auto)
(ng)
(cases)
(auto)
(ng)
(assume "p" "j")
(assume "Eq")
(simp "Eq")
(ng)
(use "Truth")
(save "IntLeRefl")

(set-goal "all k,j(k eqd j -> k=j)")
(assume "k" "j")
(assume "Eq")
(simp "Eq")
(use "Truth")
(save "EqDToIntEq")

(set-goal "all k,j,p (k*p<j*p)=(k<j)")
(assume "k" "j" "p")
(use "BooleAeqToEq")
;; 3,4
(assume "kp<jp")
(use "IntNotLeToLt")
(assume "j<=k")
(assert "j*p<=k*p")
 (use "j<=k")
(use-with "IntLtLeTrans" (pt "k*p") (pt "j*p") (pt "k*p") "kp<jp")
;; 4
(assume "k<j")
(use "IntNotLeToLt")
(assume "jp<=kp")
(assert "j<=k")
 (use "jp<=kp")
(use-with "IntLtLeTrans" (pt "k") (pt "j") (pt "k") "k<j")
;; Proof finished.
(save "IntLtTimesIntPCancelRThm")

(set-goal "all k,j,p (k*p<=j*p)=(k<=j)")
(cases)
;; 2-4
(assume "p")
(cases)
;; 6-8
(assume "q" "r")
(use "Truth")
;; 7
(assume "q")
(use "Truth")
;; 8
(assume "q" "r")
(use "Truth")
;; 3
(cases)
;; 12-14
(strip)
(use "Truth")
;; 13
(strip)
(use "Truth")
;; 14
(strip)
(use "Truth")
;; 4
(assume "p")
(cases)
;; 19-21
(strip)
(use "Truth")
;; 20
(strip)
(use "Truth")
;; 21
(strip)
(use "Truth")
;; Proof finished
(save "IntLeTimesIntPCancelRThm")

(set-goal "all k((0<k)=(1<=k))")
(cases)
(auto)
(save "(0<k)=(1<=k)")

(set-goal "all n 0<IntS n")
(ind)
(auto)
(assume "n" "Ih")
(simp (pf "IntS(Succ n)=IntS(IntS n)"))
(use "IntLtTrans" (pt "IntS n"))
(use "Ih")
(auto)
(add-rewrite-rule "0<IntS n" "True")

(set-goal "all p (p=abs p)")
(ng #t)
(auto)
(save "AbsPosEqPos")

(set-goal "all p,q,k(q<p-> p--q=k -> p=k+q)")
(assume "p" "q")
(cases)
(assume "p0")
(ng #t)
(assume "cond")
(assume "1")
(simp "<-" "1")
(ng #t)
(simp "PosMinusPlus")
(ng #t)
(auto)
(assume "cond")
(ng #t)
(assume "1")
(use "Efq")
(auto)
(assume "p0")
(assume "cond")
(assume "1")
(simp "<-" "1")
(ng #t)
(simp "PosMinusPlus")
(ng #t)
(auto)
(save "PosMinusShift1")

; (set-goal "all k,j,p (k+p<=j+p)=(k<=j)")
; (ng #t)
; (auto)
; (add-rewrite-rule "k+p<=j+p" "k<=j")



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; list int extensions 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(add-var-name "kls" (py "list int"))

(add-program-constant "IntSumList" (py "list int=>int") t-deg-zero)
(add-computation-rules
 	"IntSumList (Nil int)" "Zero"
 	"IntSumList (k::kls) " "k+IntSumList kls")

(set-goal "k1+k2 = IntSumList(k1:)+k2")
(ng #t)
(auto)
(save "IntSumListElim0")

(set-goal "all p,q p<=p*q")
(assume "p")
(ind)
(ng #t)
(auto)
(assume "p0")
(assume "Ih")
(use "PosLeTrans" (pt "p*p0"))
(use "Ih")
(auto)
(add-rewrite-rule "p<=p*q" "True")

(set-goal "all p,q(p<q -> (q<p->F)) ")
(assume "p" "q")
(assume "p<q")
(assume "q<p")
(assert "p<p")
(use "PosLtTrans" (pt "q"))
(use "p<q")
(use "q<p")
(ng #t)
(auto)
(save "PosLtToNotLtS")

(set-goal "all p,q,r(p*q<r -> (r<q)->F)")
(assume "p")
(ng #t)
(assume "q")
(assume "r")
(assume "p*q<r")
(assume "r<q")
(use "PosLtToNotLtS" (pt "q") (pt "r"))
(use "PosLeLtTrans" (pt "p*q"))
(simp "PosTimesComm")
(auto)
(save "PosLtToNotLtTimes")

(set-goal "all p,q,k,j(PosQR p q=(k pair j) -> 0<=k)")
(assume "p" "q")
(cases)
(assume "p0")
(ng #t)
(auto)
(assume "p0")
(cases)
(assume "p1")
(assume "PosQRCond")
(inst-with-to "PairConstrRewRule" (pt "(IntN p0 pair IntP p1)") "InstAssertion")
(inst-with-to "PosQRCorrAux" (pt  "p") (pt "q") (pt "IntN p0") (pt "IntP p1") "PosQRCorrInst")
(ng)
(assert "p=[if (p0*q=p1) 0 [if (p0*q<p1) (p1--p0*q) (IntN(p0*q--p1))]]")
(use "PosQRCorrInst")
(auto)
(cases (pt "p0*q=p1"))
(ng #t)
(auto)
(assume "case2")
(ng #t)
(cases (pt "p0*q<p1"))
(ng #t)
(assume "p0*q<p1")
(assume "absurd")
(use "PosLtToNotLtTimes" (pt "p0") (pt "q") (pt "p1"))
(auto)
(use "PosQRCorrInst")
(auto)
(ng #t)
(assume "PosQRCond")
(inst-with-to "PairConstrRewRule" (pt "(IntN p0 pair 0)") "InstAssertion")
(inst-with-to "PosQRCorrAux" (pt  "p") (pt "q") (pt "IntN p0") (pt "0") "PosQRCorrInst")
(ng)
(use "PosQRCorrInst")
(auto)
(assume "p1")
(assume "PosQRCond")
(ng #t)
(inst-with-to "PairConstrRewRule" (pt "(IntN p0 pair IntN p1)") "InstAssertion")
(inst-with-to "PosQRCorrAux" (pt  "p") (pt "q") (pt "IntN p0") (pt "IntN p1") "PosQRCorrInst")
(ng)
(use "PosQRCorrInst")
(auto)
(save "PosQRLftNonNeg")

(set-goal "all k,j,i (k+j<=i+j->k<=i)")
(ng #t)
(auto)
(save "IntLePlusCancelRThm")

(set-goal "all k,j,i (j+k<=j+i->k<=i)")
(ng #t)
(auto)
(save "IntLePlusCancelLThm")

(set-goal "all k,j,i (0<=j->k<=i->j*k<=j*i)")
(assume "k")
(cases)
(ng #t)
(auto)
(ng #t)
(assume "p")
(assume "i" "F")
(use "Efq")
(auto)
(save "IntLeTimesCancelLThm")

(set-goal "all k,j,i (0<=j->k<=i->k*j<=i*j)")
(assume "k")
(cases)
(ng #t)
(auto)
(ng #t)
(assume "p")
(assume "i" "F")
(use "Efq")
(auto)
(save "IntLeTimesCancelRThm")

(set-goal "all k,j( k<=j -> (j<k -> F))")
(cases)
(assume "p")
(cases)
(assume "p0")
(ng #t)
(use "PosLeToNotLt")
(ng #t)
(use "Efq")
(assume "p0")
(ng #t)
(use "Efq")
(ng #t)
(cases)
(ng #t)
(assume "p" "T")
(use "Efq")
(ng #t)
(assume "T")
(use "Efq")
(ng #t)
(assume "p")
(use "Efq")
(assume "p")
(ng #t)
(cases)
(ng #t)
(assume "p0" "T")
(use "Efq")
(ng #t)
(assume "T")
(use "Efq")
(ng #t)
(assume "p0")
(use "PosLeToNotLt")
(save "IntLeToNotLt")

(set-goal "all k,j( k<j -> (j<=k -> F))")
(cases)
(assume "p")
(cases)
(assume "p0")
(ng #t)
(use "PosLtToNotLe")
(ng #t)
(use "Efq")
(assume "p0")
(ng #t)
(use "Efq")
(ng #t)
(cases)
(ng #t)
(assume "p" "T")
(use "Efq")
(ng #t)
(use "Efq")
(ng #t)
(assume "p")
(use "Efq")
(assume "p")
(ng #t)
(cases)
(ng #t)
(assume "p0" "T")
(use "Efq")
(ng #t)
(assume "T")
(use "Efq")
(ng #t)
(assume "p0")
(use "PosLtToNotLe")
(save "IntLtToNotLe")

(add-program-constant "IntToNat" (py "int=>nat"))
(add-computation-rules 
  "IntToNat (IntPos p)" "PosToNat p"
  "IntToNat (IntZero)" "Zero"
  "IntToNat (IntNeg p)" "Zero")

(set-totality-goal "IntToNat")
(assume "k^" "Tk")
(elim "Tk")
(assume "p^" "Tp")
(ng #t)
(use "PosToNatTotal")
(use "Tp")
(ng #t)
(use "NatTotalVar")
(assume "p^" "Tp")
(ng #t)
(use "NatTotalVar")
(save-totality)

;; IntEqSym
(set-goal "all i,k((i=k) = (k=i))")
(assume "i" "k")
(use "BooleAeqToEq")
(assume 1)
(simp 1)
(use "Truth")
(assume 1)
(simp 1)
(use "Truth")
(save "IntEqSym")

(add-program-constant "IntToPos" (py "int=>pos"))
(add-computation-rules
  "IntToPos (IntPos p)" "p"
  "IntToPos (IntNeg p)" "SZero One"
  "IntToPos (IntZero)" "One")

(set-totality-goal "IntToPos")
(assume "k^1" "Tk1")
(elim "Tk1")
(assume "p^1" "Tp1")
(ng #t)
(use "Tp1")
(ng #t)
(use "PosTotalVar")
(assume "p^2" "Tp2")
(ng #t)
(use "PosTotalVar")
(save-totality)

(set-goal "all i1,i2,i3((i1+i2 = i1+i3)=(i2=i3))")
(assume "i1" "i2" "i3")
(use "BooleAeqToEq")
(assume "Step")
(use "IntPlusCancelL" (pt "i1"))
(use "Step")
(assume "eq")
(simp "eq")
(use "Truth")
(save "IntEqPlusCancelL")

(set-goal "all i1,i2,i3((i2+i1 = i3+i1)=(i2=i3))")
(assume "i1" "i2" "i3")
(use "BooleAeqToEq")
(assume "Step")
(use "IntPlusCancelR" (pt "i1"))
(use "Step")
(assume "eq")
(simp "eq")
(use "Truth")
(save "IntEqPlusCancelR")

(set-goal "all k,j,i(0<k -> j<=i -> j*k<=i*k)")
(ind)
(assume "p")
(assume "j" "i")
(ng #t)
(assume 1)
(assume 1)
(use 2)
(assume "j" "i")
(ng #t)
(use "Efq")
(assume "p" "j" "i")
(ng #t)
(use "Efq")
(save "IntLeTimesCancelRInv")

(set-goal "all i(0<i -> IntToPos(i+1) = (IntToPos i)+1)")
(cases)
(ng #t)
(assume "p" 1)
(use 1)
(ng #t)
(use "Efq")
(assume "p")
(ng #t)
(assume 1)
(cases (pt "p=1"))
(ng #t)
(assume 1)
(use 1)
(assume 1)
(ng #t)
(use 1)
(save "IntToPosPlusOneDist")

(set-goal "all k(IntZero < k -> IntToPos(2*k) = 2*IntToPos k)")
(cases)
(assume "p")
(assume 1)
(ng #t)
(use 1)
(ng #t)
(use "Efq")
(assume "p")
(ng #t)
(use "Efq")
(save "IntToPosAssoc")

(set-goal "all i1,i2,i3(0 < abs i1 ->(i1*i2=i1*i3)=(i2=i3))")
(assume "i1" "i2" "i3")
(assume "Lim")
(use "BooleAeqToEq")
(use "IntTimesCancelL")
(use "Lim")
(assume "Eq")
(simp "Eq")
(use "Truth")
(save "IntEqTimesCancelL")

(set-goal "all i,k((i=k -> F)->(i < k) -> (k <= i->F))")
(cases)
(assume "p")
(cases)
(assume "q")
(ng #t)
(use "PosNotLeCases")
(ng #t)
(assume 1 1 1)
(use 2)
(assume "q")
(ng #t)
(assume 1 1 1)
(use 2)
(cases)
(assume "q")
(ng #t)
(assume 1 1 1)
(use 3)
(ng #t)
(assume 1 1 1)
(use 2)
(assume "q")
(ng #t)
(assume 1 1 1)
(use 2)
(assume "p")
(cases)
(assume "q")
(ng #t)
(assume 1 1 1)
(use 3)
(ng #t)
(assume 1 1 1)
(use 3)
(assume "q")
(ng #t)
(assume 1 1)
(use "PosNotLeCases")
(assume "q=p")
(use 1)
(simp "q=p")
(ng #t)
(auto)
(save "IntNotLeCases")

(set-goal "all i,k((i=k -> F)->(i < k) -> (k < i->F))")
(cases)
(assume "p")
(cases)
(assume "q")
(ng #t)
(use "PosNotLtCases")
(ng #t)
(assume 1 1 1)
(use 2)
(assume "q")
(ng #t)
(assume 1 1 1)
(use 2)
(cases)
(assume "q")
(ng #t)
(assume 1 1 1)
(use 3)
(ng #t)
(assume 1 1 1)
(use 2)
(assume "q")
(ng #t)
(assume 1 1 1)
(use 2)
(assume "p")
(cases)
(assume "q")
(ng #t)
(assume 1 1 1)
(use 3)
(ng #t)
(assume 1 1 1)
(use 3)
(assume "q")
(ng #t)
(assume 1 1)
(use "PosNotLtCases")
(assume "q=p")
(use 1)
(simp "q=p")
(auto)
(save "IntNotLtCases")

(set-goal "all p,i(0 <= i -> i<=i*p)")
(cases)
(ng #t)
(assume "i" 1)
(use "Truth")
(assume "p")
(cases)
(assume "q" 1)
(ng #t)
(simp "PosSZeroEqTimes")
(simp "PosTimesComm")
(simp (pf "q = q*One"))
(pp "PosLeTimesCancelL")
(inst-with "PosLeTimesCancelL" (pt "q") (pt "One") (pt "1*p*2"))
(ng 2)
(ng #t)
(simp 2)
(use "Truth")
(use "Truth")
(ng #t)
(assume 1)
(use "Truth")
(assume "q")
(ng #t)
(use "Efq")
(assume "p")
(cases)
(assume "q")
(ng #t)
(assume 1)
(use 1)
(ng #t)
(assume 1)
(use 1)
(assume "q")
(ng #t)
(use "Efq")
(save "IntLeTimesPos")

(set-goal "all i(0<i -> i<i*2)")
(cases)
(ng #t)
(assume "p")
(assume 1)
(use 1)
(ng #t)
(use "Efq")
(assume "p")
(ng #t)
(use "Efq")
(save "IntLtTimesTwo")

(set-goal "all i(0<i -> IntToPos(2*i+1) = 2*(IntToPos i)+1)")
(cases)
(assume "p")
(ng #t)
(assume 1)
(use 1)
(ng #t)
(assume 1)
(use 1)
(assume "p")
(ng #t)
(assume 1)
(use 1)
(save "IntToPosTimesTwoPlusOneDist")

(set-goal "all k,j,i((k+j < i+j) = (k < i))")
(ng #t)
(assume "k""j" "i")
(use "Truth")
(save "IntLtCancelR")

(set-goal "all k,j,i ((i+k<i+j) = (k<j))")
(ng #t)
(assume "k" "j" "i")
(use "Truth")
(save "IntLtCancelL")

;; IntLePlusCancelR
(set-goal "all k,j,i (k+j<=i+j)=(k<=i)")
(assert "all j,k,i (k+j<=i+j)=(k<=i)")
(cases)
;; 4-6
(ind)
(assume "k" "i")
(simp "IntPlusOneIntS")
(simp "IntPlusOneIntS")
(use "Truth")
;; 8
(assume "p" "IH" "k" "i")
(simp "IntPlusIdIntPSZero")
(simp "IntPlusIdIntPSZero")
(use "BooleEqTrans" (pt "k+p<=i+p"))
(use "IH")
(use "IH")
;; 9
(assume "p" "IH" "k" "i")
(simp "IntPlusIdIntPSOne")
(simp "IntPlusIdIntPSOne")
(simp "IntPlusIdIntPSZero")
(simp "IntPlusIdIntPSZero")
(use "BooleEqTrans" (pt "k+p+p<=i+p+p"))
(use "Truth")
(use "BooleEqTrans" (pt "k+p<=i+p"))
(use "IH")
(use "IH")
;; 5
(assume "k" "i")
(use "Truth")
;; 6
(ind)
(assume "k" "i")
(simp "IntPlusIntNOneIntPred")
(simp "IntPlusIntNOneIntPred")
(simp "<-" "IntPlusIntNOneIntPred")
(simp "<-" "IntPlusIntNOneIntPred")
;; ?_35:(k+IntN 1<=i+IntN 1)=(k<=i)
(simp "IntPlusIntNOneIntPred")
(simp "IntPlusIntNOneIntPred")
(use "Truth")
;; 29
(assume "p" "IH" "k" "i")
(simp "IntPlusIdIntNSZero")
(simp "IntPlusIdIntNSZero")
(simp "IH")
(use "IH")
;; 30
(assume "p" "IH" "k" "i")
(simp "IntPlusIdIntNSOne")
(simp "IntPlusIdIntNSOne")
(ng)
; (simp "IntPlusIdIntNSZero")
; (simp "IntPlusIdIntNSZero")
; (simp "IH")
; (use "IH")
(use "Truth")
;; Assertion proved.
(assume "Assertion" "k" "j" "i")
(use "Assertion")
;; Proof finished.
(add-rewrite-rule "k+j<=i+j" "k<=i")
(save "IntLePlusCancelR")

;; IntLePlusCancelL
(set-goal "all k,j,i (k+j<=k+i)=(j<=i)")
(assume "k" "j" "i")
(simp "IntPlusComm")
(simp (pf "k+i=i+k"))
(use "Truth")
(use "IntPlusComm")
;; Proof finished.
(add-rewrite-rule "k+j<=k+i" "j<=i")
(save "IntLePlusCancelL")

(set-goal "all p(p = PosS p -> F)")
  (ind)
  (ng #t)
  (assume "Useless")
  (use "Useless")
  (assume "p" "IHp")
  (ng #t)
  (assume "Useless")
  (use "Useless")
  (assume "p" "IHp")
  (ng #t)
  (assume "Useless")
  (use "Useless")
(save "PosIdNotEqPosS")

(set-goal "all p,q(p=p+q -> F)")
 (ind)
 (ng #t)
 (cases)
 (ng #t)
 (assume "Fa")
 (use "Fa")
 (ng #t)
 (assume "q" "Fa")
 (use "Fa")
 (ng #t)
 (assume "q" "Fa")
 (use "Fa")
 (assume "p" "IHp")
 (cases)
 (ng #t)
 (auto)
 (assume "p" "IHp")
 (cases)
 (auto)
(save "PosPlusNotEqId")

(set-goal "all p,q(IntPos(PosPlus p q) = IntPlus (IntPos p) (IntPos q))")
  (ng #t)
  (assume "p" "q")
  (use "Truth")
(save "IntPlusEqPosPlusPos")

(set-goal "all i,k(k<=i -> (i=k -> F) -> k<i)")
(cases)
(ind)
(cases)
(assume "q")
(ng #t)
(assume 1 1)
(use 2)
(simp 1)
(use "Truth")
(ng #t)
(assume 1 1)
(use 1)
(assume "q")
(ng #t)
(assume 1 1)
(use 1)
(assume "p" "IH")
(assume "k")
(simp "PosSZeroEqPlus")
(simp (pf "(k<=p+p) = (k-p<=p)"))
(simp (pf "(p+p=k) = (p=k-p)"))
(simp (pf "(k<p+p)=(k-p < p)"))
(use "IH")
(inst-with "IntLtCancelR" (pt "k+IntN p") (pt "IntPos p") (pt "IntPos p"))
(ng 2)
(simp (pf "(k<p+p) = (k+0<p+p)"))
(simp (pf "0 = IntN p +IntPos p"))
(simp "IntPlusAssoc")
(use 2)
(use "Truth")
(use "Truth")
(inst-with "IntEqPlusCancelR" (pt "IntPos p") (pt "IntPos p") (pt "k+IntN p"))
(ng 2)
(simp (pf "(p+p=k)=(p+p=k+0)"))
(simp (pf "0 = IntN p+p"))
(simp "IntPlusAssoc")
(use 2)
(use "Truth")
(use "Truth")
(inst-with "IntLePlusCancelR" (pt "k+IntN p") (pt "IntPos p") (pt "IntPos p"))
(simp (pf "(k<=p+p) = (k+0<=p+p)"))
(simp (pf "0 = IntN p +IntPos p"))
(simp "IntPlusAssoc")
(use 2)
(use "Truth")
(use "Truth")
(assume "p" "IH")
(ng #t)
(assume "k")
(simp (pf "SOne p = p+p+1"))
(simp (pf "(k<=p+p+1) = (k-p-1<=p)"))
(simp (pf "(p+p+1=k) = (p=k-p-1)"))
(simp (pf "(k<p+p+1)=(k-p-1 < p)"))
(use "IH")
(inst-with "IntLtCancelR" (pt "k+IntN p+IntN One") (pt "IntPos p+IntPos One") (pt "IntPos p"))
(simp (pf "(k<p+p+1) = (k+0<p+p+1)"))
(simp (pf "0 = IntN p +IntN 1+PosS p"))
(simp "IntPlusAssoc")
(simp "IntPlusAssoc")
(ng 2)
(use 2)
(use "Truth")
(use "Truth")
(inst-with "IntEqPlusCancelR" (pt "IntPos p+IntPos One") (pt "IntPos p") (pt "k+IntN p+IntN One"))
(ng 2)
(simp (pf "(p+p+1=k)=(p+p+1=k+0)"))
(simp (pf "0 = IntN p+IntN 1+PosS p"))
(simp "IntPlusAssoc")
(simp "IntPlusAssoc")
(use 2)
(use "Truth")
(use "Truth")
(inst-with "IntLePlusCancelR" (pt "k+IntN p+IntN One") (pt "IntPos p+IntPos One") (pt "IntPos p"))
(simp (pf "(k<=p+p+1) = (k+0<=p+p+1)"))
(simp (pf "0 = IntN p+IntN 1+PosS p"))
(simp "IntPlusAssoc")
(simp "IntPlusAssoc")
(use 2)
(use "Truth")
(use "Truth")
(use "Truth")
(ng #t)
(cases)
(ng #t)
(assume "p")
(assume 1 1)
(use 1)
(ng #t)
(assume 1 1)
(use 2)
(use 1)
(assume "p")
(ng #t)
(assume 1 1)
(use 1)
(ind)
(cases)
(assume "q")
(ng #t)
(assume 1 1)
(use 1)
(ng #t)
(assume 1 1)
(use 1)
(assume "q")
(ng #t)
(assume 1 1)
(use "PosNotLeToLt")
(ng #t)
(assume "q=1")
(use 2)
(simp "q=1")
(auto)
(assume "p" "IH")
(assume "k")
(ng #t)
(assume 1 1)
(simp "PosSZeroEqPlus")
(simp (pf "(k<IntN(p+p)) = (k+ IntPos p < IntN p)"))
(use "IH")
(inst-with "IntLePlusCancelR" (pt "k") (pt "IntPos p") (pt "IntN (p+p)"))
(simp (pf "(IntN p) = (IntN(p+p)+p)"))
(simp 4)
(simp "<-" "PosSZeroEqPlus")
(use 2)
(ng #t)
  (assert "all p (p+p=p->F)")
    (ind)
    (ng #t)
    (assume 1)
    (use 5)
    (assume "r" "IHr")
    (ng #t)
    (use "IHr")
    (assume "r" "IHr")
    (ng #t)
    (assume 1)
    (use 6)
  (assume "C1")
(simp "C1")
(ng #t)
(use "Truth")
(inst-with "IntEqPlusCancelR" (pt "IntPos p") (pt "IntN(p+p)") (pt "k"))
(simp (pf "IntN p =(IntN(p+p)+p)"))
(simp 4)
(simp "<-" "PosSZeroEqPlus")
(use 3)
(ng #t)
   (assert "all p (p+p=p->F)")
    (ind)
    (ng #t)
    (assume 1)
    (use 5)
    (assume "r" "IHr")
    (ng #t)
    (use "IHr")
    (assume "r" "IHr")
    (ng #t)
    (assume 1)
    (use 6)
  (assume "C1")
(simp "C1")
(use "Truth")
(inst-with "IntLtCancelR" (pt "k") (pt "IntPos p") (pt "IntN (p+p)"))
(simp (pf "IntN p = IntN(p+p)+p"))
(simp 4)
(use "Truth")
(ng #t)
  (assert "all p (p+p=p->F)")
    (ind)
    (ng #t)
    (assume 1)
    (use 5)
    (assume "r" "IHr")
    (ng #t)
    (use "IHr")
    (assume "r" "IHr")
    (ng #t)
    (assume 1)
    (use 6)
  (assume "C1")
(simp "C1")
(use "Truth")
(assume "p" "IH")
(assume "k")
(assume 1 1)
(simp (pf "(k<IntN(SOne p)) = (k+(IntPos p+1)<IntN p)"))
(use "IH")
(inst-with "IntLePlusCancelR" (pt "k") (pt "IntPos (p+1)") (pt "IntN (p+p+1)"))
(simp (pf "(IntPlus p 1)=(p+1)"))
(simp (pf "IntN p = (IntN(p+p+1)+(p+1))"))
(simp 4)
(use 2)
(ng #t)
  (assert "all p(SOne p = PosS p ->F)")
    (cases)
    (ng #t)
    (assume 1)
    (use 5)
    (assume "r")
    (ng #t)
    (assume 1)
      (assert "all p (SZero p = p-> F)")
        (ind)
        (ng #t)
        (assume 1)
        (use 6)
        (assume "r1" "IHr1")
        (ng #t)
        (use "IHr1")
        (assume "r1" "IHr1")
        (ng #t)
        (assume 1)
        (use 7)
      (assume "c1")
(use "c1" (pt "r"))
(use 5)
(ng #t)
(assume "r" "Fals")
(use "Fals")
(assume "C1")
(simp "C1")
(ng #t)
  (assert "all p(SOne p <= p->F)")
    (ind)
    (ng #t)
    (assume 1)
    (use 6)
    (assume "r1" "IHr1")
    (ng #t)
    (use "Efq")
    (assume "r1" "IHr1")
    (ng #t)
    (use "IHr1")
  (assume "ass1")
(simp "ass1" (pt "p"))
(ng #t)
  (assert "all p (PosS p <= SOne p -> p = SOne p --PosS p)")
    (ind)
    (ng #t)
    (assume 1)
    (use 7)
    (assume "r" "IHr")
    (ng #t)
    (simp "PosSZeroEqPlus")
    (ng #t)
    (assume 1)
    (use 8)
    (assume "r" "IHr")
    (ng #t)
    (assume 1)
    (simp "C1")
    (ng #t)
    (use "IHr")
    (use 8)
  (assume "ass2")
(use "ass2")
(use "PosNotLtToLe")
(use "ass1")
(use "Truth")
(inst-with "IntEqPlusCancelR" (pt "IntN p+IntN 1") (pt "k+IntPos p+IntPos 1") (pt "IntN p"))
(simp "IntEqSym")
(simp (pf "(k+IntPlus p 1) = k+p+1"))
(simp "<-" 4)
(ng #t)
(simp (pf "k+p+1+IntN(PosS p) = k"))
(simp "IntEqSym")
(use 3)
(simp "IntPlusComm")
(simp (pf "k+p+1=p+1+k"))
(ng #t)
(auto)
(simp "IntPlusComm")
(simp "IntPlusAssoc")
(simp "IntPlusComm")
(simp "IntPlusAssoc")
(simp "IntPlusEqPosPlusPos")
(ng #t)
(use "Truth")
(simp "IntEqSym")
(simp "IntPlusComm")
(ng #t)
(simp "IntPlusComm")
(ng #t)
(simp "IntPlusComm")
(use "Truth")
(simp "<-" "IntPlusEqPosPlusPos")
(ng #t)
(ng #t)
(inst-with "IntLtCancelR" (pt "k+(IntPos p +IntPos 1)") (pt "IntN p+IntN 1") (pt "IntN p"))
(simp (pf "(k<IntN(SOne p)) = (k+0<IntN(SOne p))"))
(simp (pf "0 = PosS p+IntN (PosS p)"))
(ng 4)
(simp "IntPlusAssoc")
(simp "<-" 4)
(use "Truth")
(use "Truth")
(use "Truth")
(save "IntLtCases")

(set-goal "all i,j,k(0 < abs i ->(i*j=i*k)=(j=k))")
(assume "i" "j" "k" "Cond")
(ng #t)
(use "BooleAeqToEq")
(assume "EqHyp")
(use "IntTimesCancelL" (pt "i"))
(use "Cond")
(use "EqHyp")
(assume "EqHyp")
(simp "EqHyp")
(use "Truth")
(save "IntTimesCancelLSW")

(set-goal "all i,j((i<=j) = (~j <= ~i))")
(ng #t)
(assume "i" "j")
(use "Truth")
(save "IntLeToNegLe")

(set-goal "all i,j,k(i+j < i+k-> j<k)")
(search)
(save "IntLtPlusCancelLImp")

;; __________ Term Trans Lib _______________

;;(add-program-constant "IntToNat" (py "int=>nat"))
;;(add-computation-rules 
;;  "IntToNat (IntPos p)" "PosToNat p"
;;  "IntToNat (IntZero)" "Zero"
;;  "IntToNat (IntNeg p)" "Zero")
;;
;;(set-totality-goal "IntToNat")
;;  (assume "k^" "Tk")
;;  (elim "Tk")
;;  (assume "p^" "Tp")
;;  (ng #t)
;;  (use "PosToNatTotal")
;;  (use "Tp")
;;  (ng #t)
;;  (use "NatTotalVar")
;;  (assume "p^" "Tp")
;;  (ng #t)
;;  (use "NatTotalVar")
;;(save-totality)

(set-goal "all p,q(p = lft(PosQR p q)*q+rht(PosQR p q))")
  (ind)
  (cases)
  (use "Truth")
  (assume "p")
  (use "Truth")
  (assume "p")
  (use "Truth")
  (assume "p" "IH" "q")
  (ng #t)
  (cases (pt "PosQR p q"))
  (assume "k1" "k2")
  (assume "c1")
  (ng #t)
  (cases (pt "2*k2<q"))
  (assume "c2")
  (ng #t)
  (simp (pf "2*k1*q + 2*k2  = 2*(k1*q+k2)"))
  (simp "PosSZeroTimes")
  (inst-with-to "IntEqTimesCancelL" (pt "IntPos 2") (pt "IntPos p") (pt "k1*q+k2") "TimesC")
  (simp (pf "2*p = IntTimes 2 p"))
  (simp "TimesC")
  (simp (pf "k1 = lft(PosQR p q)"))
  (simp (pf "k2 = rht(PosQR p q)"))
  (use "IH")
  (simp "c1")
  (use "Truth")
  (simp "c1")
  (use "Truth")
  (use "Truth")
  (use "Truth")
  (use "Truth")
  (assume "nCase2")
  (ng #t)
  (simp (pf "2*k1*q+q+2*k2+IntN q = 2*k1*q+2*k2+q+IntN q"))
  (simp "IntPlusComm")
  (ng #t)
  (simp "IntPlusComm")
  (ng #t)
  (simp (pf "2*k1*q+2*k2=2*(k1*q+k2)"))
  (simp "PosSZeroTimes")
  (inst-with-to "IntEqTimesCancelL" (pt "IntPos 2") (pt "IntPos p") (pt "k1*q+k2") "TimesC")
  (simp (pf "2*p = IntTimes 2 p"))
  (simp "TimesC")
  (simp (pf "k1 = lft(PosQR p q)"))
  (simp (pf "k2 = rht(PosQR p q)"))
  (use "IH")
  (simp "c1")
  (use "Truth")
  (simp "c1")
  (use "Truth")
  (use "Truth")
  (use "Truth")
  (use "Truth")
  (pp "IntEqPlusCancelL")
  (simp-with "IntEqPlusCancelL" (pt "2*k1*q") (pt "q+2*k2+IntN q") (pt "2*k2+q+IntN q"))
  (simp "IntPlusComm")
  (ng #t)
  (simp "IntEqSym")
  (simp "IntPlusComm")
  (ng #t)
  (simp "IntPlusComm")
  (ng #t)
  (use "Truth")
  (assume "p" "IH" "q")
  (ng #t)
  (cases (pt "PosQR p q"))
  (assume "k1" "k2" "c1")
  (ng #t)
  (cases (pt "2*k2+1<q"))
  (assume "c2")
  (ng #t)
  (simp (pf "SOne p = 2*p+1"))
  (inst-with-to "IntEqPlusCancelR" (pt "IntPos 1") (pt "IntPos 2*p") (pt "2*k1*q+2*k2") "PlusCancel")
  (simp (pf "2*p+1 = IntTimes 2 p +1"))
  (simp "PlusCancel")
  (inst-with-to "IntTimesPlusDistr" (pt "IntPos 2") (pt "k1*q") (pt "k2") "Dist")
  (simp (pf "2*k1*q = 2*(k1*q)"))
  (simp "<-" "Dist")
  (inst-with-to "IntEqTimesCancelL" (pt "IntPos 2") (pt "IntPos p") (pt "k1*q+k2") "TimesC")
  (simp "TimesC")
  (simp (pf "k1 = lft(PosQR p q)"))
  (simp (pf "k2 = rht(PosQR p q)"))
  (use "IH")
  (simp "c1")
  (use "Truth")
  (simp "c1")
  (use "Truth")
  (use "Truth")
  (use "Truth")
  (use "Truth")
  (use "Truth")
  (assume "nc2")
  (ng #t)
  (simp (pf "SOne p = 2*p+1"))
  (simp (pf "2*k1*q+q+2*k2+1+IntN q = 2*k1*q+2*k2+q+IntN q + 1"))
  (inst-with-to "IntEqPlusCancelR" (pt "IntPos 1") (pt "IntPos 2*p") (pt "2*k1*q+2*k2+q+IntN q") "CancR")
  (simp (pf "2*p+1 = IntTimes 2 p +1"))
  (simp  "CancR")
  (simp "IntPlusComm")
  (ng #t)
  (simp "IntPlusComm")
  (ng #t)
  (inst-with-to "IntTimesPlusDistr" (pt "IntPos 2") (pt "k1*q") (pt "k2") "disnt")
  (simp "PosSZeroTimes")
  (simp (pf "2*k1*q = 2*(k1*q)"))
  (simp "<-" "disnt")
  (inst-with-to "IntEqTimesCancelL" (pt "IntPos 2") (pt "IntPos p") (pt "k1*q+k2") "CanL")
  (simp (pf "2*p = IntTimes 2 p"))
  (simp "CanL")
  (simp (pf "k1=lft(PosQR p q)"))
  (simp (pf "k2=rht(PosQR p q)"))
  (use "IH")
  (simp "c1")
  (use "Truth")
  (simp "c1")
  (use "Truth")
  (use "Truth")
  (use "Truth")
  (use "Truth")
  (use "Truth")
  (inst-with-to "IntEqPlusCancelL" (pt "2*k1*q") (pt "q+2*k2+1+IntN q") (pt "2*k2+q+IntN q+1") "PCanL")
  (simp "PCanL")
  (ng #t)
  (simp "IntPlusComm")
  (ng #t)
  (simp "IntEqSym")
  (inst-with-to "IntEqPlusCancelL" (pt "2*k2") (pt "q+IntN q+1") (pt "IntPos 1") "PCanL2")
  (simp (pf "2*k2+q+IntN q+1 = 2*k2+(q+IntN q+1)"))
  (simp "PCanL2")
  (use "Truth")
  (ng #t)
  (inst-with-to "IntEqPlusCancelR" (pt "IntPos 1") (pt "2*k2+q+IntN q") (pt "2*k2") "PCan3")
  (simp "PCan3")
  (simp "IntPlusComm")
  (ng #t)
  (simp "IntPlusComm")
  (use "Truth")
  (use "Truth")
(save "IntPosQRRWRule")

(set-goal "all p,q(p<q -> lft(PosQR p q) = 0)")
  (ind)
  (cases)
  (ng #t)
  (use "Efq")
  (assume "p")
  (ng #t)
  (assume 1)
  (use 1)
  (assume "p")
  (ng #t)
  (assume 1)
  (use 1)
  (assume "p" "IH" "q")
  (ng #t)
  (assume "Case")
  (cases (pt "PosQR p q"))
  (assume "k1" "k2")
  (assume "c1")
  (ng #t)
  (cases (pt "2*k2<q"))
  (assume "c2")
  (ng #t)
  (simp (pf "k1 = lft(PosQR p q)"))
  (simp (pf "0 = 2*0"))
  (inst-with "IntEqTimesCancelL" (pt "IntPos 2") (pt "lft(PosQR p q)") (pt "IntZero"))
  (simp 5)
  (use "IH")
  (use "PosLtTrans" (pt "SZero p"))
  (use "Truth")
  (use "Case")
  (use "Truth")
  (use "Truth")
  (simp "c1")
  (use "Truth")
  (assume "nc2")
  (ng #t)
    (assert "k1=0")
      (simp (pf "k1 = lft(PosQR p q)"))
      (use "IH")
      (use "PosLtTrans" (pt "SZero p"))
      (use "Truth")
      (use "Case")
      (simp "c1")
      (use "Truth")
    (assume "ass1")
  (simp "ass1")
  (ng #t)
  (use "nc2")
    (assert "p = lft(PosQR p q)*q+rht(PosQR p q)")
      (use "IntPosQRRWRule")
    (assume "ass2")
  (simphyp-with "ass2" "c1")
  (ng 7)
  (simphyp-with 7 "ass1")
  (ng 8)
  (simp "<-" 8)
  (ng #t)
  (use "Case")
  (assume "p" "IH" "q" "Case")
  (ng #t)
  (cases (pt "PosQR p q"))
  (assume "k1" "k2")
  (assume "c1")
  (ng #t)
  (cases (pt "2*k2+1<q"))
  (assume "c2")
  (ng #t)
  (simp (pf "k1 = lft(PosQR p q)"))
  (simp (pf "0=2*0"))
  (inst-with "IntEqTimesCancelL" (pt "IntPos 2") (pt "lft(PosQR p q)") (pt "IntZero"))
  (simp 5)
  (use "IH")
  (use "PosLtTrans" (pt "SOne p"))
  (use "Truth")
  (use "Case")
  (use "Truth")
  (use "Truth")
  (simp "c1")
  (use "Truth")
  (assume "nc2")
  (ng #t)
    (assert "k1=0")
      (simp (pf "k1 = lft(PosQR p q)"))
      (use "IH")
      (use "PosLtTrans" (pt "SOne p"))
      (use "Truth")
      (use "Case")
      (simp "c1")
      (use "Truth")
    (assume "ass1")
  (simp "ass1")
  (ng #t)
  (use "nc2")
    (assert "p = lft(PosQR p q)*q+rht(PosQR p q)")
      (use "IntPosQRRWRule")
    (assume "ass2")
  (simphyp-with "ass2" "c1")
  (ng 7)
  (simphyp-with 7 "ass1")
  (ng 8)
  (simp "<-" 8)
  (ng #t)
  (use "Case")
(save "PosQRK1EqZero")

(set-goal "all i(i=0 -> ~i = 0)")
  (cases)
  (ng #t)
  (assume "p")
  (auto)
(save "IntEqZeroLM1")

(set-goal "all p,q(lft(PosQR p q) = 0 -> p<q)")
  (assume "p" "q")
  (cases (pt "PosQR p q"))
  (assume "k1" "k2")
  (assume "c1")
  (ng #t)
  (assume 1)
  (simp (pf "(p<q) = (IntLt (IntPos p)(IntPos q))"))
  (simp "IntPosQRRWRule" (pt "q"))
  (simp "c1")
  (ng #t)
  (simp 2)
  (ng #t)
  (simp (pf "k2 = rht(PosQR p q)"))
  (use "PosQRCorr")
  (simp "c1")
  (use "Truth")
  (use "Truth")
(save "PosQRLtpqElim1")

(set-goal "all k,j,i ((i+k<i+j) = (k<j))")
  (ng #t)
  (assume "k" "j" "i")
  (use "Truth")
(save "intLtCancelL")

(set-goal "all i,j,k(i+j < i+k-> j<k)")
  (search)
(save "IntLtPlusCancelL")

(set-goal "all n((IntPlus 1 n) = IntS n)")
  (ind)
  (ng #t)
  (use "Truth")
  (assume "n" "IH")
  (ng #t)
  (simp "IH")
  (use "Truth")
(save "IntPlusOneNatEqIntS")
(add-rewrite-rule "IntPlus 1 n" "IntS n")

(set-goal "all i,j,k( 0<i -> (i*j<i*k)=(j<k))")
  (cases)
  (ind)
  (ng #t)
  (assume "j" "k")
  (auto)
  (assume "j" "k")
  (ng #t)
  (use "Efq")
  (assume "p" "j" "k")
  (ng #t)
  (use "Efq")
(save "IntLtTimesCancleLSW")

(set-goal "all i,j,k( i<0 -> (i*j<i*k)=(k<j))")
  (cases)
  (assume "p" "j" "k")
  (ng #t)
  (use "Efq")
  (assume "j" "k")
  (ng #t)
  (use "Efq")
  (ng #t)
  (auto)
(save "IntLtTimesCancleLSW2")

(set-goal "all p(PosQR p 1 = (p pair 0))")
  (ind)
  (use "Truth")
  (assume "p" "IHp")
  (ng #t)
  (simp "IHp")
  (ng #t)
  (use "Truth")
  (assume "p" "IHp")
  (ng #t)
  (simp "IHp")
  (ng #t)
  (use "Truth")
(save "PosQR1Rule")
(add-rewrite-rule "PosQR p 1" "((IntPos p) pair 0)")

(add-program-constant "IntDivRem" (py "int=>int=>(int yprod int)"))

(add-computation-rules
  "IntDivRem (IntPos p) (IntPos q)" "(PosQR p q)"
  "IntDivRem (IntNeg p) (IntPos q)" "(~(lft(PosQR p q)) pair rht(PosQR p q))"
  "IntDivRem (IntPos p) (IntNeg q)" "(~(lft(PosQR p q)) pair rht(PosQR p q))"
  "IntDivRem (IntNeg p) (IntNeg q)" "(PosQR p q)"
  "IntDivRem (IntZero) k" "(IntZero pair IntZero)"
  "IntDivRem k IntZero" "(IntZero pair IntZero)"
  )

(set-totality-goal "IntDivRem")
  (use "AllTotalElim")
  (cases)
  (assume "p")
  (use "AllTotalElim")
  (cases)
  (ng #t)
  (assume "q")
  (use "PosQRTotal")
  (use "PosTotalVar")
  (use "PosTotalVar")
  (ng #t)
  (use "TotalYprodPairConstr")
  (use "IntTotalVar")
  (use "IntTotalVar")
  (assume "q")
  (ng #t)
  (use "YprodTotalVar")
  (use "AllTotalElim")
  (assume "k")
  (ng #t)
  (use "YprodTotalVar")
  (assume "p")
  (use "AllTotalElim")
  (cases)
  (ng #t)
  (assume "q")
  (use "YprodTotalVar")
  (ng #t)
  (use "TotalYprodPairConstr")
  (use "IntTotalVar")
  (use "IntTotalVar")
  (assume "q")
  (ng #t)
  (use "PosQRTotal")
  (use "PosTotalVar")
  (use "PosTotalVar")
(save-totality)

(set-goal "all k1,p(0<=k1-> k1<=p*k1)")
  (ind)
  (assume "p" "q")
  (ng #t)
  (auto)
  (assume "p" "q")
  (ng #t)
  (use "Efq")
(save "IntPosLemma1")

(set-goal "all p,q(0 <= lft(PosQR p q))")
    (assert "all i(2*i = i+i)")
      (cases)
      (ng #t)
      (assume "r")
      (simp "PosSZeroPlus")
      (use "Truth")
      (use "Truth")
      (assume "r")
      (ng #t)
      (use "PosSZeroPlus")
    (assume "A1")
  (ind)
  (cases)
  (auto)
  (assume "p" "IHp")
  (assume "q")
  (ng #t)
  (cases (pt "PosQR p q"))
  (assume "k1" "k2" "Trans")
  (ng #t)
  (cases (pt "2*k2<q"))
  (assume "C1")
  (ng #t)
  (simp (pf "k1 = lft(PosQR p q)"))
  (use "IntLeTrans" (pt "lft(PosQR p q)"))
  (use "IHp")
  (simp "A1")
  (simp (pf "lft(PosQR p q) = lft(PosQR p q) + 0"))
  (inst-with "IntLePlusCancelL" (pt "lft(PosQR p q)") (pt "0") (pt "lft(PosQR p q)+0"))
  (ng)
  (simp 5)
  (use "IHp")
  (use "Truth")
  (simp "Trans")
  (use "Truth")
  (assume "nC1")
  (ng #t)
  (use "IntLeTrans" (pt "2*k1"))
  (ng #t)
  (use "IntLeTrans" (pt "k1"))
  (simp (pf "k1 = lft(PosQR p q)"))
  (use "IHp")
  (simp "Trans")
  (use "Truth")
  (simp (pf "2*k1 = k1+k1"))
  (inst-with "IntLePlusCancelL" (pt "k1") (pt "0") (pt "k1"))
  (ng 5)
  (simp 5)
  (simp (pf "k1 = lft(PosQR p q)"))
  (use "IHp")
  (simp "Trans")
  (use "Truth")
  (use "A1")
  (use "Truth")
  (assume "p" "IHp")
  (assume "q")
  (ng #t)
  (cases (pt "PosQR p q"))
  (assume "k1" "k2")
  (assume "Trans")
  (ng #t)
  (cases (pt "2*k2+1<q"))
  (assume "C1")
  (ng #t)
  (use "IntLeTrans" (pt "k1"))
  (simp (pf "k1 = lft(PosQR p q)"))
  (use "IHp")
  (simp "Trans")
  (use "Truth")
  (simp "A1")
  (inst-with "IntLePlusCancelL" (pt "k1") (pt "0") (pt "k1"))
  (ng 5)
  (simp 5)
  (simp (pf "k1 = lft(PosQR p q)"))
  (use "IHp")
  (simp "Trans")
  (use "Truth")
  (assume "nC1")
  (ng #t)
  (use "IntLeTrans" (pt "2*k1"))
  (use "IntLeTrans" (pt "k1"))
  (simp (pf "k1 = lft(PosQR p q)"))
  (use "IHp")
  (simp "Trans")
  (use "Truth")
  (simp "A1")
  (inst-with "IntLePlusCancelL" (pt "k1") (pt "0") (pt "k1"))
  (ng 5)
  (simp 5)
  (simp (pf "k1 = lft(PosQR p q)"))
  (use "IHp")
  (simp "Trans")
  (use "Truth")
  (use "Truth")
(save "PosQRZeroLeK1")

(set-goal "all p,q(0 <= lft(PosQR p q) andi 0 <= rht(PosQR p q))")
  (ind)
  (cases)
  (ng #t)
  (split)
  (use "Truth")
  (use "Truth")
  (assume "q")
  (ng #t)
  (split)
  (use "Truth")
  (use "Truth")
  (assume "q")
  (ng #t)
  (split)
  (use "Truth")
  (use "Truth")
  (assume "p" "IHp")
  (cases)
  (ng #t)
  (split)
  (use "Truth")
  (use "Truth")
  (assume "q")
  (ng #t)
  (cases (pt "PosQR p (SZero q)"))
  (assume "k1" "k2" "C1")
    (assert "0<=k1")
      (simp (pf "k1 = lft(k1 pair k2)"))
      (simp "<-" "C1")
      (use "IHp")
      (use "Truth")
    (assume "Condk1")
    (assert "0<=k2")
      (simp (pf "k2 = rht(k1 pair k2)"))
      (simp "<-" "C1")
      (use "IHp")
      (use "Truth")
    (assume "Condk2")
  (ng #t)
  (cases (pt "2*k2<SZero q"))
  (assume "C2")
  (split)
  (ng #t)
  (use "IntLeTrans" (pt "k1"))
  (use "Condk1")
  (use "IntPosLemma1")
  (use "Condk1")
  (ng #t)
  (use "IntLeTrans" (pt "k2"))
  (use "Condk2")
  (use "IntPosLemma1")
  (use "Condk2")
  (assume "nC2")
  (split)
  (use "IntLeTrans" (pt "2*k1"))
  (use "IntLeTrans" (pt "k1"))
  (use "Condk1")
  (use "IntPosLemma1")
  (use "Condk1")
  (use "Truth")
  (ng #t)
  (simp "IntPlusComm")
  (simp  "<-" "IntLePlusCancelL" (pt "IntPos (SZero q)"))
  (ng #t)
  (use "IntNotLtToLe")
  (use "nC2")
  (assume "q")
  (ng #t)
  (cases (pt "PosQR p (SOne q)"))
  (assume "k1" "k2" "C1")
    (assert "0<=k1")
      (simp (pf "k1 = lft(k1 pair k2)"))
      (simp "<-" "C1")
      (use "IHp")
      (use "Truth")
    (assume "Condk1")
    (assert "0<=k2")
      (simp (pf "k2 = rht(k1 pair k2)"))
      (simp "<-" "C1")
      (use "IHp")
      (use "Truth")
    (assume "Condk2")
  (ng #t)
  (cases (pt "2*k2<SOne q"))
  (assume "C2")
  (split)
  (ng #t)
  (use "IntLeTrans" (pt "k1"))
  (use "Condk1")
  (use "IntPosLemma1")
  (use "Condk1")
  (ng #t)
  (use "IntLeTrans" (pt "k2"))
  (use "Condk2")
  (use "IntPosLemma1")
  (use "Condk2")
  (assume "nC2")
  (ng #t)
  (split)
  (use "IntLeTrans" (pt "2*k1"))
  (use "IntLeTrans" (pt "k1"))
  (use "Condk1")
  (use "IntPosLemma1")
  (use "Condk1")
  (use "Truth")
  (simp "IntPlusComm")
  (simp "<-" "IntLePlusCancelL" (pt "IntPos(SOne q)"))
  (ng #t)
  (use "IntNotLtToLe")
  (use "nC2")
  (assume "p" "IHp")
  (cases)
  (ng #t)
  (split)
  (use "Truth")
  (use "Truth")
  (assume "q")
  (ng #t)
  (cases (pt "PosQR p (SZero q)"))
  (assume "k1" "k2" "C1")
    (assert "0<=k1")
      (simp (pf "k1 = lft(k1 pair k2)"))
      (simp "<-" "C1")
      (use "IHp")
      (use "Truth")
    (assume "Condk1")
    (assert "0<=k2")
      (simp (pf "k2 = rht(k1 pair k2)"))
      (simp "<-" "C1")
      (use "IHp")
      (use "Truth")
    (assume "Condk2")
  (ng #t)
  (cases (pt "2*k2+1<SZero q"))
  (assume "C2")
  (ng #t)
  (split)
  (use "IntLeTrans" (pt "k1"))
  (use "Condk1")
  (use "IntPosLemma1")
  (use "Condk1")
  (use "IntLeTrans" (pt "2*k2"))
  (use "IntLeTrans" (pt "k2"))
  (use "Condk2")
  (use "IntPosLemma1")
  (use "Condk2")
  (use "Truth")
  (assume "nC2")
  (ng #t)
  (split)
  (use "IntLeTrans" (pt "2*k1"))
  (use "IntLeTrans" (pt "k1"))
  (use "Condk1")
  (use "IntPosLemma1")
  (use "Condk1")
  (use "Truth")
  (simp (pf "2*k2+1+IntN(SZero q) = IntN(SZero q)+2*k2+1"))
  (simp "<-" "IntLePlusCancelL" (pt "IntPos(SZero q)"))
  (ng #t)
  (use "IntNotLtToLe")
  (use "nC2")
  (simp "IntPlusComm")
  (ng #t)
  (use "Truth")
  (assume "q")
  (ng #t)
  (cases (pt "PosQR p (SOne q)"))
  (assume "k1" "k2" "C1")
    (assert "0<=k1")
      (simp (pf "k1 = lft(k1 pair k2)"))
      (simp "<-" "C1")
      (use "IHp")
      (use "Truth")
    (assume "Condk1")
    (assert "0<=k2")
      (simp (pf "k2 = rht(k1 pair k2)"))
      (simp "<-" "C1")
      (use "IHp")
      (use "Truth")
    (assume "Condk2")
  (ng #t)
  (cases (pt "2*k2+1<SOne q"))
  (assume "C2")
  (ng #t)
  (split)
  (use "IntLeTrans" (pt "k1"))
  (use "Condk1")
  (use "IntPosLemma1")
  (use "Condk1")
  (use "IntLeTrans" (pt "2*k2"))
  (use "IntLeTrans" (pt "k2"))
  (use "Condk2")
  (use "IntPosLemma1")
  (use "Condk2")
  (use "Truth")
  (assume "nC2")
  (ng #t)
  (split)
  (use "IntLeTrans" (pt "2*k1"))
  (use "IntLeTrans" (pt "k1"))
  (use "Condk1")
  (use "IntPosLemma1")
  (use "Condk1")
  (use "Truth")
  (simp (pf "2*k2+1+IntN(SOne q) = IntN(SOne q)+2*k2+1"))
  (simp "<-" "IntLePlusCancelL" (pt "IntPos(SOne q)"))
  (ng #t)
  (use "IntNotLtToLe")
  (use "nC2")
  (simp "IntPlusComm")
  (ng #t)
  (use "Truth")
(save "PosQRResCond")

(set-goal "all i1,i2 (0 < i2 -> (i1*i2<=i2) = (i1<=1))")
  (cases)
  (assume "r1")
  (cases)
  (assume "r2")
  (ng #t)
  (auto)
  (ng #t)
  (use "Efq")
  (assume "r2")
  (ng #t)
  (use "Efq")
  (cases)
  (assume "r1")
  (ng #t)
  (auto)
  (assume "r1")
  (cases)
  (assume "r2")
  (auto)
(save "IntLeTimesRule2")

(set-goal "all i1,i2 (0 < i1 -> (i1*i2<=i1) = (i2<=1))")
  (cases)
  (assume "r1")
  (cases)
  (assume "r2")
  (ng #t)
  (auto)
  (ng #t)
  (assume "i2")
  (use "Efq")
  (assume "r2")
  (ng #t)
  (assume "i2")
  (use "Efq")
(save "IntLeTimesRule1")



(set-goal "all k,j,i(0<=k -> j<=i -> k*j<=k*i)")
(assume "k" "j" "i" "ineq1" "ineq2")
(simp "IntTimesComm")
(use "IntLeTrans" (pt "i*k"))
(use "IntLeMonTimes")
(use "ineq1")
(use "ineq2")
(simp "IntTimesComm")
(ng #t)
(use "Truth")
(save "IntLeMonTimesL")




(set-goal "all k,j(abs(k + ~j)=abs(j + ~k))")
(assert "all p,p0 abs(p+ ~p0)=abs(p0+ ~p)")
(ng #t)
(assume "p" "p0")
(cases (pt "p=p0"))
(ng #t)
(assume "p=p0")
(simp "p=p0")
(ng #t)
(auto)
(assume "Falsity")
(ng #t)
(cases (pt "p<p0"))
(assume "p<p0")
(ng #t)
(assert "(p0=p)->F")
(assume "p0=p")
(use "Falsity")
(simp "PosEqSym")
(auto)
(assume "Assertion")
(simp "Assertion")
(ng #t)
(assert "p0<p -> F")
(use "PosLtToNotLtS")
(auto)
(assume "(p0<p -> F)")
(ng #t)
(simp "(p0<p -> F)")
(ng #t)
(auto)
(assume "p<p0->F")
(ng #t)
(assert "(p0=p)->F")
(assume "p0=p")
(use "Falsity")
(simp "PosEqSym")
(auto)
(assume "(p0<p -> F)")
(simp "(p0<p -> F)")
(ng #t)
(assert "p0<p")
(use "PosNotLeToLt")
(use "PQNotLeCases")
(auto)
(assume "Assertion")
(simp "Assertion")
(ng #t)
(auto)
(assume "Assertion")
(cases)
(assume "p")
(cases)
(assume "p0")
(auto)
(ng #t)
(assume "p0")
(use "PosPlusComm")
(assume "j")
(ng #t)
(auto)
(assume "p")
(cases)
(assume "p0")
(ng #t)
(use "PosPlusComm")
(auto)
(assume "p0")
(ng #t)
(ng "Assertion")
(cases (pt "p=p0"))
(ng #t)
(assume "p=p0")
(simp "p=p0")
(ng #t)
(auto)
(assume "Falsity")
(ng #t)
(cases (pt "p<p0"))
(assume "p<p0")
(ng #t)
(assert "(p0=p)->F")
(assume "p0=p")
(use "Falsity")
(simp "PosEqSym")
(auto)
(assume "Assertion1")
(simp "Assertion1")
(ng #t)
(assert "p0<p -> F")
(use "PosLtToNotLtS")
(auto)
(assume "(p0<p -> F)")
(ng #t)
(simp "(p0<p -> F)")
(ng #t)
(auto)
(assume "p<p0->F")
(ng #t)
(assert "(p0=p)->F")
(assume "p0=p")
(use "Falsity")
(simp "PosEqSym")
(auto)
(assume "(p0<p -> F)")
(simp "(p0<p -> F)")
(ng #t)
(assert "p0<p")
(use "PosNotLeToLt")
(use "PQNotLeCases")
(auto)
(assume "p0<p")
(simp "p0<p")
(ng #t)
(auto)
(save "IntAbsPlusMinusComm")


(set-goal "all n n=NatToInt(n)")
(ind)
(auto)
(save "NatToIntAux")