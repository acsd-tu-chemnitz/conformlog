(display "loading rea.scm extension")(newline)

;; Appendix
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;_____APPENDIX_____;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(add-computation-rules "(RealConstr as M) max (RealConstr bs N)" "RealConstr ([n] as n max bs n) ([p] (N (PosS p)) max (M (PosS p)))")

(set-totality-goal "RealMax")
	(assume "x^1" "Tx1" "x^2" "Tx2")
	(elim "Tx1")
	(assume "as^1" "Tas1" "M^1" "TM1")
	(elim "Tx2")
	(assume "as^2" "Tas2" "M^2" "TM2")
	(ng #t)
	(use "TotalReaRealConstr")
	(ng #t)
	(assume "n^1" "Tn1")
	(use "RatMaxTotal")
	(use "Tas1")
	(use "Tn1")
	(use "Tas2")
	(use "Tn1")
	(assume "p^1" "Tp1")
	(ng #t)
	(use "NatMaxTotal")
	(use "TM2")
	(use "PosSTotal")
	(use "Tp1")
	(use "TM1")
	(use "PosSTotal")
	(use "Tp1")
(save-totality)


(set-goal "all x,y (Real x -> Real y-> Real(x max y))")
(assume "x" "y" "Rx" "Ry")
(elim "Rx")
(cases)
(assume "as" "M" "Cas" "Mas")
(elim "Ry")
(cases)
(assume "bs" "N" "Cbs" "Mbs")
(use "RealIntro")
(ng #t)
(use "CauchyIntro")
(assume "p" "n" "m")
(ng #t)
(assume "M(PosS p)max N(PosS p)<=n")
(assume "M(PosS p)max N(PosS p)<=m")
(use "RatAbsLeCases2")
(use "RatLePlusCancelR" (pt "as m max bs m"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "~(as m max bs m)+as m max bs m==0"))
(ng #t)
(use "RatLePlusCancelL" (pt "1#2**p"))
(ng #t)
(simprat (pf "(0#2**p*2**p)==0"))
(ng #t)
(simp "RatPlusComm")
(cases (pt "as m<=bs m"))
(assume "case1")
(use "RatLeTrans" (pt "bs n + (1#2**p)"))
(use "RatLeTrans" (pt "bs m + (1#2**(PosS p))"))
(use "RatLeTrans" (pt "bs m"))
(use "RatMaxLUB")
(auto)
(use "RatLePlusCancelR" (pt "~(1#2**PosS p)"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "(1#2**PosS p)+ ~(1#2**PosS p)==0"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "(1#2**p)+ ~(1#2**PosS p)==(1#2**PosS p)"))
(use "RatLePlusCancelL" (pt "~(bs n)"))
(ng #t)
(simprat (pf " ~(bs n)+bs n==0"))
(ng #t)
(simp "RatPlusComm")
(use "RatLeTrans" (pt "abs(bs m + ~(bs n))"))
(auto)
(use "CauchyElim" (pt "N"))
(use "Cbs")
(use "NatLeTrans" (pt "N(PosS p)max M(PosS p)"))
(use "NatMaxUB1")
(auto)
(use "NatLeTrans" (pt "N(PosS p)max M(PosS p)"))
(use "NatMaxUB1")
(auto)
(simprat "<-" "RatPlusHalfExpPosS")
(simp "<-" "RatPlusAssoc")
(simprat (pf "(1#2**PosS p)+ ~(1#2**PosS p)==0"))
(auto)
(use "RatLeMonPlus")
(use "RatMaxUB2")
(auto)
(assume "case2")
(cut "bs m<as m")
(assume "case2c")
(use "RatLeTrans" (pt "as n + (1#2**p)"))
(use "RatLeTrans" (pt "as m + (1#2**(PosS p))"))
(use "RatLeTrans" (pt "as m"))
(use "RatMaxLUB")
(auto)
(use "RatLtToLe")
(auto)
(use "RatLePlusCancelR" (pt "~(1#2**PosS p)"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "(1#2**PosS p)+ ~(1#2**PosS p)==0"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "(1#2**p)+ ~(1#2**PosS p)==(1#2**PosS p)"))
(use "RatLePlusCancelL" (pt "~(as n)"))
(ng #t)
(simprat (pf "~(as n)+as n==0"))
(ng #t)
(simp "RatPlusComm")
(use "RatLeTrans" (pt "abs(as m+ ~(as n))"))
(auto)
(use "CauchyElim" (pt "M"))
(auto)
(use "NatLeTrans" (pt "N(PosS p)max M(PosS p)"))
(use "NatMaxUB2")
(auto)
(use "NatLeTrans" (pt "N(PosS p)max M(PosS p)"))
(use "NatMaxUB2")
(auto)
(simprat "<-" "RatPlusHalfExpPosS")
(simp "<-" "RatPlusAssoc")
(simprat (pf "(1#2**PosS p)+ ~(1#2**PosS p)==0"))
(auto)
(use "RatLeMonPlus")
(use "RatMaxUB1")
(auto)
(use "RatNotLeToLt")
(auto)
(use "RatLePlusCancelR" (pt "as m max bs m"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "~(as m max bs m)+as m max bs m==0"))
(ng #t)
(cases (pt "as n<=bs n"))
(assume "case1")
(simp "RatPlusComm")
(use "RatLeTrans" (pt "bs n"))
(use "RatMaxLUB")
(auto)
(use "RatLeTrans" (pt "bs n + (1#2**(PosS p))"))
(auto)
(use "RatLeTrans" (pt "bs m + (1#2**p)"))
(use "RatLePlusCancelR" (pt "~(1#2**PosS p)"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "(1#2**PosS p)+ ~(1#2**PosS p)==0"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "(1#2**p)+ ~(1#2**PosS p)==(1#2**PosS p)"))
(use "RatLePlusCancelL" (pt "~(bs m)"))
(ng #t)
(simprat (pf "~(bs m)+bs m==0"))
(simp "RatPlusComm")
(use "RatLeTrans" (pt "abs(bs n + ~(bs m))"))
(auto)
(ng #t)
(use "CauchyElim" (pt "N"))
(auto)
(use "NatLeTrans" (pt "N(PosS p)max M(PosS p)"))
(use "NatMaxUB1")
(auto)
(use "NatLeTrans" (pt "N(PosS p)max M(PosS p)"))
(use "NatMaxUB1")
(auto)
(simprat "<-" "RatPlusHalfExpPosS")
(simp "<-" "RatPlusAssoc")
(simprat (pf "(1#2**PosS p)+ ~(1#2**PosS p)==0"))
(auto)
(use "RatLeMonPlus")
(use "RatMaxUB2")
(auto)
(assume "case2")
(cut "bs n< as n")
(assume "case2c")
(simp "RatPlusComm")
(use "RatLeTrans" (pt "as n"))
(use "RatMaxLUB")
(auto)
(use "RatLtToLe")
(auto)
(use "RatLeTrans" (pt "as m + (1#2**(PosS p))"))
(use "RatLePlusCancelL" (pt "~(as m)"))
(simp "RatPlusAssoc")
(simprat (pf "~(as m)+as m==0"))
(simp "RatPlusComm")
(use "RatLeTrans" (pt "abs(as n+ ~(as m))"))
(auto)
(ng #t)
(use "CauchyElim" (pt "M"))
(auto)
(use "NatLeTrans" (pt "N(PosS p)max M(PosS p)"))
(use "NatMaxUB2")
(auto)
(use "NatLeTrans" (pt "N(PosS p)max M(PosS p)"))
(use "NatMaxUB2")
(auto)
(use "RatLeMonPlus")
(use "RatMaxUB1")
(ng #t)
(use "PosLeMonPosExp")
(simp "PosToNatLe")
(auto)
(use "RatNotLeToLt")
(auto)
(use "MonIntro")
(assume "p" "q")
(ng #t)
(assume "p<=q")
(ng #t)
(use "NatMaxLUB")
(use "NatLeTrans" (pt "N(PosS q)"))
(use "MonElim")
(auto)
(use "NatMaxUB1")
(use "NatLeTrans" (pt "M(PosS q)"))
(use "MonElim")
(auto)
(use "NatMaxUB2")
(save "RealMaxReal")

;; Cauchy preservation with different Modulus
(set-goal "all as,N,M( Cauchy as M-> all p (M p <=N p) -> Cauchy as N )")
(assume "as" "N" "M")
(elim)
(assume "as0" "M0")
(assume "Hyp")
(assume "<=")
(use "CauchyIntro")
(assume "p" "n" "m")
(assume "N p<=n")
(assume "N p<=m")
(inst-with-to "Hyp" (pt "p") (pt "n") (pt "m")  "Hyp2")
(use "Hyp2")
(inst-with-to "<=" (pt "p") "Hyp<=")
(use "NatLeTrans" (pt "N p"))
(use "Hyp<=")
(use "N p<=n")
(use "NatLeTrans" (pt "N p"))
(inst-with-to "<=" (pt "p") "Hyp<=")
(use "Hyp<=")
(use "N p<=m")
(save "CauchyDiffModAuxCauchy")

(set-goal "all x,y(Real x -> Real y->x===y->x<<=y)")
(assume "x" "y" "Rx" "Ry")
(assume "Eq")
(simpreal "<-" "Eq")
(use "RealLeRefl")
(realproof)
(save "RealLeRefl2")

(set-goal "allnc x,y(x===y->x<<=y)")
(assume "x" "y" )
(assume "Eq")
(simpreal "<-" "Eq")
(use "RealLeRefl")
(realproof)
(save "RealLeReflNC")

; (set-goal "all x,y,z(Real x -> Real y -> Real z-> abs(x+ ~y)<<=abs(x+ ~z) + abs(z+ ~y)) ")
; (cases)
; (assume "as" "M")
; (cases)
; (assume "bs" "N")
; (cases)
; (assume "cs" "L")
; (assume "Rx" "Ry" "Rz")
; (simpreal (pf "abs(RealConstr as M+ ~(RealConstr bs N))===abs((RealConstr as M+ ~(RealConstr cs L)) +((RealConstr cs L)+ ~(RealConstr bs N)))"))
; (use "RealLeTrans" (pt "abs(RealConstr as M+ ~(RealConstr cs L))+
;     abs(RealConstr cs L+ ~(RealConstr bs N))"))
; (use "RealLeAbsPlus")
; (realproof)
; (realproof)
; (use "RealLeRefl2")
; (realproof)
; (realproof)
; (use "RealSeqEqToEq" (pt "n"))
; (realproof)
; (realproof)
; (assume "n0")
; (assume "Ineq")
; (ng #t)
; (auto)
; (use "RealSeqEqToEq" (pt "n"))
; (realproof)
; (realproof)
; (assume "n0" "Ineq")
; (ng #t)
; (simprat (pf " as n0+ ~(bs n0)==as n0+ ~(cs n0)+cs n0+ ~(bs n0)"))
; (auto)
; (simprat (pf "as n0+ ~(cs n0)+cs n0+ ~(bs n0)==as n0+ (~(cs n0)+cs n0)+ ~(bs n0)"))
; (simprat (pf "(~(cs n0)+cs n0)==0"))
; ;; OPEN!!!!

(set-goal "all x (Real x -> ~x <<= abs(x))")
(cases)
(assume "as" "M")
(assume "Rx")
(use "RealLeIntro")
(realproof)
(realproof)
(use "RealNNegIntro")
(realproof)
(ng #t)
(assume "p")
(use "RatLeTrans" (pt "abs(as(M(PosS p)))+as(M(PosS p))"))
(use "RatLePlusCancelR" (pt "~(as(M(PosS p)))"))
(simp "RatLeNegElimR")
(use "Truth")
(ng #t)
(auto)
(save "RealAbsInvLeEqAbs")

(set-goal "all x,y,p(Real x -> Real y -> RealLt 0 (y + ~x)p -> RealLt x y (PosS p) )")
(cases)
(assume "as" "M")
(cases)
(assume "bs" "N")
(assume "p")
(assume "Rx" "Ry")
(ng #t)
(assume "Frst")
(use "RatLeTrans" (pt "(1#2**p)"))
(ng #t)
(use "PosLtToLe")
(use "PosExpLtPosSExp")
(use "Frst")
(save "ReaLtPosSAux")

(set-goal "all x,y,p(Real x -> Real y  -> RealLt x y p -> RealLt 0 (y + ~x)( PosS(PosS p)))")
(cases)
(assume "as" "M")
(cases)
(assume "bs" "N")
(assume "p")
(assume "Rx" "Ry")
(assume "Frst")
(use "RealLtIntro")
(assert "RealPos(RealConstr bs N+ ~(RealConstr as M))p")
(use "RealLtElim")
(use "Frst")
(assume "RealPosAssertion")
(simp "RealUMinus0CompRule")
(simp "RealUMinus0CompRule")
(simp "RealPlus0CompRule")
(simp "RealPlus0CompRule")
(use "RealPosCompatRealConstrFree" (pt "RealConstr bs N+ ~(RealConstr as M)"))
(use "RealSeqEqToEq" (pt "Zero"))
(realproof)
(simp "<-" "RealPlus0CompRule")
(simp "<-" "RealPlus0CompRule")
(simp "<-" "RealUMinus0CompRule")
(simp "<-" "RealUMinus0CompRule")
(realproof)
(assume "n" "Zero<=n")
(ng #t)
(use "Truth")
(use "RealPosAssertion")
(save "ReaLtPosSAux1")


(animate "RealNNegCharOne")
;;(pp (pt "(RealConstr([n]cs n+([n0]~(as0 n0))n)([p]L(PosS p)max M0(PosS p))) seq")))
(animate "RealNNegCharOne")

(set-goal "all x,y,p( Real x -> Real y -> ( RealLt x y p) -> x<<=y)")
(assume "x" "y" "p")
(assume "Rx" "Ry")
(assume "x<y")
(use "RealLeIntro")
(auto)
(use "RealNNegChar2RealConstrFree")
(autoreal)
(assume "p0")
(assert "RealPos (y + ~x) p")
(use "RealLtElim")
(auto)
(assume "RpAssertion")
(inst-with-to "RealPosChar1RealConstrFree" (pt "(y + ~x)") (pt "p") "RPChar")
(intro 0 (pt "(y+ ~x)mod(PosS p)"))
(assume "n" "condn")
(use "RatLeTrans" (pt "(1#2**PosS p)"))
(auto)
(use "RPChar")
(autoreal)
(auto)
(save "RealLtToLe")
;;(remove-theorem "RealLtToLe")
(remove-theorem "RealLeLtTrans")

(set-goal "all x,y,z,p(Real x -> Real y -> Real z -> x<<=y -> RealLt(y) (z) p -> RealLt(x) (z) (PosS(PosS(PosS p))))")
(cases)
(assume "as" "M")
(cases)
(assume "bs" "N")
(cases)
(assume "cs" "L")
(assume "p")
(assume "Rx" "Ry" "Rz")
(elim)
(cases)
(assume "as0" "M0")
(cases)
(assume "bs0" "N0")
(assume "Rxx" "Ryy")
(assume "x<=y")
(assume "y<z")
(use "RealLtIntro")
(simp "RealUMinus0CompRule")
(simp "RealPlus0CompRule")
(use "RealPosChar2" (pt "L(PosS(PosS p))max N0(PosS(PosS(PosS(PosS p))))max M0(PosS(PosS(PosS(PosS p))))"))
(simp "<-" "RealPlus0CompRule")
(simp "<-" "RealUMinus0CompRule")
(realproof)
(assume "n" "n1<=n")
(ng)
(assert "(1#2**PosS p)<=([n]cs n+([n0]~(bs0 n0))n)n")
(use "RealPosChar1" (pt "[p](L(PosS p))max N0((PosS p))"))
(simp "<-" "RealPlus0CompRule")
(simp "<-" "RealUMinus0CompRule")
(realproof)
(ng #t)
(use "y<z")
(ng #t)
(use "NatLeTrans" (pt "L(PosS(PosS p))max N0(PosS(PosS(PosS(PosS p))))max
	M0(PosS(PosS(PosS(PosS p))))"))
(simp "NatMaxAssoc")
(use "NatMaxLUB" (pt "L(PosS(PosS p))max N0(PosS(PosS(PosS(PosS p))))"))
(use "NatMaxUB1")
(use "NatLeTrans" (pt "N0(PosS(PosS(PosS(PosS p))))"))
(use "MonElim")
(use "RealConstrToMon" (pt "bs0"))
(realproof)
(ng #t)
(use "PosLeTrans" (pt "PosS p"))
(use "Truth")
(use "Truth")
(simp "NatMaxComm")
(simp "NatMaxAssoc")
(use "NatMaxUB1")
(use "n1<=n")
(assume "y<z__")
(assert " ~(1#2**(PosS (PosS p)))<=([n0]bs0 n0 + ~(as0 n0))n")
(use "RealNNegCharOneExFree" (pt "[p]N0((PosS p))max M0((PosS p))"))
(ng #t)
(use "x<=y")
(ng #t)
(use "NatLeTrans" (pt "L(PosS(PosS p))max N0(PosS(PosS(PosS(PosS p))))max
	M0(PosS(PosS(PosS(PosS p))))"))
(simp "NatMaxAssoc")
(use "NatMaxUB2")
(use "n1<=n")
(assume "x<=y__")
(use "RatLeTrans" (pt "cs n+ ~(bs0 n)+ ~(1#2**(PosS (PosS p)))"))
(use "RatLePlusCancelR" (pt "(1#2**PosS(PosS p))"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "(~(1#2**PosS(PosS
	p))+(1#2**PosS(PosS p)))==0"))
(simprat (pf "(1#2**PosS(PosS p))+(1#2**PosS(PosS p))==(1#2**(PosS p))"))
(ng #t)
(ng "y<z__")
(use "y<z__")
(use "RatPlusHalfExpPosS")
(use "Truth")
(use "RatLePlusCancelL" (pt "~ (cs n)"))
(simp "RatPlusAssoc")
(simp "RatPlusAssoc")
(simp "RatPlusAssoc")
(simprat (pf "~(cs n)+cs n==0"))
(simprat (pf "0+ ~(bs0 n)== ~(bs0 n)"))
(simprat (pf "0+ ~(as0 n)== ~(as0 n)"))
(use "RatLePlusCancelL" (pt "(bs0 n)"))
(simp "RatPlusAssoc")
(simprat (pf "bs0 n+ ~(bs0 n)==0"))
(simprat (pf "0+ ~(1#2**PosS(PosS p))== ~(1#2**PosS(PosS p))"))
(ng #t)
(ng "x<=y__")
(use "x<=y__")
(use "Truth")
(auto)
(save "RealLeLtTrans")


(set-goal "all x,y (x=+=y -> y=+=x)")
(assume "x" "y")
(assume "x=+=y")
(use "RealEqSIntro")
(assume "n")
(use "RatEqvSym")
(use "RealEqSElim")
(use "x=+=y")
(save "RealEqSSym")

(set-goal "all x,y(Real x -> x=+=y -> all p x mod p = y mod p ->Real y)")
(cases)
(assume "as" "M")
(cases)
(assume "as0" "M0")
(assume "Ras")
(assume "xeqsy")
(assume "modeq")
(use "RealIntro")
(use "CauchyIntro")
(assume "p" "n" "m")
(assume "Rn" "Rm")
(ng #t)
(simprat "RealConstrEqSElim" (pt "M0") (pt "as") (pt "M"))
(simprat (pf "as0 m==as m"))
(use "CauchyElim" (pt "[p] M p"))
(ng #t)
(use "RealConstrToCauchy")
(use "Ras")
(ng)
(simp "modeq")
(auto)
(ng)
(simp "modeq")
(auto)
(use "RealConstrEqSElim" (pt "M0") (pt "M"))
(use "RealEqSSym")
(use "xeqsy")
(use "RealEqSSym")
(use "xeqsy")
(ng #t)
(use "MonIntro")
(assume "p" "q" "pleq")
(ng "modeq")
(simp "<-" "modeq")
(simp "<-" "modeq")
(use "MonElim")
(use "RealConstrToMon" (pt "as"))
(use "Ras")
(use "pleq")
(save "RealEqSModEqReal")



(set-goal "all x,y,z(Real x -> Real y -> Real z -> all p RealLt(x) (y) p -> all p RealLt(y) (z) p -> all p RealLt(x) (z) (PosS(PosS p)))")
(cases)
(assume "as" "M")
(cases)
(assume "bs" "N")
(cases)
(assume "cs" "L")
(assume "Rx" "Ry" "Rz")
(assume "x<y")
(assume "y<z")
(assume "p")
(use "RealLtIntro")
(simp "RealUMinus0CompRule")
(simp "RealPlus0CompRule")
(use "RealPosChar2" (pt "L(PosS(PosS p))max N(PosS(PosS p))max M(PosS(PosS p))"))
(simp "<-" "RealPlus0CompRule")
(simp "<-" "RealUMinus0CompRule")
(realproof)
(assume "n" "n1<=n")
(ng)
(assert "(1#2**PosS p)<=([n0]bs n0 + ~(as n0))n")
(use "RealPosChar1" (pt "[p]N((PosS p))max M((PosS p))"))
(use "RealEqSModEqReal" (pt "RealConstr bs N + ~(RealConstr as M)"))
(realproof)
(use "RealEqSIntro")
(ng #t)
(assume "n0")
(use "Truth")
(assume "p0")
(ng #t)
(use "Truth")
(use "x<y")
(ng #t)
(use "NatLeTrans" (pt "L(PosS(PosS p))max N(PosS(PosS p))max M(PosS(PosS p))"))
(simp "NatMaxAssoc")
(use "NatMaxUB2")
(use "n1<=n")
(assume "x<y__")
(assert "(1#2**PosS p)<=([n0]cs n0 + ~(bs n0))n")
(use "RealPosChar1" (pt "[p]L((PosS p))max N((PosS p))"))
(use "RealEqSModEqReal" (pt "RealConstr cs L + ~(RealConstr bs N)"))
(realproof)
(use "RealEqSIntro")
(assume "n0")
(ng #t)
(use "Truth")
(assume "p0")
(ng #t)
(use "Truth")
(use "y<z")
(use "NatLeTrans" (pt "L(PosS(PosS p))max N(PosS(PosS p))max M(PosS(PosS p))"))
(ng #t)
(use "NatMaxUB1")
(auto)
(assume "y<z__")
(use "RatLeTrans" (pt "cs n+ ~(bs n)"))
(use "y<z__")
(use "RatLePlusCancelL" (pt "~ (cs n)"))
(ng #t)
(use "RatLePlusCancelR" (pt "~(as n)"))
(simprat (pf "as n+ ~(as n)==0"))
(use "RatLeTrans" (pt "(1#2**PosS p)"))
(use "Truth")
(ng "x<y__")
(use "x<y__")
(use "Truth")
(save "RealLtTrans")

(remove-theorem "RealLtLeTrans")

(set-goal "all x,y,z,p(Real x -> Real y -> Real z -> y<<=z -> RealLt(x) (y) p ->  RealLt(x) (z) (PosS(PosS(PosS p))))")
(cases)
(assume "as" "M")
(cases)
(assume "bs" "N")
(cases)
(assume "cs" "L")
(assume "p")
(assume "Rx" "Ry" "Rz")
(elim)
(cases)
(assume "bs0" "N0")
(cases)
(assume "cs0" "L0")
(assume "Ryy" "Rzz")
(assume "y<=z")
(assume "x<y")
;;(assume "p")
(use "RealLtIntro")
(simp "RealUMinus0CompRule")
(simp "RealPlus0CompRule")
(use "RealPosChar2" (pt "L0(PosS(PosS(PosS(PosS p))))max N0(PosS(PosS(PosS(PosS p))))max M(PosS(PosS p))"))
(simp "<-" "RealPlus0CompRule")
(simp "<-" "RealUMinus0CompRule")
(realproof)
(assume "n" "n1<=n")
(assert " ~(1#2**(PosS (PosS p)))<=([n0]cs0 n0 + ~(bs0 n0))n")
(use "RealNNegCharOneExFree" (pt "[p]L0((PosS p))max N0((PosS p))"))
(ng #t)
(ng "y<=z")
(use "y<=z")
(ng #t)
(use "NatLeTrans" (pt "L0(PosS(PosS(PosS(PosS p))))max
	N0(PosS(PosS(PosS(PosS p))))max
	M(PosS(PosS p))"))
(simp "NatMaxAssoc")
(use "NatMaxUB1")
(use "n1<=n")
(ng #t)
(assume "y<=z__")
(assert "(1#2**PosS p)<=([n]bs0 n+([n0]~(as n0))n)n")
(use "RealPosChar1" (pt "[p](N0((PosS p)) max M(PosS p))"))
(simp "<-" "RealPlus0CompRule")
(simp "<-" "RealUMinus0CompRule")
(realproof)
(ng #t)
(ng "x<y")
(use "x<y")
(ng #t)
(use "NatLeTrans" (pt "L0(PosS(PosS(PosS(PosS p))))max N0(PosS(PosS(PosS(PosS p))))max
	M(PosS(PosS p))"))
(simp "NatMaxAssoc")
(use "NatLeTrans" (pt "(N0(PosS(PosS(PosS(PosS p))))max M(PosS(PosS p)))"))
(use "NatMaxLUB" (pt "(N0(PosS(PosS(PosS(PosS p))))max M(PosS(PosS p)))"))
(use "NatLeTrans" (pt "N0(PosS(PosS(PosS(PosS p))))"))
(use "MonElim")
(use "RealConstrToMon" (pt "bs0"))
(realproof)
(ng #t)
(use "PosLeTrans" (pt "PosS p"))
(auto)
(use "NatMaxUB1")
(use "NatMaxUB2")
(use "NatMaxUB2")
(use "n1<=n")
(assume "x<y__")
(ng "x<y__")
(use "RatLeTrans" (pt "bs0 n+ ~(as n)+ ~(1#2**(PosS (PosS p)))"))
(use "RatLePlusCancelR" (pt "(1#2**PosS(PosS p))"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "(~(1#2**PosS(PosS
	p))+(1#2**PosS(PosS p)))==0"))
(simprat (pf "(1#2**PosS(PosS p))+(1#2**PosS(PosS p))==(1#2**(PosS p))"))
(ng #t)
(use "x<y__")
(use "RatPlusHalfExpPosS")
(use "Truth")
(use "RatLePlusCancelL" (pt "~(bs0 n)"))
(simp "RatPlusAssoc")
(simp "RatPlusAssoc")
(simprat (pf "~(bs0 n)+bs0 n==0"))
(ng #t)
(use "RatLePlusCancelL" (pt "(as n)"))
(simp "RatPlusAssoc")
(simprat (pf "as n+ ~(as n)==0"))
(ng #t)
(simp "<-" "RatPlusComm")
(simp "RatPlusAssoc")
(simp "RatPlusAssoc")
(simprat (pf "~(as n)+as n==0"))
(ng #t)
(simp "RatPlusComm")
(use "y<=z__")
(auto)
(save "RealLtLeTrans")

;; (PosS(PosS(PosS(PosS(PosS p)))))
(set-goal "all x,y (exl p RealLt x y p -> x<<=y)")
(assume "x" "y")
;; Open

(set-goal "all x,y,z,p(Real x -> Real y -> Real z -> x<<=y -> exl q RealLt(y) (z) q -> exl p RealLt(x) (z)  p)")
(cases)
(assume "as" "M")
(cases)
(assume "bs" "N")
(cases)
(assume "cs" "L")
(assume "p")
(assume "Rx" "Ry" "Rz")
(assume "x<<=y")
(assume "ExQ")
(by-assume "ExQ" "q" "ExQProp")
(intro 0 (pt "PosS(PosS(PosS(q)))")) 
(use "RealLtIntro")
(simp "RealUMinus0CompRule")
(simp "RealPlus0CompRule")
(use "RealPosChar2" (pt "L(PosS(PosS(PosS(PosS q))))max N(PosS(PosS(PosS(PosS q))))max M(PosS(PosS q))"))
(simp "<-" "RealPlus0CompRule")
(simp "<-" "RealUMinus0CompRule")
(realproof)
;Open

(set-goal "all x,y,z,p(Real x -> Real y -> Real z -> x===y -> RealLt(y) (z) p ->  RealLt(x) (z) (PosS(PosS p)))")
(cases)
(assume "as" "M")
(cases)
(assume "bs" "N")
(cases)
(assume "cs" "L")
(assume "p")
(assume "Rx" "Ry" "Rz")
(assume "x==y")
(assume "x<y")
(use "RealLtIntro")
(simp "RealUMinus0CompRule")
(simp "RealPlus0CompRule")
(use "RealPosCompat" (pt "([n]cs n+([n0]~(bs n0))n)") (pt "[p0]L(PosS p0)max N(PosS p0)"))
(simp "<-" "RealPlus0CompRule")
(simp "<-" "RealPlus0CompRule")
(use "RealPlusCompat")
(use "RealSeqEqToEq" (pt "Zero"))
(autoreal)
(auto)
(simp "<-" "RealUMinus0CompRule")
(simp "<-" "RealUMinus0CompRule")
(use "RealUMinusCompat")
(use "RealEqSym")
(use "x==y")
(ng "x<y")
(ng #t)
(auto)
(save "RealEqLtTrans")

(set-goal "all x,y,z,p(Real x -> Real y -> Real z -> RealLt(x) (y) p -> y===z ->  RealLt(x) (z) (PosS(PosS p)))")
(cases)
(assume "as" "M")
(cases)
(assume "bs" "N")
(cases)
(assume "cs" "L")
(assume "p")
(assume "Rx" "Ry" "Rz")
(assume "x<y")
(assume "y==z")
(use "RealLtIntro")
(simp "RealUMinus0CompRule")
(simp "RealPlus0CompRule")
(use "RealPosCompat" (pt "[n]bs n+([n0]~(as n0))n") (pt "[p0]N(PosS p0)max M(PosS p0)"))
(simp "<-" "RealPlus0CompRule")
(simp "<-" "RealPlus0CompRule")
(use "RealPlusCompat")
(use "y==z")
(use "RealSeqEqToEq" (pt "Zero"))
(simp "<-" "RealUMinus0CompRule")
(use "RealUMinusReal")
(use "Rx")
	(assert "all as,M((RealConstr([n]~(as n))M) eqd (~(RealConstr([n](as n))M)))")
		(assume "as1" "M1")
		(ng #t)
		(use "InitEqD")
	(assume "A1")
(simp "A1")
(use "RealUMinusReal")
(use "Rx")
(auto)
(save "RealLtEqTrans")

(set-goal "all as,l exl n all m(m<l -> abs(as m)<=2**n)")
(assume "as")
(ind)
;; 3,4
(intro 0 (pt "Zero"))
(assume "m" "Absurd")
(use "EfqAtom")
(use "Absurd")
;; 4
(assume "l" "IH")
(by-assume "IH" "n" "nProp")
(inst-with-to "RatLeAbsBound" (pt "as l") "ExHyp")
(by-assume "ExHyp" "n1" "n1Prop")
(intro 0 (pt "n max n1"))
(assume "m" "m<l+1")
(use "NatLtSuccCases" (pt "m") (pt "l"))
(use "m<l+1")
(assume "m<l")
(use "RatLeTrans" (pt "(2**n#One)"))
(use "nProp")
(use "m<l")
(ng)
(use "PosLeMonPosExp")
(use "NatMaxUB1")
(assume "m=l")
(simp "m=l")
(use "RatLeTrans" (pt "(2**n1#One)"))
(use "n1Prop")
(ng)
(use "PosLeMonPosExp")
(use "NatMaxUB2")
;; Proof finished.
(save "RatLeAbsBoundSeq")

(animate "RatLeAbsBoundSeq")

(set-goal "all as,l,m(m<l -> abs(as m)<=2**cRatLeAbsBoundSeq as l)")
(assume "as")
(ind)
;; 3,4
(assume "m" "Absurd")
(use "EfqAtom")
(use "Absurd")
;; 4
(assume "l" "IH" "m" "m<l+1")
(use "NatLtSuccCases" (pt "m") (pt "l"))
(use "m<l+1")
(assume "m<l")
(use "RatLeTrans" (pt "(2**cRatLeAbsBoundSeq as l#1)"))
(use "IH")
(use "m<l")
(ng)
(use "PosLeMonPosExp")
(use "NatMaxUB1")
(assume "m=l")
(simp "m=l")
(assert "cRatLeAbsBoundSeq as(Succ l)=
         cRatLeAbsBoundSeq as l max cRatLeAbsBound(as l)")
 (use "Truth")
(assume "EqHyp")
(simp "EqHyp")
(drop "EqHyp")
(use "RatLeTrans" (pt "(2**cRatLeAbsBound(as l)#One)"))
(use "RatLeAbsBoundExFree")
(use "PosLeMonPosExp")
(use "NatMaxUB2")
;; Proof finished.
(save "RatLeAbsBoundSeqExFree")

(deanimate "RatLeAbsBoundSeq")

(set-goal "all as,M(Cauchy as M -> exl m all n abs(as n)<=2**m)")
(assume "as" "M" "CasM")
(cut "exl m all n(n<=M 1 -> abs(as n)<=2**m)")
(assume "ExHyp")
(by-assume "ExHyp" "m" "FinBound")
(intro 0 (pt "m+1"))
;; ?_9:all n abs(as n)<=2**(m+1)
(assume "n")
(cases (pt "n<=M 1"))
;; 11,12
(assume "n<=M 1")
(use "RatLeTrans" (pt "(2**m#1)"))
(use "FinBound")
(use "n<=M 1")
(use "Truth")
;; ?_12:(n<M 1 -> F) -> abs(as n)<=2**(m+1)
(assume "n<M 1 -> F")
(use "RatLeTrans" (pt "abs(as(M 1))+(abs(as n)+ ~(abs(as(M 1))))"))
(assert "all b,c b<=c+(b+ ~c)")
 (assume "b" "c")
 (simp "RatPlusComm")
 (simp "<-" "RatPlusAssoc")
 (simprat (pf "~c+c==0"))
 (use "Truth")
 (use "Truth")
(assume "Assertion")
(use "Assertion")
;; ?_21:abs(as(M 1))+(abs(as n)+ ~abs(as(M 1)))<=2**(m+1)
(use "RatLeTrans" (pt "(2**m#1)+(1#2**1)"))
(use "RatLeMonPlus")
(use "FinBound")
(use "Truth")
;; ?_31:abs(as n)+ ~abs(as(M 1))<=(1#2)
(use "RatLeTrans" (pt "abs(abs(as n)+ ~abs(as(M 1)))"))
(use "Truth")
(use "RatLeTrans" (pt "abs(as n+ ~(as(M 1)))"))
(use "RatLeAbsMinusAbs")
;; ?_36:abs(as n+ ~(as(M 1)))<=(1#2)
(use "CauchyElim" (pt "M"))
(use "CasM")
(use "NatNotLtToLe")
(assume "n<M 1")
(use "n<M 1 -> F")
(use "NatLtToLe")
(use "n<M 1")
(use "Truth")
(simp (pf "2**(m+1)=2**m+2**m"))
(use "Truth")
(ng)
(simp "SZeroPosPlus")
(use "Truth")
(intro 0 (pt "cRatLeAbsBoundSeq as(Succ(M 1))"))
(assume "n" "n<=M 1")
(use "RatLeAbsBoundSeqExFree")
(use "NatLeToLtSucc")
(use "n<=M 1")
;; Proof finished.
(save "RealBound")

(set-goal "all x,y,p,q( Real x -> Real y -> RealLt 0 x p -> RealLt 0 y q -> RealLt 0 (x*y) (PosS(PosS(PosS (p+q))) )) ")
(cases)
(assume "as" "M")
(cases)
(assume "bs" "N")
(assume "p" "q")
(assume "Rx" "Ry")
(assume "0<x")
(assume "0<y")
(use "RealLtIntro")
(simp "RealUMinus0CompRule")
(simp "RealTimes0CompRule")
(simp "RealPlus0CompRule")
(use "RealPosChar2" (pt "(M(PosS(PosS(PosS(PosS(PosS(p+cNatPos(cRealBound bs N)))))))max
	N(PosS(PosS(PosS(PosS(PosS(p+cNatPos(cRealBound as M)))))))max N(PosS(PosS q)))"))
(simp "<-" "RealPlus0CompRule")
(simp "<-" "RealUMinus0CompRule")
(simp "<-" "RealTimes0CompRule")
(realproof)
(ng #t)
(assume "n" "n1<=n")
(assert "(1#2**PosS(PosS(p+q)))==(1#2**PosS p)*(1#2**PosS q)")
(ng #t)
(inst-with-to "PosExpTwoPosPlus" (pt "(PosS p)") (pt "(PosS q)") "InstAssertion")
(simp "InstAssertion")
(use "Truth")
(assume "Assertion")
(simprat "Assertion")
(assert "Mon M")
(use "RealConstrToMon" (pt "as"))
(realproof)
(assume "MonAssertion")
(use "RatLeMonTimesTwo")
(auto)
(use "RealPosChar1" (pt "[p]M(PosS p)"))
(use "RealIntro")
(use "CauchyDiffModAuxCauchy" (pt "M"))
(use "RealConstrToCauchy")
(ng #t)
(realproof)
(ng #t)
(assume "p0")
(use "MonElim")
(use "MonAssertion")
(use "Truth")
(use "MonIntro")
(ng #t)
(assume "q0" "q1")
(assume "q0<=q1")
(use "MonElim")
(use "MonAssertion")
(ng #t)
(use "q0<=q1")
(ng #t)
(ng "0<x")
(use "0<x")
(ng #t)
(use "NatLeTrans" (pt "M(PosS(PosS(PosS(PosS(PosS(p+cNatPos(cRealBound bs N)))))))max
	N(PosS(PosS(PosS(PosS(PosS(p+cNatPos(cRealBound as M)))))))max
	N(PosS(PosS q))"))
(use "NatLeTrans" (pt "M(PosS(PosS(PosS(PosS(PosS(p+cNatPos(cRealBound bs
	N)))))))"))
(use "MonElim")
(use "MonAssertion")
(ng #t)
(use "PosLeTrans" (pt "PosS(PosS(PosS(p)))"))
(simp (pf "PosS(PosS(PosS p))=PosSIteratedNat 3 p"))
(use "PosLePosSIteratedNat")
(use "Truth")
(use "Truth")
(simp "NatMaxAssoc")
(use "NatMaxUB1")
(use "n1<=n")
(assert "Mon N")
(use "RealConstrToMon" (pt "bs"))
(realproof)
(assume "MonAssertion2")
(use "RealPosChar1" (pt "[q]N(PosS q)"))
(use "RealIntro")
(use "CauchyDiffModAuxCauchy" (pt "N"))
(use "RealConstrToCauchy")
(ng #t)
(realproof)
(ng #t)
(assume "p2")
(use "MonElim")
(use "MonAssertion2")
(use "Truth")
(ng #t)
(use "MonIntro")
(assume "q0" "q1")
(assume "q0<=q1")
(ng #t)
(use "MonElim")
(use "MonAssertion2")
(ng #t)
(use "q0<=q1")
(ng #t)
(ng "0<y")
(use "0<y")
(ng #t)
(use "NatLeTrans" (pt "M(PosS(PosS(PosS(PosS(PosS(p+cNatPos(cRealBound bs N)))))))max
	N(PosS(PosS(PosS(PosS(PosS(p+cNatPos(cRealBound as M)))))))max
	N(PosS(PosS q))"))
(use "NatMaxUB2")
(use "n1<=n")
(save "RealLtTimesMon")

;;(set-goal "all x,y,z,p,q,r( Real x -> Real y -> RealLt 0 x p -> RealLt 0 y q -> RealLt 0 (x*y) (PosS(PosS(PosS (p+q))) )) ")



(set-goal "all x (Real x -> ~x<<=abs(x))")
(cases)
(assume "as" "M")
(assume "Rx")
(use "RealLeIntro")
(realproof)
(realproof)
(use "RealNNegIntro")
(realproof)
(assume "p")
(ng #t)
(simp "RatPlusComm")
(ng #t)
(use "RatLePlusCancelR" (pt "~(as(M(PosS p)))"))
(ng #t)
(simp "<-" "RatPlusAssoc")
(simprat (pf "as(M(PosS p))+ ~(as(M(PosS p)))==0"))
(ng #t)
(simp "RatPlusComm")
(use "RatLeTrans" (pt "abs(as(M(PosS p)))"))
(use "RatAbsInvLeqAbs")
(use "RatLtToLe")
(use "RatPlusEpsLt")
(use "Truth")
(save "RealAbsInvLeqAbs")

(set-goal "all x,y (Real x -> Real y-> x+ ~y<<=0 -> x<<=y)")
(assume "x")
(assume "y")
(assume "Rx" "Ry")
(assume "x+~y<=0")
(use "RealLePlusCancelR" (pt "~y"))
(realproof)
(realproof)
(realproof)
(simpreal (pf "y+ ~y===0"))
(use "x+~y<=0")
(use "RealPlusMinusZero")
(realproof)
(save "RealShiftLeR")

(set-goal "all x,y (Real x -> Real y -> x<<=y -> x+ ~y<<=0)")
(assume "x" "y")
(assume "Rx" "Ry")
(assume "x<=y")
(use "RealLePlusCancelR" (pt "y"))
(realproof)
(realproof)
(autoreal)
(simpreal "<-" "RealPlusAssoc")
(simpreal (pf "~y+ y===0"))
(ng #t)
(simpreal "RealPlusZero")
(simpreal "RealPlusComm")
(simpreal "RealPlusZero")
(use "x<=y")
(realproof)
(realproof)
(realproof)
(realproof)
(simpreal "RealPlusComm")
(use "RealPlusMinusZero")
(realproof)
(realproof)
(autoreal)
(save "RealShiftLeR1")

(add-program-constant "ReaRat" (py "rat=>rea"))
(add-computation-rules "ReaRat a" "(RealConstr ([n] a) ([p]Zero))")


(set-totality-goal "ReaRat")
(use "AllTotalElim")
(assume "a")
(ng)
(use "ReaTotalVar")
(save "ReaRatTotal")

(set-goal "all x,a (Real x  -> x<<=a -> x+ ~a<<=0)")
(assume "x" "a" "Rx" "x<<=a")
(use "RealLePlusCancelR" (pt "ReaRat a"))
(realproof)
(ng #t)
(realproof)
(autoreal)
(ng #t)
(simpreal "<-" "RealPlusAssoc")
(simpreal (pf "RealPlus~a a===0"))
(simpreal (pf "x+0===x"))
(auto)
(use "RealPlusZero")
(autoreal)
(ng #t)
(use "RatEqvToRealEq")
(ng #t)
(auto)
(realproof)
(autoreal)
(save "RealShiftLeRatR1")

(set-goal "all x,y (Real x -> Real y -> ~x+y=== ~(x+ ~y))")
(assume "x" "y")
(assume "Rx" "Ry")
(inst-with-to "RealUMinusPlus" (pt "x") (pt "~y") "RInst")
(ng "RInst")
(simpreal (pf "~x + y === ~x + ~ ~y"))
(use "RealEqSym")
(use "RInst")
(auto)
(autoreal)
(use "RealPlusCompat")
(use "RealEqRefl")
(autoreal)
(use "RealEqSym")
(use "RealUMinusUMinus")
(autoreal)
(save "RealUMinusPlus1")

(set-goal "allnc x,a,z(x<<=a -> a<<=z -> x<<=z)")
(assume "x" "a" "z")
(inst-with-to "RealLeTrans" (pt "x") (pt "ReaRat a") (pt "z") "RInst")
(auto)
(save "RealRatLeTrans")



(set-goal "all x,y,z,z1(x===y -> z===z1 -> RealLt x z p -> RealLt y z1 (PosS(PosS p)))")
(assume "p")
(assume "x" "y" "z" "z0")
(assume "x=y" "z=z0")
(assume "x<z")
(use "RealLtIntro")
(assert "z0 + ~y === z + ~x")
(use "RealPlusCompat")
(use "RealEqSym")
(auto)
(use "RealEqSym")
(use "RealUMinusCompat")
(auto)
(assume "eq")
(assert "RealPos(z + ~x) p")
(use "RealLtElim")
(auto)
(assume "RealPosInst")
(use "RealPosCompatRealConstrFree" (pt "(z + ~x)"))
(use "RealEqSym")
(auto)
(save "RealLtCompatRealConstrFree")

(deanimate "NatPos")
(deanimate "RatLeAbsBound")
(deanimate "RatLeBound")


(set-goal "all x(Real x -> x*x === abs( x * x))")
  (cases)
  (assume "as" "M")
  (assume "Rx")
  (use "RealEqIntro")
  (realproof)
  (realproof)
  (assume "p")
  (ng)
  (simprat (pf"as(M(PosS(PosS(p+cNatPos(RealBd as M)))))*
      as(M(PosS(PosS(p+cNatPos(RealBd as M)))))+
      ~abs(as(M(PosS(PosS(p+cNatPos(RealBd as M)))))*
          as(M(PosS(PosS(p+cNatPos(RealBd as M)))))) == 0"))
  (use "Truth")
  (simp "RatAbsId")
  (use "Truth")
  (ng)
  (use "Truth")
(save "RealSquarToAbs")

(set-goal "RealNNeg 0")
(use "RealNNegIntro")
(realproof)
(ng)
(assume "p")
(use "Truth")
;; proven
(save "RealZeroNNeg")

(set-goal "all x,y(Real x -> Real y -> all n(x seq n <= y seq n) -> x <<= y)")
(cases)
(assume "as" "M")
(cases)
(assume "bs" "N")
(assume "Rx" "Ry" "InEqSeq")
(use "RealLeIntro")
(use "Rx")
(use "Ry")
(use "RealNNegIntro")
(use "RealPlusReal")
(use "Ry")
(use "RealUMinusReal")
(use "Rx")
(assume "p")
(ng #t)
(use "RatLeTrans" (pt "bs(N(PosS p)max M(PosS p))+ ~(as(N(PosS p)max M(PosS p)))"))
(inst-with "RatLeZeroEqSumNeg" (pt "bs(N(PosS p)max M(PosS p))") (pt "0#1") (pt "~(as(N(PosS p)max M(PosS p)))"))
(ng 4)
(simp 4)
(use "InEqSeq")
(inst-with "RatLePlusCancelLInv" (pt "bs(N(PosS p)max M(PosS p))+ ~(as(N(PosS p)max M(PosS p)))") (pt "0#1")(pt"1#2**p"))
(use "RatLeTrans" (pt "bs(N(PosS p)max M(PosS p))+ ~(as(N(PosS p)max M(PosS p)))+0"))
(use "Truth")
(use 4)
(use "Truth")
(save "RealLeSeqToLe")

;; RealMaxUB1
(set-goal "all x,y( Real x -> Real y -> x <<=x max y)")
(cases)
(assume "as" "M")
(cases)
(assume "bs" "N")
(assume "Rx" "Ry")
(ng #t)
(use "RealLeIntro")
(use "Rx")
(inst-with-to "RealMaxReal" (pt "RealConstr as M") (pt "RealConstr bs N") "Trans")
(use "Trans")
(use "Rx")
(use "Ry")
;(ng #t)
(use "RealNNegIntro")
(use "RealPlusReal")
(inst-with-to "RealMaxReal" (pt "RealConstr as M") (pt "RealConstr bs N") "Trans")
(use "Trans")
(use "Rx")
(use "Ry")
(use "RealUMinusReal")
(use "Rx")
(ng #t)
(assume "p")

(simp (pf "(0<=
     as(N(PosS(PosS p))max M(PosS(PosS p))max M(PosS p))max
     bs(N(PosS(PosS p))max M(PosS(PosS p))max M(PosS p))+
     ~(as(N(PosS(PosS p))max M(PosS(PosS p))max M(PosS p)))+
     (1#2**p)) = ((as(N(PosS(PosS p))max M(PosS(PosS p))max M(PosS p)))<=
     as(N(PosS(PosS p))max M(PosS(PosS p))max M(PosS p))max
     bs(N(PosS(PosS p))max M(PosS(PosS p))max M(PosS p))+
     (1#2**p))"))

;(simp (pf "(0<=
;    as(M(PosS(PosS p))max N(PosS(PosS p))max M(PosS p))max
;    bs(M(PosS(PosS p))max N(PosS(PosS p))max M(PosS p))+
;    ~(as(M(PosS(PosS p))max N(PosS(PosS p))max M(PosS p)))+
;    (1#2**p)) = ((as(M(PosS(PosS p))max N(PosS(PosS p))max M(PosS p)))<=
;        as(M(PosS(PosS p))max N(PosS(PosS p))max M(PosS p))max
;        bs(M(PosS(PosS p))max N(PosS(PosS p))max M(PosS p))+
;        (1#2**p) )"))

(use "RatLeTrans" (pt "as(N(PosS(PosS p))max M(PosS(PosS p))max M(PosS p))max
	bs(N(PosS(PosS p))max M(PosS(PosS p))max M(PosS p))"))
(use "RatMaxUB1")
(ng #t)
(use "Truth")
(use "BooleAeqToEq")
(assume "LeftSide")
(use "RatLeTrans" (pt "as(N(PosS(PosS p))max M(PosS(PosS p))max M(PosS p))max bs(N(PosS(PosS p))max M(PosS(PosS p))max M(PosS p))"))
(use "RatMaxUB1")
(use "RatLeToZeroLePlus")
(simp "RatPlusComm")
(ng #t)
(simprat (pf  "(~(as(N(PosS(PosS p))max M(PosS(PosS p))max M(PosS p))max
    bs(N(PosS(PosS p))max M(PosS(PosS p))max M(PosS p)))+
  as(N(PosS(PosS p))max M(PosS(PosS p))max M(PosS p))max
  bs(N(PosS(PosS p))max M(PosS(PosS p))max M(PosS p))) == 0"))
(use "Truth")
(simp "RatPlusComm")
(use "Truth")
(assume "RightSide")
(simp "RatPlusComm")
(simp "RatLeZeroPlusToRatLe")
(use "Truth")
(use "RatLeTrans" (pt "as(N(PosS(PosS p))max M(PosS(PosS p))max M(PosS p))max bs(N(PosS(PosS p))max M(PosS(PosS p))max M(PosS p))"))
(use "RatMaxUB1")
(use "RatLeToZeroLePlus")
(ng #t)
(simp "<-" "RatPlusAssoc")
(simp "RatPlusComm")
(ng #t)
(simprat (pf "(as(N(PosS(PosS p))max M(PosS(PosS p))max M(PosS p))max
    bs(N(PosS(PosS p))max M(PosS(PosS p))max M(PosS p))+
    ~(as(N(PosS(PosS p))max M(PosS(PosS p))max M(PosS p))max
      bs(N(PosS(PosS p))max M(PosS(PosS p))max M(PosS p)))) == 0"))
(use "Truth")
(use "Truth")
;RealMaxUB1
(save "RealMaxUB1")

;; RealMaxUB2
(set-goal "all x,y( Real x -> Real y -> y <<=x max y)")
(cases)
(assume "as" "M")
(cases)
(assume "bs" "N")
(assume "Rx" "Ry")
(use "RealLeIntro")
(use "Ry")
(inst-with-to "RealMaxReal" (pt "RealConstr as M") (pt "RealConstr bs N") "Trans")
(use "Trans")
(use "Rx")
(use "Ry")
(use "RealNNegIntro")
(use "RealPlusReal")
(inst-with-to "RealMaxReal" (pt "RealConstr as M") (pt "RealConstr bs N") "Trans")
(use "Trans")
(use "Rx")
(use "Ry")
(use "RealUMinusReal")
(use "Ry")
(assume "p")
(ng #t)
(simp "RatPlusComm")
(use "RatLeZeroPlusToRatLe")
(use "RatLeTrans" (pt "as(N(PosS(PosS p))max M(PosS(PosS p))max N(PosS p))max bs(N(PosS(PosS p))max M(PosS(PosS p))max N(PosS p))"))
(use "RatMaxUB2")
(use "RatLeToZeroLePlus")
(simp "<-" "RatPlusAssoc")
(simprat (pf "( as(N(PosS(PosS p))max M(PosS(PosS p))max N(PosS p))max
    bs(N(PosS(PosS p))max M(PosS(PosS p))max N(PosS p))+
    ~(as(N(PosS(PosS p))max M(PosS(PosS p))max N(PosS p))max
      bs(N(PosS(PosS p))max M(PosS(PosS p))max N(PosS p))))==0"))
(use "Truth")
(use "Truth")
;RealMaxUB2
(save "RealMaxUB2")

(set-goal "all as,M(Real(RealConstr as M) -> exl m abs(RealConstr as M)<<=2**m)")
(assume "as" "M")
(assume "Ras")
(inst-with-to "RealBound" (pt "as") (pt "M") "RealBoundInst")
(cut "exl m all n abs(as n)<=2**m")
(assume "CutRealBound")
(by-assume "CutRealBound" "m" "CutRealBoundInst")
(intro 0 (pt "m"))
(use "RealLeIntro")
(use "RealAbsReal")
(autoreal)
(use "RealNNegIntro")
(autoreal)
(assume "p")
(ng #t)
(simp "RatPlusComm")
(use "RatLePlusCancelR" (pt "abs(as(M(PosS p)))"))
(simp "RatPlusAssoc")
(simp "<-" "RatPlusAssoc")
(simprat (pf "~abs(as(M(PosS p)))+abs(as(M(PosS p)))==0"))
(use "RatLeTrans" (pt "2**m#1"))
(ng #t)
(use "CutRealBoundInst")
(ng #t)
(auto)
(use "RealBoundInst")
(use "RealConstrToCauchy")
(auto)
(save "RealLeConstrBoundNat")

(deanimate "RealBound")

(deanimate "RealLeConstrBoundNat")



(set-goal "all as,M(Real(RealConstr as M) -> exl a abs(RealConstr as M)<<=a)")
(assume "as" "M")
(assume "Ras")
(inst-with-to "RealLeConstrBoundNat" (pt "as") (pt "M") "RealBoundInst")
(cut "exl m abs(RealConstr as M)<<=2**m")
(assume "ExHyp")
(by-assume "ExHyp" "m" "ExHypProp")
(intro 0 (pt "2**m#1"))
(use "ExHypProp")
(auto)
(save "RealLeConstrBoundRat")

(deanimate "RealLeConstrBoundRat")

(set-goal "all x (Real x -> exl a abs(x)<<=a)")
(cases)
(use "RealLeConstrBoundRat")
(save "RealLeConstrFreeBoundRat")

(set-goal "all x,p(Real x -> exl a RealLt abs(x) a p)")
(cases)
(assume "as" "M")
(assume "p" "Ras")
(intro  0 (pt "(1#2**p) + abs(as(M(PosS(PosS p))))"))
(ng #t)
(simp "<-" "RatPlusAssoc")
(simprat (pf "abs(as(M(PosS(PosS p))))+ ~abs(as(M(PosS(PosS p))))==0"))
(ng #t)
(auto)
(save "RealLtConstrFreeBoundRat")

(animate "RealLtConstrFreeBoundRat")

(add-program-constant "RealDivision" (py "rea=>rea=>pos=>rea"))
(add-computation-rule "RealDivision x y p" "x*RealUDiv y p")

(set-totality-goal "RealDivision")
(use "AllTotalElim")
(assume "x")
(use "AllTotalElim")
(assume "y")
(use "AllTotalElim")
(assume "p")
(ng #t)
(use "RealTimesTotal")
(use "ReaTotalVar")
(use "RealUDivTotal")
(use "ReaTotalVar")
(use "PosTotalVar")
(save-totality)


(set-goal "all x(Real x -> RealNNegS x -> 0<<=x)")
(assume "x" "Rx" "NNegSx")
(use "RealLeIntro")
(use "RealRat")
(auto)
(use "RealNNegCompat" (pt "x"))
(use "RealEqCompat" (pt "x") (pt "x+0"))
(use "RealEqRefl")
(auto)
(use "RealPlusCompat")
(use "RealEqRefl")
(auto)
(use "RatEqvToRealEq")
(auto)
(use "RealEqSym")
(use "RealPlusZero")
(auto)
(use "RealNNegSToNNeg")
(auto)
;; Proof finished.
(save "RealNNegSToZeroLe")

;; _______________________ Term Transform Lib ______________________
(set-goal "all as,M,N(Real (RealConstr as M) -> Mon N -> (RealConstr as ([p] N p max M p)) <<= (RealConstr as M))")
  (assume "as" "M" "N")
  (assume "Rx" "NN")
    (assert "Real(RealConstr as([p]N p max M p))")
      (use "RealIntro")
      (ng #t)
      (use "CauchyIntro")
      (assume "p" "n" "m")
      (assume "Lim1" "Lim2")
      (ng #t)
      (use "CauchyElim" (pt "M"))
      (inst-with-to "RealToCauchy" (pt "RealConstr as M") "ElimInst1")
      (ng "ElimInst1")
      (use "ElimInst1")
      (use "Rx")
      (use "NatLeTrans" (pt "([p0]N p0 max M p0)p"))
      (ng #t)
      (use "NatMaxUB2")
      (ng #t)
      (use "Lim1")
      (use "NatLeTrans" (pt "([p0]N p0 max M p0)p"))
      (ng #t)
      (use "NatMaxUB2")
      (ng #t)
      (use "Lim2")
      (ng #t)
      (use "MonIntro")
      (assume "p" "q" "pleq")
      (ng #t)
      (use "NatMaxLUB")
      (use "NatLeTrans" (pt "N q"))
      (use "MonElim")
      (use "NN")
      (use "pleq")
      (use "NatMaxUB1")
      (use "NatLeTrans" (pt "M q"))
      (use "MonElim")
      (use "RealConstrToMon" (pt "as"))
      (use "Rx")
      (use "pleq")
      (use "NatMaxUB2")
    (assume "Rxx")
  (use "RealLeIntro")
  (use "Rxx")
  (use "Rx")
  (use "RealNNegIntro")
  (use "RealPlusReal")
  (use "Rx")
  (use "RealUMinusReal")
  (use "Rxx")
  (assume "p")
  (ng #t)
  (simprat (pf "as(M(PosS p)max N(PosS p)max M(PosS p))+ ~(as(M(PosS p)max N(PosS p)max M(PosS p))) == (0#1)"))
  (use "Truth")
(use "Truth")
(save "RealLeModMaxCommLemma1")

(set-goal "all as,M,N(Real (RealConstr as M) -> Mon N -> (RealConstr as ([p] M p max N p)) <<= (RealConstr as M))")
  (assume "as" "M" "N")
  (assume "Rx" "NN")
    (assert "Real(RealConstr as([p]M p max N p))")
      (use "RealIntro")
      (ng #t)
      (use "CauchyIntro")
      (assume "p" "n" "m")
      (assume "Lim1" "Lim2")
      (ng #t)
      (use "CauchyElim" (pt "M"))
      (inst-with-to "RealToCauchy" (pt "RealConstr as M") "ElimInst1")
      (ng "ElimInst1")
      (use "ElimInst1")
      (use "Rx")
      (use "NatLeTrans" (pt "([p0]M p0 max N p0)p"))
      (ng #t)
      (use "NatMaxUB1")
      (ng #t)
      (use "Lim1")
      (use "NatLeTrans" (pt "([p0]M p0 max N p0)p"))
      (ng #t)
      (use "NatMaxUB1")
      (ng #t)
      (use "Lim2")
      (ng #t)
      (use "MonIntro")
      (assume "p" "q" "pleq")
      (ng #t)
      (use "NatMaxLUB")
      (use "NatLeTrans" (pt "M q"))
      (use "MonElim")
			(use "RealConstrToMon" (pt "as"))
			(use "Rx")
			(use "pleq")
			(use "NatMaxUB1")
			(use "NatLeTrans" (pt "N q"))
			(use "MonElim")
			(use "NN")
      (use "pleq")
      (use "NatMaxUB2")
    (assume "Rxx")
  (use "RealLeIntro")
  (use "Rxx")
  (use "Rx")
  (use "RealNNegIntro")
  (use "RealPlusReal")
  (use "Rx")
  (use "RealUMinusReal")
  (use "Rxx")
  (assume "p")
  (ng #t)
  (simprat (pf "as(M(PosS p)max N(PosS p))+ ~(as(M(PosS p)max N(PosS p))) == (0#1)"))
  (use "Truth")
(use "Truth")
(save "RealLeModMaxCommLemma2")

(set-goal "all as,N,M(Real (RealConstr as N) -> Mon M -> (RealConstr as ([p] N p max M p)) <<= (RealConstr as N))")
  (assume "as" "N" "M")
  (assume "Rx" "MM")
    (assert "Real(RealConstr as([p]N p max M p))")
      (use "RealIntro")
      (ng #t)
      (use "CauchyIntro")
      (assume "p" "n" "m")
      (assume "Lim1" "Lim2")
      (ng #t)
      (use "CauchyElim" (pt "N"))
      (inst-with-to "RealToCauchy" (pt "RealConstr as N") "ElimInst1")
      (ng "ElimInst1")
      (use "ElimInst1")
      (use "Rx")
      (use "NatLeTrans" (pt "([p0]N p0 max M p0)p"))
      (ng #t)
      (use "NatMaxUB1")
      (use "Lim1")
      (use "NatLeTrans" (pt "([p0]N p0 max M p0)p"))
      (ng #t)
      (use "NatMaxUB1")
      (use "Lim2")
      (ng #t)
      (use "MonIntro")
      (assume "p" "q" "pleq")
      (ng #t)
      (use "NatMaxLUB")
      (use "NatLeTrans" (pt "N q"))
      (use "MonElim")
      (use "RealConstrToMon" (pt "as"))
      (use "Rx")
      (use "pleq")
      (use "NatMaxUB1")
      (use "NatLeTrans" (pt"M q"))
      (use "MonElim")
      (use "MM")
      (use "pleq")
      (use "NatMaxUB2")
    (assume "Rxx")
  (use "RealLeIntro")
  (use "Rxx")
  (use "Rx")
  (use "RealNNegIntro")
  (use "RealPlusReal")
  (use "Rx")
  (use "RealUMinusReal")
  (use "Rxx")
  (assume "p")
  (ng #t)
  (simprat (pf "as(N(PosS p)max M(PosS p))+ ~(as(N(PosS p)max M(PosS p))) == (0#1)"))
  (use "Truth")
(use "Truth")
(save "RealLeModMax")

(set-goal "all as,M(Real(RealConstr as M) -> Real(RealConstr as ([p]M (PosS p))))")
  (assume "as" "M" "Rx")
  (use "RealIntro")
  (ng #t)
  (use "CauchyIntro")
  (assume "p" "n" "m")
  (ng #t)
  (assume "Lim1" "Lim2")
  (use "CauchyElim" (pt "M"))
  (use "RealConstrToCauchy")
  (use "Rx")
  (use "NatLeTrans" (pt "M (PosS p)"))
  (use "MonElim")
  (use "RealConstrToMon" (pt "as"))
  (use "Rx")
  (use "Truth")
  (use "Lim1")
  (use "NatLeTrans" (pt "M (PosS p)"))
  (use "MonElim")
  (use "RealConstrToMon" (pt "as"))
  (use "Rx")
  (use "Truth")
  (use "Lim2")
  (ng #t)
  (use "MonIntro")
  (assume "p" "q")
  (assume "Rel")
  (cases (pt "p=q"))
  (assume "C1")
  (simp "C1")
  (ng #t)
  (use "Truth")
  (assume "nC1")
    (assert "p < q")
      (use "PosLtCases")
      (use "Rel")
      (use "nC1")
    (assume "C2")
  (use "NatLeTrans" (pt "M q"))
  (ng #t)
  (use "MonElim")
  (use "RealConstrToMon" (pt "as"))
  (use "Rx")
  (ng #t)
  (use "C2")
  (use "MonElim")
  (use "RealConstrToMon" (pt "as"))
  (use "Rx")
  (use "Truth")
(save "RealConstrLemma1")

(set-goal "all as,M(Real(RealConstr as M)->RealConstr as M <<= RealConstr as ([p] M (PosS p)))")
  (assume "as" "M" "Rx")
  (use "RealLeIntro")
  (use "Rx")
  (use "RealConstrLemma1")
  (use "Rx")
  (use "RealNNegIntro")
  (use "RealPlusReal")
  (use "RealConstrLemma1")
  (use "Rx")
  (use "RealUMinusReal")
  (use "Rx")
  (assume "p")
  (ng #t)
  (simprat (pf "as(M(PosS(PosS p))max M(PosS p))+ ~(as(M(PosS(PosS p))max M(PosS p))) == (0#1)"))
  (use "Truth")
  (use "Truth")
(save "RealLeModPos")

(set-goal "all as,M(Real(RealConstr as M)->RealConstr as ([p] M (PosS p)) <<= RealConstr as M)")
  (assume "as" "M" "Rx")
  (use "RealLeIntro")
  (use "RealConstrLemma1")
  (use "Rx")
  (use "Rx")
  (use "RealNNegIntro")
  (use "RealPlusReal")
  (use "Rx")
  (use "RealUMinusReal")
  (use "RealConstrLemma1")
  (use "Rx")
  (assume "p")
  (ng #t)
  (simprat (pf "as(M(PosS p)max M(PosS(PosS p)))+ ~(as(M(PosS p)max M(PosS(PosS p)))) == (0#1)"))
  (use "Truth")
  (use "Truth")
(save "RealLeModPosComm")

(set-goal "all x,y,z(x <<= z -> y <<= z -> x max y <<= z )")
  (cases)
  (assume "as" "M")
  (cases)
  (assume "bs" "N")
  (cases)
  (assume "cs" "L")
  (assume "xLez" "yLez")
  (assert "Real (RealConstr as M)")
  (use "RealLeElim0" (pt "RealConstr cs L"))
  (use "xLez")
  (assume "Rx")
  (assert "Real(RealConstr cs L)")
  (use "RealLeElim1" (pt "(RealConstr as M)"))
  (use "xLez")
  (assume "Rz")
  (assert "Real(RealConstr bs N)")
  (use "RealLeElim0" (pt "(RealConstr cs L)"))
  (use "yLez")
  (assume "Ry")
  (inst-with-to "RealLeElim2" (pt "(RealConstr as M)") (pt "(RealConstr cs L)") "LeElimxz")
  (inst-with-to "RealLeElim2" (pt "(RealConstr bs N)") (pt "(RealConstr cs L)") "LeElimyz")
  (ng "LeElimxz")
  (ng "LeElimyz")
  (inst-with-to "RealNNegElim1" (pt "RealConstr([n]cs n+ ~(bs n))([p]L(PosS p)max N(PosS p) max M(PosS p))") "NNegyz")
  (inst-with-to "RealNNegElim1" (pt "RealConstr([n]cs n+ ~(as n))([p]L(PosS p)max M(PosS p) max N(PosS p))") "NNegxz")
  (use "RealLeIntro")
  (realproof)
  (realproof)
  (use "RealNNegIntro")
  (realproof)
  (assume "q")
  (ng)
  (simp-with "RatPlusComm" 
    (pt "cs(L(PosS q)max N(PosS(PosS q))max M(PosS(PosS q)))")
    (pt "~(as(L(PosS q)max N(PosS(PosS q))max M(PosS(PosS q)))max bs(L(PosS q)max N(PosS(PosS q))max M(PosS(PosS q))))+(1#2**q)"))
  (use "RatLePlusCancelL" (pt "(as(L(PosS q)max N(PosS(PosS q))max M(PosS(PosS q)))max
       bs(L(PosS q)max N(PosS(PosS q))max M(PosS(PosS q))))"))
  (ng #t)
  (simprat (pf "as(L(PosS q)max N(PosS(PosS q))max M(PosS(PosS q)))max
     bs(L(PosS q)max N(PosS(PosS q))max M(PosS(PosS q)))+
     ~(as(L(PosS q)max N(PosS(PosS q))max M(PosS(PosS q)))max
       bs(L(PosS q)max N(PosS(PosS q))max M(PosS(PosS q)))) == (0#1)"))
  (use "RatMaxLUB")
  (ng #t)
  (use "RatLePlusCancelR" (pt "~(as(L(PosS q)max N(PosS(PosS q))max M(PosS(PosS q))))"))
  (simprat (pf "as(L(PosS q)max N(PosS(PosS q))max M(PosS(PosS q)))+ 
     ~(as(L(PosS q)max N(PosS(PosS q))max M(PosS(PosS q)))) == (0#1)"))
  (simp "RatPlusComm")
  (ng #t)
  (simp "RatPlusComm")
  (ng #t)
  (inst-with-to "RealNNegElim1" (pt "(RealConstr cs L)+ ~(RealConstr as ([p] N(PosS p)max M(PosS p)))") "NNegElim1")
  (ng "NNegElim1")
  (use "NNegElim1")
  (ng #t)
  (inst-with-to "RealLeElim2" (pt "RealConstr as ([p] N(PosS p) max M(PosS p))") (pt "RealConstr cs L") "LeElim2")
  (ng "LeElim2")
  (use "LeElim2")
  (use "RealLeTrans" (pt "RealConstr as ([p]M (PosS p))"))
  (inst-with-to "RealLeModMaxCommLemma1" (pt "as") (pt "([p] M (PosS p))") (pt "([p] N(PosS p))") "LeModMaxInst1")
  (ng "LeModMaxInst1")
  (use "LeModMaxInst1")
  (use "RealConstrLemma1")
  (use "Rx")
  (use "RealConstrToMon" (pt "bs"))
  (use "RealConstrLemma1")
  (use "Ry")
  (use "RealLeTrans" (pt "RealConstr as M"))
  (use "RealLeModPosComm")
  (use "Rx")
  (use "xLez")
;  (simp "NatMaxComm")
  (ng #t)
  (use "Truth")
  (use "RatLePlusCancelR" (pt "~(bs(L(PosS q)max N(PosS(PosS q))max M(PosS(PosS q))))"))
  (simprat (pf "bs(L(PosS q)max N(PosS(PosS q))max M(PosS(PosS q)))+  ~(bs(L(PosS q)max N(PosS(PosS q))max M(PosS(PosS q)))) == (0#1)"))
  (inst-with-to "RealNNegElim1" (pt "(RealConstr cs L)+ ~(RealConstr bs ([p] N(PosS p) max M(PosS p)))") "NNegElim1")
  (simp "RatPlusComm")
  (ng #t)
  (simp "RatPlusComm")
  (ng #t)
  (use "NNegElim1")
  (inst-with-to "RealLeElim2" (pt "(RealConstr bs([p] N (PosS p) max M(PosS p)))") (pt "(RealConstr cs L)") "LeElim2")
  (ng "LeElim2")
  (use "LeElim2")
  (use "RealLeTrans" (pt "RealConstr bs ([p] N(PosS p))"))
  (inst-with-to "RealLeModMaxCommLemma2" (pt "bs") (pt "([p] N(PosS p))") (pt "([p] M(PosS p))") "LeModMaxInst1")
  (ng)
  (use "LeModMaxInst1")
  (use "RealConstrLemma1")
  (use "Ry")
  (use "RealConstrToMon" (pt "as"))
  (use "RealConstrLemma1")
  (use "Rx")
  (use "RealLeTrans" (pt "RealConstr bs N"))
  (use "RealLeModPosComm")
  (use "Ry")
  (use "yLez")
  (use "Truth")
  (use "Truth")
(save "RealMaxLUB")


(set-goal "all x,y (Real x -> Real y ->x max y === y max x)")
(assume "x" "y" "Rx" "Ry")
(use "RealLeAntiSym")
(use "RealMaxLUB")
(use "RealMaxUB2")
(autoreal)
(use "RealMaxUB1")
(autoreal)
(use "RealMaxLUB")
(use "RealMaxUB2")
(autoreal)
(use "RealMaxUB1")
(autoreal)
(save "RealMaxComm")

(set-goal "all x,y,z (Real x -> Real y -> Real z-> x max y max z=== x max (y max z))")
(assume "x" "y" "z" "Rx" "Ry" "Rz")
(use "RealLeAntiSym")
(use "RealMaxLUB")
(use "RealMaxLUB")
(use "RealMaxUB1")
(autoreal)
(simpreal "RealMaxComm")
(use "RealLeTrans" (pt "y max z"))
(use "RealMaxUB1")
(autoreal)
(use "RealMaxUB1")
(use "RealMaxReal")
(autoreal)
(simpreal "RealMaxComm")
(use "RealLeTrans" (pt "y max z"))
(use "RealMaxUB2")
(autoreal)
(use "RealMaxUB1")
(use "RealMaxReal")
(autoreal)
(use "RealMaxLUB")
(use "RealLeTrans" (pt "x max y"))
(use "RealMaxUB1")
(autoreal)
(use "RealMaxUB1")
(use "RealMaxReal")
(autoreal)
(use "RealMaxLUB")
(simpreal "RealMaxComm")
(use "RealLeTrans" (pt "x max y"))
(use "RealMaxUB2")
(autoreal)
(use "RealMaxUB2")
(autoreal)
(use "RealMaxUB2")
(autoreal)
(save "RealMaxAssoc")


(set-goal "all x,y,z,z1 (x === z -> y=== z1 -> (x max y === z max z1))")
(assume "x" "y" "z" "z1")
(assume "eq1" "eq2")
(use "RealLeAntiSym")
(use "RealMaxLUB")
(simpreal "eq1")
(use "RealMaxUB1")
(autoreal)
(simpreal "eq2") 
(use "RealMaxUB2")
(autoreal)
(use "RealMaxLUB")
(simpreal "<-" "eq1") 
(use "RealMaxUB1")
(autoreal)
(simpreal "<-" "eq2") 
(use "RealMaxUB2")
(autoreal)
(save "RealMaxCompat")







(set-goal "all x,y ( Real x -> Real y -> (x + ~y)*(x+y)===x*x + ~(y*y))")
(cases)
(assume "as" "M")
(cases)
(assume "bs" "N")
(assume "Ras" "Rbs")
(use "RealEqSToEq")
(autoreal)
(use "RealEqSIntro")
(ng #t)
(assume "n")
(simprat  "RatBinomForm3")
(simp "RatTimesComm")
(ng #t)
(auto)
(save "RealBinomForm3")


(set-goal "all x,p(Real x-> abs(x seq (x mod p)+ ~x)<<=(1#2)**p)")
(cases)
(assume "as" "M")
(assume "p")
(assume "Rx")
(use "RealLeIntro")
(realproof)
(realproof)
(use "RealNNegIntro")
(realproof)
(assume "p0")
(ng)
(simp "RatPlusComm")
(simp "RatPlusAssoc")
(use "RatLePlusR")
(simp "<-" "RatLeUMinus")
(simprat (pf "~ ~abs(as(M p)+ ~(as(M(PosS(PosS p0)))))==abs(as(M p)+ ~(as(M(PosS(PosS p0)))))"))
(simprat (pf "~(~((1#2**p0)+(1#2**p))+0)==(1#2**p0)+(1#2**p)"))
(use "RatLeTrans" (pt "abs(as(M p)+ ~(as(M (p+(PosS(PosS p0))))))+abs(as(M(p+(PosS(PosS p0))))+ ~(as(M(PosS(PosS p0)))))"))
(use "RatLeAbsMinus")
(simp "RatPlusComm")
(use "RatLeMonPlus")
(use "CauchyElim" (pt "M"))
(use "RealConstrToCauchy")
(use "Rx")
(use "MonElim")
(use "RealConstrToMon" (pt "as"))
(use "Rx")
(use "PosLeTrans" (pt "(PosS(PosS p0))"))
(use "PosLeTrans" (pt "PosS p0"))
(use "Truth")
(use "Truth")
(ng)
(use "Truth")
(use "MonElim")
(use "RealConstrToMon" (pt "as"))
(use "Rx")
(use "PosLeTrans" (pt "PosS p0"))
(use "Truth")
(use "Truth")
(use "CauchyElim" (pt "M"))
(use "RealConstrToCauchy")
(use "Rx")
(use "MonElim")
(use "RealConstrToMon" (pt "as"))
(use "Rx")
(ng)
(use "Truth")
(use "MonElim")
(use "RealConstrToMon" (pt "as"))
(use "Rx")
(use "PosLeTrans" (pt "(PosS(PosS p))"))
(use "PosLeTrans" (pt "PosS p"))
(use "Truth")
(use "Truth")
(ng)
(use "Truth")
(use "Truth")
(use "Truth")
(save "RealApproxExFree")

(set-goal "all x,y,z(Real x -> Real y -> Real z-> abs(x+ ~y)<<=abs(x+ ~z) + abs(z+ ~y)) ")
(cases)
(assume "as" "M")
(cases)
(assume "bs" "N")
(cases)
(assume "cs" "L")
(assume "Rx" "Ry" "Rz")
(simpreal (pf "abs(RealConstr as M+ ~(RealConstr bs N))===abs((RealConstr as M+ ~(RealConstr cs L)) +((RealConstr cs L)+ ~(RealConstr bs N)))"))
(use "RealLeTrans" (pt "abs(RealConstr as M+ ~(RealConstr cs L))+abs(RealConstr cs L+ ~(RealConstr bs N))"))
(use "RealLeAbsPlus")
(realproof)
(realproof)
(use "RealLeRefl2")
(realproof)
(realproof)
(use "RealSeqEqToEq" (pt "n"))
(realproof)
(realproof)
(assume "n0")
(assume "Ineq")
(ng #t)
(auto)
(use "RealSeqEqToEq" (pt "n"))
(realproof)
(realproof)
(assume "n0" "Ineq")
(ng #t)
(simprat (pf " as n0+ ~(bs n0)==as n0+ ~(cs n0)+cs n0+ ~(bs n0)"))
(auto)
(simprat (pf "as n0+ ~(cs n0)+cs n0+ ~(bs n0)==as n0+ (~(cs n0)+cs n0)+ ~(bs n0)"))
(simprat (pf "(~(cs n0)+cs n0)==0"))
(auto)
(save "RealLeAbsInvTriangle")

(set-goal "all x,y,z,z1(Real x -> Real y -> Real z -> abs(x+ ~z) + abs(z+ ~y)<<=z1 -> abs(x+ ~y)<<=z1) ")
(assume "x" "y" "z" "z1")
(assume "Rx" "Ry" "Rz")
(assume "cond")
(use "RealLeTrans" (pt "abs(x+ ~z)+abs(z+ ~y)"))
(use "RealLeAbsInvTriangle")
(autoreal)
(auto)
(save "RealLeAbsInvTriangleInj")


(set-goal "all x,y,z,z1(Real x -> Real y -> Real z -> Real z1 -> abs(x+ ~y)<<=abs(x+ ~z)+ abs(z+ ~z1) + abs(z1+ ~y)) ")
(assume "x" "y" "z" "z1")
(assume "Rx" "Ry" "Rz" "Rz1")
(use "RealLeTrans" (pt "abs(x + ~z1) + abs(z1 + ~y)"))
(use "RealLeAbsInvTriangle")
(auto)
(use "RealLeMonPlus")
(use "RealLeAbsInvTriangle")
(auto)
(use "RealLeRefl")
(autoreal)
(save "RealLeAbsInvTriangle2")


(set-goal "all x,y,z,z1,z2(Real x -> Real y -> Real z -> Real z1 -> Real z2 -> abs(x+ ~z)+ abs(z+ ~z1) + abs(z1+ ~y)<<=z2 -> abs(x+ ~y)<<=z2) ")
(assume "x" "y" "z" "z1" "z2")
(assume "Rx" "Ry" "Rz" "Rz1" "Rz2")
(assume "cond")
(use "RealLeTrans" (pt "abs(x+ ~z)+abs(z+ ~z1)+abs(z1+ ~y)"))
(use "RealLeAbsInvTriangle2")
(auto)
(save "RealLeAbsInvTriangle2Inj")
 



(set-goal "all a,b,x,y (Real x -> Real y -> abs(a+ ~b)<<=abs(a+ ~x)+abs(x+ ~y)+abs(y+ ~b))")
(assume "a" "b" "x" "y")
(assume "Rx" "Ry")
(use "RealLeTrans" (pt "abs(a + ~y) + abs(y + ~b)"))
(inst-with-to "RealLeAbsInvTriangle" (pt "ReaRat a") (pt "ReaRat b") (pt "y") "InvTriangleInst")
(ng "InvTriangleInst")
(use "InvTriangleInst")
(autoreal)
(use "RealLeMonPlus")
(inst-with-to "RealLeAbsInvTriangle" (pt "ReaRat a") (pt "y") (pt "x")  "InvTriangleInst")
(ng "InvTriangleInst")
(use "InvTriangleInst")
(autoreal)
(use "RealLeRefl")
(autoreal)
(save "RealLeAbsRatInvTriangle2")


(set-goal "all x (Real x-> ex y x===y)")
(assume "x")
(assume "Rx")
(ex-intro (pt "x"))
(use "RealEqRefl")
(use "Rx")
(save "RealSubVar")

(set-goal "all x (ex y x eqd y)")
(assume "x")
(ex-intro (pt "x"))
(use "InitEqD")
(save "RealSubVarEqd")






(set-goal "all x(RealNNeg(x) ->all p,n(cRealNNegCharOne (x mod) p<=n -> ~(1#2**p)<=x seq n))")
(cases)
(assume "as" "M")
(use "RealNNegCharOneExFree")
(save "RealNNegCharOneExFreeConstrFree")


(set-goal "all x (0<<=x -> RealNNeg x)")
(assume "x" )
(assume "0lex")
(assert "RealNNeg(x + ~0)")
(inst-with-to "RealLeElim2" (pt "ReaRat 0") (pt "x") "Inst")
(use "Inst")
(auto)
(assume "Assertion")
(use "RealNNegCompat" (pt "x + ~0"))
(ng #t)
(simpreal "RealPlusZero")
(use "RealEqRefl")
(autoreal)
(auto)
(save "RealLeToRealNNeg")

(set-goal "all x ( RealNNeg x -> 0<<= x )")
(assume "x" )
(assume "0lex")
(use "RealLeIntro")
(autoreal)
(use "RealNNegCompat" (pt "x"))
(ng #t)
(simpreal "RealPlusZero")
(use "RealEqRefl")
(autoreal)
(auto)
(save "RealNNegToRealLe")


(set-goal "all x(Real x -> exl a all n abs(x seq n)<=a)")
(cases)
(ng #t)
(assume "as" "M")
(assume "RasM")
(inst-with-to "RealBound" (pt "as") (pt "M") "Bound1Inst")
(assert "exl m all n abs(as n)<=2**m")
(use "Bound1Inst")
(use "RealConstrToCauchy")
(auto)
(assume "ExInst")
(by-assume "ExInst" "m" "ExInstProp")
(intro 0 (pt "(2**m#1)"))
(auto)
(save "RealBoundX") 

(animate "RealBound")

(set-goal "all as,M(Cauchy as M -> all n abs(as n)<=2**cRealBound as M)")
(assume "as" "M" "CasM")
(assert "all n(n<=M 1 -> abs(as n)<=2**cRatLeAbsBoundSeq as(Succ(M 1)))")
(assume "n" "n<=M 1")
(use "RatLeAbsBoundSeqExFree")
(use "NatLeToLtSucc")
(use "n<=M 1")
(assume "FinBound" "n")
(cases (pt "n<=M 1"))
(assume "n<=M 1")
(ng)
(simp "SZeroPosPlus")
(use "RatLeTrans" (pt "(2**cRatLeAbsBoundSeq as(Succ(M 1))#1)"))
(use "FinBound")
(use "n<=M 1")
(ng #t)
(use "Truth")
(assume "n<M 1 -> F")
(ng)
(simp "SZeroPosPlus")
(use "RatLeTrans" (pt "abs(as(M 1))+(abs(as n)+ ~(abs(as(M 1))))"))
(assert "all b,c b<=c+(b+ ~c)")
 (assume "b" "c")
 (simp "RatPlusComm")
 (simp "<-" "RatPlusAssoc")
 (simprat (pf "~c+c==0"))
 (use "Truth")
 (use "Truth")
(assume "Assertion")
(use "Assertion")
(use "RatLeTrans" (pt "(2**cRatLeAbsBoundSeq as(Succ(M 1))#1)+(1#2**1)"))
(use "RatLeMonPlus")
(use "FinBound")
(use "Truth")
(use "RatLeTrans" (pt "abs(abs(as n)+ ~abs(as(M 1)))"))
(use "Truth")
(use "RatLeTrans" (pt "abs(as n+ ~(as(M 1)))"))
(use "RatLeAbsMinusAbs")
(use "CauchyElim" (pt "M"))
(use "CasM")
(use "NatNotLtToLe")
(assume "n<M 1")
(use "n<M 1 -> F")
(use "NatLtToLe")
(use "n<M 1")
(use "Truth")
(use "Truth")
(save "RealBoundExFree")

(deanimate "RealBound")

(animate "RealBoundX")

(set-goal "all x(Real x -> all n abs(x seq n)<=cRealBoundX x)")
(cases)
(assume "as" "M")
(assume "RasM")
(ng #t)
(use "RealBoundExFree")
(use "RealConstrToCauchy")
(auto)
(save "RealBoundXExFree")

(set-goal "all x (Real x -> 0<= cRealBoundX x )")
(assume "x" "Rx")
(use "RatLeTrans" (pt "abs(x seq Zero)"))
(use "Truth")
(use "RealBoundXExFree")
(auto)
(save "RealBoundXExFreeProp0")

(deanimate "RealBoundX")

(set-goal "all x (Real x ->0<<= abs(x))")
(cases)
(assume "as" "M")
(assume "RasM")
(use "RealNNegSToZeroLe")
(use "RealAbsReal")
(auto)
(use "RealNNegSIntro")
(ng #t)
(auto)
(save "RealAbsNNeg")

(set-goal "all x,y,n(x seq n + y seq n == (x+y) seq n)")
(cases)
(assume "as" "M")
(cases)
(assume "as0" "M0")
(ng #t)
(auto)
(save "RealsSeqPlusElim")


(set-goal "all x,y(x===y ->
  all p all n(cRealEqCharOne (x mod) (y mod) p<=n -> abs(x seq n+ ~(y seq n))<=(1#2**p)))")
(cases)
(assume "as" "M")
(cases)
(assume "bs" "N")
(use "RealEqCharOneExFree")
(save "RealEqCharOneExFreeConstrFree")



(set-goal "allnc as,bs all M,N(RealConstr as M===RealConstr bs N -> all p exl n1 all n,m(n1<=n -> n1 <= m -> abs(as n+ ~(bs m))<=(1#2**p)))")
(assume "as" "bs" "M" "N" "x=y" "p")
(intro 0 (pt "M(PosS(PosS p))max N(PosS(PosS p))"))
(assume "n" "m" "BdHyp" "BdHyp2")
(use "RatLeTrans"
     (pt "(1#2**(PosS(PosS p)))+(1#2**(PosS p))+(1#2**(PosS(PosS p)))"))
(use "RatLeTrans" (pt "abs(as n+ ~(as(M(PosS(PosS p)))))+
                       abs(as(M(PosS(PosS p)))+ ~(bs(N(PosS(PosS p)))))+
                       abs(bs(N(PosS(PosS p)))+ ~(bs m))"))
(assert "all a,b,c,c1 abs(a+ ~b)<=abs(a+ ~c)+abs(c+ ~c1)+abs(c1+ ~b)")
 (assume "a" "b" "c" "c1")
 (use "RatLeTrans" (pt "abs(a+ ~c1)+abs(c1+ ~b)"))
 (use "RatLeAbsMinus")
 (use "RatLeMonPlus")
 (use "RatLeAbsMinus")
 (use "Truth")
(assume "RatLeAbsMinus3")
(use "RatLeAbsMinus3")
(assert
 "all a1,a2,b1,b2,c1,c2(a1<=a2 -> b1<=b2 -> c1<=c2 -> a1+b1+c1<=a2+b2+c2)")
 (assume "a1" "a2" "b1" "b2" "c1" "c2" "a1<=a2" "b1<=b2" "c1<=c2")
 (use "RatLeMonPlus")
 (use "RatLeMonPlus")
 (use "a1<=a2")
 (use "b1<=b2")
 (use "c1<=c2")
(assume "RatLeMonPlus3")
(use "RatLeMonPlus3")
(use "CauchyElim" (pt "M"))
(use "RealConstrToCauchy")
(use "RealConstrEqElim0" (pt "bs") (pt "N"))
(use "x=y")
(use "NatLeTrans" (pt "(M(PosS(PosS p)))max(N(PosS(PosS p)))"))
(use "NatMaxUB1")
(use "BdHyp")
(use "Truth")
(use "RealConstrEqElim2")
(use "x=y")
(use "CauchyElim" (pt "N"))
(use "RealConstrToCauchy")
(use "RealConstrEqElim0" (pt "as") (pt "M"))
(use "RealEqSym")
(use "x=y")
(use "Truth")
(use "NatLeTrans" (pt "(M(PosS(PosS p)))max(N(PosS(PosS p)))"))
(use "NatMaxUB2")
(use "BdHyp2")
(assert "(1#2**PosS(PosS p))+(1#2**PosS p)=(1#2**PosS p)+(1#2**PosS(PosS p))")
 (use "RatPlusComm")
(assume "Assertion")
(simp "Assertion")
(drop "Assertion")
(simp "<-" "RatPlusAssoc")
(simprat "RatPlusHalfExpPosS")
(simprat "RatPlusHalfExpPosS")
(use "Truth")
(save "RealEqCharOnev2")

(set-goal "all x,y(x===y ->
  all p exl n1 all n,m(n1<=n -> n1<=m -> abs(x seq n+ ~(y seq m))<=(1#2**p)))")
(cases)
(assume "as" "M")
(cases)
(assume "bs" "N")
(use "RealEqCharOnev2")
(save "RealEqCharOnev2ConstrFree")


(animate "RealEqCharOnev2")

(set-goal "all as,bs,M,N(RealConstr as M===RealConstr bs N ->
      all p,n,m(cRealEqCharOnevTwo M N p<=n -> cRealEqCharOnevTwo M N p<=m -> abs(as n-bs m)<=(1#2**p)))")
(assume "as" "bs" "M" "N" "x=y" "p")
(assume "n" "m" "BdHyp" "BdHyp2")
(use "RatLeTrans"
     (pt "(1#2**(PosS(PosS p)))+(1#2**(PosS p))+(1#2**(PosS(PosS p)))"))
(use "RatLeTrans" (pt "abs(as n+ ~(as(M(PosS(PosS p)))))+
                       abs(as(M(PosS(PosS p)))+ ~(bs(N(PosS(PosS p)))))+
                       abs(bs(N(PosS(PosS p)))+ ~(bs m))"))
(assert "all a,b,c,c1 abs(a+ ~b)<=abs(a+ ~c)+abs(c+ ~c1)+abs(c1+ ~b)")
 (assume "a" "b" "c" "c1")
 (use "RatLeTrans" (pt "abs(a+ ~c1)+abs(c1+ ~b)"))
 (use "RatLeAbsMinus")
 (use "RatLeMonPlus")
 (use "RatLeAbsMinus")
 (use "Truth")
(assume "RatLeAbsMinus3")
(use "RatLeAbsMinus3")
(assert
 "all a1,a2,b1,b2,c1,c2(a1<=a2 -> b1<=b2 -> c1<=c2 -> a1+b1+c1<=a2+b2+c2)")
 (assume "a1" "a2" "b1" "b2" "c1" "c2" "a1<=a2" "b1<=b2" "c1<=c2")
 (use "RatLeMonPlus")
 (use "RatLeMonPlus")
 (use "a1<=a2")
 (use "b1<=b2")
 (use "c1<=c2")
(assume "RatLeMonPlus3")
(use "RatLeMonPlus3")
(use "CauchyElim" (pt "M"))
(use "RealConstrToCauchy")
(use "RealConstrEqElim0" (pt "bs") (pt "N"))
(use "x=y")
(use "NatLeTrans" (pt "(M(PosS(PosS p)))max(N(PosS(PosS p)))"))
(use "NatMaxUB1")
(use "BdHyp")
(use "Truth")
(use "RealConstrEqElim2")
(use "x=y")
(use "CauchyElim" (pt "N"))
(use "RealConstrToCauchy")
(use "RealConstrEqElim0" (pt "as") (pt "M"))
(use "RealEqSym")
(use "x=y")
(use "Truth")
(use "NatLeTrans" (pt "(M(PosS(PosS p)))max(N(PosS(PosS p)))"))
(use "NatMaxUB2")
(use "BdHyp2")
(assert "(1#2**PosS(PosS p))+(1#2**PosS p)=(1#2**PosS p)+(1#2**PosS(PosS p))")
 (use "RatPlusComm")
(assume "Assertion")
(simp "Assertion")
(drop "Assertion")
(simp "<-" "RatPlusAssoc")
(simprat "RatPlusHalfExpPosS")
(simprat "RatPlusHalfExpPosS")
(use "Truth")
(save "RealEqCharOnev2ExFree")


(set-goal "all x,y(x===y ->
  all p all n,m(cRealEqCharOnevTwo (x mod) (y mod) p<=n -> cRealEqCharOnevTwo (x mod) (y mod) p<=m ->  abs(x seq n+ ~(y seq m))<=(1#2**p)))")
(cases)
(assume "as" "M")
(cases)
(assume "bs" "N")
(use "RealEqCharOnev2ExFree")
(save "RealEqCharOnev2ExFreeConstrFree")

(deanimate "RealEqCharOne")


(set-goal "all as,M,bs,N(Real(RealConstr as M) -> Real(RealConstr bs N) ->
           all p exnc n0 all n,m(n0<=n -> n0<= m -> abs(as n+ ~(bs m))<=(1#2**p)) ->
           RealConstr as M===RealConstr bs N)")
(assume "as" "M" "bs" "N" "Rx" "Ry" "Est")
(use "RealEqIntro")
(use "Rx")
(use "Ry")
(ng #t)
(assume "p")
(use "RatLeAllPlusToLe")
(assume "q")
(inst-with-to "Est" (pt "q") "InstEst")
(drop "Est")
(by-assume "InstEst" "n0" "n0Prop")
(cut "all n(n=((M(PosS p))max(N(PosS p)))max n0 ->
             abs(as(M(PosS p))+ ~(bs(N(PosS p))))<=(1#2**p)+(1#2**q))")
(assume "AllHyp")
(use "AllHyp" (pt "((M(PosS p))max(N(PosS p)))max n0"))
(use "Truth")
(assume "n" "nDef")
(use "RatLeTrans"
     (pt "abs(as(M(PosS p))+ ~(as n))+
          abs(as n+ ~(bs n))+
          abs(bs n+ ~(bs(N(PosS p))))"))
(assert "all a,b,c,c1 abs(a+ ~b)<=abs(a+ ~c)+abs(c+ ~c1)+abs(c1+ ~b)")
 (assume "a" "b" "c" "c1")
 (use "RatLeTrans" (pt "abs(a+ ~c1)+abs(c1+ ~b)"))
 (use "RatLeAbsMinus")
 (use "RatLeMonPlus")
 (use "RatLeAbsMinus")
 (use "Truth")
(assume "RatLeAbsMinus3")
(use "RatLeAbsMinus3")
(use "RatLeTrans" (pt "(1#2**(PosS p))+(1#2**q)+(1#2**(PosS p))"))
(assert
 "all a1,a2,b1,b2,c1,c2(a1<=a2 -> b1<=b2 -> c1<=c2 -> a1+b1+c1<=a2+b2+c2)")
 (assume "a1" "a2" "b1" "b2" "c1" "c2" "a1<=a2" "b1<=b2" "c1<=c2")
 (use "RatLeMonPlus")
 (use "RatLeMonPlus")
 (use "a1<=a2")
 (use "b1<=b2")
 (use "c1<=c2")
(assume "RatLeMonPlus3")
(use "RatLeMonPlus3")
(drop "RatLeMonPlus3")
(use "CauchyElim" (pt "M"))
(use "RealConstrToCauchy")
(use "Rx")
(use "Truth")
(simp "nDef")
(use "NatLeTrans" (pt "M(PosS p)max N(PosS p)"))
(use "NatMaxUB1")
(use "NatMaxUB1")
(use "n0Prop")
(simp "nDef")
(use "NatMaxUB2")
(simp "nDef")
(use "NatMaxUB2")
(use "CauchyElim" (pt "N"))
(use "RealConstrToCauchy")
(use "Ry")
(simp "nDef")
(use "NatLeTrans" (pt "M(PosS p)max N(PosS p)"))
(use "NatMaxUB2")
(use "NatMaxUB1")
(use "Truth")
(simprat (pf "(1#2**PosS p)+(1#2**q)==(1#2**q)+(1#2**PosS p)"))
(simp "<-" "RatPlusAssoc")
(simprat "RatPlusHalfExpPosS")
(simp "RatPlusComm")
(use "Truth")
(simp "RatPlusComm")
(use "Truth")
(save "RealEqChar2v2")


(set-goal "all x,y(Real x -> Real y ->
 all p exnc n0 all n,m(n0<=n -> n0<=m-> abs(x seq n+ ~(y seq m))<=(1#2**p)) -> x===y)")
(cases)
(assume "as" "M")
(cases)
(assume "bs" "N")
(use "RealEqChar2v2")
;; Proof finished.
(save "RealEqChar2RealConstrFreev2")

(set-goal "all x,p (RealLt ~x 0 p -> RealLt 0 x p)")
(cases)
(assume "as" "M")
(assume "p")
(ng #t)
(auto)
(save "RealLtUMinus")


(set-goal "all x,p (RealLt x 0 p -> RealLt 0 ~x p)")
(cases)
(assume "as" "M")
(assume "p")
(ng #t)
(auto)
(save "RealLtUMinus1")


(set-goal "all x,p (RealLt 0 ~x p -> RealLt x 0 p)")
(cases)
(assume "as" "M")
(assume "p")
(ng #t)
(auto)
(save "RealLtUMinusBack")

;; from compreal.scm
(set-goal "all x(Real x -> exl p(RealLt x x p) -> F)")
(cases)
(assume "as" "M" "Rx" "ex x<x")
(elim "ex x<x")
(assume "p" "x<x")
(assert "(1#2**p)<=0")
(simp "RatLeCompat" (pt "(1#2**p)") (pt "as(M(PosS(PosS p)))+ ~(as(M(PosS(PosS p))))"))
(ng "x<x")
(use "x<x")
(simprat (pf "as(M(PosS(PosS p)))+ ~(as(M(PosS(PosS p))))==0"))
(use "Truth")
(use "Truth")
(use "Truth")
(assume "pos<=0")
(ng)
(use "pos<=0")
(save "RealLtNotSym")

;; from compreal.scm
(set-goal "all x,y,p (Real x -> Real y -> RealNNeg(x) -> RealPos(y)p -> RealPos(x+y)(PosS(PosS(PosS p))))")
(cases)
(assume "as" "M")
(cases)
(assume "as0" "M0")
(assume "p" "Rx" "Ry" "0<=x" "0<y")
(use "RealPosChar2RealConstrFree" (pt "cRealNNegCharOne M(PosS(PosS p))max(M(PosS(PosS(PosS p)))max M0(PosS(PosS(PosS p))))"))
(use "RealPlusReal")
(use "Rx")
(use "Ry")
(assume "n" "n0<=n")
(assert "all p,n (cRealNNegCharOne M p<=n -> ~(1#2**p)<=as n)")
(use "RealNNegCharOneExFree")
(use "0<=x")
(assume "all_x ineq")
(assert "~(1#2**(PosS(PosS p)))<=as n")
(inst-with-to "all_x ineq" (pt "PosS(PosS p)") (pt "n") "hyp")
(drop "all_x ineq")
(use "hyp")
(drop "hyp")
(use "NatLeTrans" (pt "cRealNNegCharOne M(PosS(PosS p))max (M(PosS(PosS(PosS p)))max M0(PosS(PosS(PosS p))))"))
(use "NatMaxUB1")
(use "n0<=n")
(assume "x ineq")
(ng)
(assert "all n(M0 (PosS p) <=n -> (1#2**(PosS p))<=as0 n)")
(use "RealPosChar1")
(use "Ry")
(use "0<y")
(assume "all_y ineq")
(assert "(1#2**(PosS p))<=as0 n")
(use "all_y ineq")
(use "NatLeTrans" (pt "M0(PosS(PosS(PosS p)))"))
(use "MonElim")
(use "RealConstrToMon" (pt "as0"))
(use "Ry")
(use "PosLeTrans" (pt "PosS(PosS p)"))
(use "Truth")
(use "Truth")
(use "NatLeTrans" (pt "M(PosS(PosS(PosS p)))max M0(PosS(PosS(PosS p)))"))
(use "NatMaxUB2")
(use "NatLeTrans" (pt "cRealNNegCharOne M(PosS(PosS p))max (M(PosS(PosS(PosS p)))max M0(PosS(PosS(PosS p))))"))
(use "NatMaxUB2")
(use "n0<=n")
(assume "y ineq")
(drop "all_y ineq")
(use "RatLeTrans" (pt "(IntN 1#2**PosS(PosS p))+(1#2**PosS p)"))
(simprat (pf "(IntN 1#2**PosS(PosS p))+(1#2**PosS p)==(1#2**(PosS(PosS p)))"))
(use "Truth")
(simprat "<-" "RatPlusHalfExpPosS")
(simp "RatPlusAssoc")
(simprat (pf "(IntN 1#2**PosS(PosS p))+(1#2**PosS(PosS p))==0"))
(ng)
(use "Truth")
(ng)
(use "Truth")
(use "RatLeMonPlus")
(use "x ineq")
(use "y ineq")
(save "PlusPos")

;; from compreal.scm
(set-goal "all x,y(Real x -> Real y -> x<<=y -> exl p(RealLt(y)(x)p) -> F)")
(cases)
(assume "as" "M")
(cases)
(assume "bs" "N" "Rx" "Ry" "x<<=y" "y<x")
(elim "y<x")
(assume "p" "p:y<x")
(assert "RealLt(RealConstr as M)(RealConstr as M)(PosS(PosS(PosS(PosS(PosS p)))))")
(use "RealLeLtTrans" (pt "RealConstr bs N"))
(use "Rx")
(use "Ry")
(use "Rx")
(use "x<<=y")
(use "RealLtCompatRealConstrFree" (pt "RealConstr bs N") (pt "RealConstr as M"))
(use "RealEqRefl")
(auto)
(use "RealEqRefl")
(auto)
(assume "p+5:x<x")
(use "RealLtNotSym" (pt "RealConstr as M"))
(use "Rx")
(intro 0 (pt "PosS(PosS(PosS(PosS(PosS p))))"))
(use "p+5:x<x")
(save "LeIsNotGt")


(set-goal "all x,y,p(Real x -> Real y -> x<<=y ->  RealLt y x p -> F)")
(cases)
(assume "as" "M")
(cases)
(assume "bs" "N" "p" "Rx" "Ry" "x<<=y" "y<x")
(assert "RealLt(RealConstr as M)(RealConstr as M)(PosS(PosS(PosS(PosS(PosS p)))))")
(use "RealLeLtTrans" (pt "RealConstr bs N"))
(auto)
(use "RealLtCompatRealConstrFree" (pt "RealConstr bs N") (pt "RealConstr as M"))
(auto)
(use "RealEqRefl")
(auto)
(use "RealEqRefl")
(auto)
(assume "p+5:x<x")
(use "RealLtNotSym" (pt "RealConstr as M") (pt "(PosS(PosS(PosS(PosS(PosS p)))))"))
(use "Rx")
(intro 0 (pt "(PosS(PosS(PosS(PosS(PosS p)))))"))
(auto)
(save "LeIsNotGtExFree")




;; from compreal.scm
(set-goal "all x,y,z,p(Real x -> Real y -> Real z -> RealLt(x)(y)p -> RealLt(x+z)(y+z)(PosS(PosS p)))")
(cases)
(assume "as" "M")
(cases)
(assume "as0" "M0")
(cases)
(assume "as1" "M1")
(assume "p" "Rx" "Ry" "Rz" "x<y")
(cut "RealPos(RealConstr as0 M0+RealConstr as1 M1+ ~(RealConstr as M+RealConstr as1 M1))(PosS(PosS p))")
(assume "hyp")
(ng)
(use "hyp")
(assert "RealPos(RealConstr as0 M0+ ~(RealConstr as M))p")
(ng)
(use "x<y")
(assume "0<y-x")
(use "RealPosCompatRealConstrFree" (pt "RealConstr as0 M0+ ~(RealConstr as M)"))
(use "RealEqTrans" (pt "RealConstr as0 M0+(RealConstr as1 M1+ ~(RealConstr as1 M1)+ ~(RealConstr as M))"))
(use "RealPlusCompat")
(use "RealEqRefl")
(use "Ry")
(use "RealEqTrans" (pt "0+ ~(RealConstr as M)"))
(use "RealEqTrans" (pt "~(RealConstr as M)+0"))
(use "RealEqSym")
(use "RealPlusZero")
(use "RealUMinusReal")
(use "Rx")
(use "RealPlusComm")
(use "RealUMinusReal")
(use "Rx")
(use "RealRat")
(use "RealPlusCompat")
(use "RealEqSym")
(use "RealPlusMinusZero")
(use "Rz")
(use "RealEqRefl")
(use "RealUMinusReal")
(use "Rx")
(use "RealEqTrans" (pt "RealConstr as0 M0+(RealConstr as1 M1+ ~(RealConstr as1 M1))+ ~(RealConstr as M)"))
(use "RealPlusAssoc")
(use "Ry")
(use "RealPlusReal")
(use "Rz")
(use "RealUMinusReal")
(use "Rz")
(use "RealUMinusReal")
(use "Rx")
(use "RealEqTrans" (pt "RealConstr as0 M0+RealConstr as1 M1+ ~(RealConstr as1 M1)+ ~(RealConstr as M)"))
(use "RealPlusCompat")
(use "RealPlusAssoc")
(use "Ry")
(use "Rz")
(use "RealUMinusReal")
(use "Rz")
(use "RealEqRefl")
(use "RealUMinusReal")
(use "Rx")
(use "RealEqTrans" (pt "RealConstr as0 M0+RealConstr as1 M1+(~(RealConstr as1 M1)+ ~(RealConstr as M))"))
(use "RealEqSym")
(use "RealPlusAssoc")
(use "RealPlusReal")
(use "Ry")
(use "Rz")
(use "RealUMinusReal")
(use "Rz")
(use "RealUMinusReal")
(use "Rx")
(use "RealPlusCompat")
(use "RealEqRefl")
(use "RealPlusReal")
(use "Ry")
(use "Rz")
(use "RealEqTrans" (pt "~(RealConstr as M)+ ~(RealConstr as1 M1)"))
(use "RealPlusComm")
(use "RealUMinusReal")
(use "Rz")
(use "RealUMinusReal")
(use "Rx")
(use "RealEqSym")
(use "RealUMinusPlus")
(use "Rx")
(use "Rz")
(use "0<y-x")
(save "RealLtMonPlus")





(set-goal "all x,y(Real x -> Real y -> (exl p(RealLt y x p) -> F) -> x<<=y)")
(assert "all z(Real z -> (exl q(RealLt 0 z q) -> F) -> z<<=0)")
(cases)
(assume "cs" "L" "Rz" "0<z -> F")
(use "RealLeIntro")
(use "Rz")
(use "RealRat")
(use "RealNNegChar2RealConstrFree")
(use "RealPlusReal")
(use "RealRat")
(use "RealUMinusReal")
(use "Rz")
(assume "p")
(assert "cs (L(PosS(PosS(PosS p))))<(1#2**PosS p)")
(use "RatNotLeToLt")
(assume "ineq1")
(use "0<z -> F")
(intro 0 (pt "PosS p"))
(ng)
(use "ineq1")
(assume "cs L(p+3)<2^-p-1")
(intro 0 (pt "L(PosS(PosS(PosS p)))"))
(assume "n" "n0<=n")
(simprat (pf "(0+ ~(RealConstr cs L))seq n== ~(cs n)"))
(simp "RatLeUMinus")
(use "RatLeTrans" (pt "cs (L(PosS(PosS(PosS p))))+(1#2**PosS(PosS p))"))
(use "RatLePlusMinusToRatLePlus")
(simp "RatPlusComm")
(use "RatLeTrans" (pt "abs(cs n+ ~(cs(L(PosS(PosS(PosS p))))))"))
(use "Truth")
(use "CauchyElim" (pt "L"))
(use "RealConstrToCauchy")
(use "Rz")
(use "NatLeTrans" (pt "L(PosS(PosS(PosS p)))"))
(use "MonElim")
(use "RealConstrToMon" (pt "cs"))
(use "Rz")
(use "Truth")
(use "n0<=n")
(use "MonElim")
(use "RealConstrToMon" (pt "cs"))
(use "Rz")
(use "Truth")
(use "RatLeTrans" (pt "(1#2**PosS p)+(1#2**PosS p)"))
(use "RatLeMonPlus")
(use "RatLtToLe")
(use "cs L(p+3)<2^-p-1")
(simp "<-" "RatLeUMinus")
(simprat "<-" "RatPlusHalfExpPosS")
(use "Truth")
(simprat "RatPlusHalfExpPosS")
(use "Truth")
(use "Truth")
(assume "hyp")
(assume "x" "y" "Rx" "Ry" "not y<x")
(use "RealLeIntro")
(use "Rx")
(use "Ry")
(use "RealNNegCompat" (pt "0+ ~(x+ ~y)"))
(use "RealEqTrans" (pt " ~(x+ ~y) + 0"))
(use "RealPlusComm")
(use "RealRat")
(autoreal)
(simpreal "RealPlusZero")
(simpreal (pf "~(x+ ~y)=== ~x +y"))
(use "RealPlusComm")
(autoreal)
(simpreal "RealUMinusPlus")
(simpreal "RealUMinusUMinus")
(use "RealEqRefl")
(autoreal)
(use "RealLeElim2")
(use "hyp")
(realproof)
(assume "0<x-y")
(use "not y<x")
(elim "0<x-y")
(assume "p" "p:0<x-y")
(intro 0 (pt "(PosS(PosS(PosS(PosS p))))"))
(use "RealLtIntro")
(use "RealPosCompatRealConstrFree" (pt "x+ ~y+y+ ~(0+y)"))
(use "RealPlusCompat")
(use "RealEqTrans" (pt "x+0"))
(use "RealEqTrans" (pt "x+(~y+y)"))
(use "RealEqSym")
(use "RealPlusAssoc")
(autoreal)
(use "RealPlusCompat")
(use "RealEqRefl")
(use "Rx")
(use "RealEqTrans" (pt "y+ ~y"))
(use "RealPlusComm")
(autoreal)
(use "RealPlusMinusZero")
(use "Ry")
(use "RealPlusZero")
(use "Rx")
(simpreal (pf "0+y===y"))
(use "RealEqRefl")
(autoreal)
(simpreal "RealPlusComm")
(use "RealPlusZero")
(autoreal)
(use "RealLtElim")
(use "RealLtMonPlus")
(use "RealRat")
(use "RealPlusReal")
(use "Rx")
(use "RealUMinusReal")
(use "Ry")
(use "Ry")
(use "p:0<x-y")
(save "NotGtIsLt")


;; taken from coq
(set-goal "all x,y ( Real x -> Real y -> (x <<= 0 -> F) -> 0<<= x*y -> 0 <<= y )")
(assume "x" "y")
(assume "Rx" "Ry")
(assume "cond1" "cond2")
(use "NotGtIsLt")
(autoreal)
(assume "H")
(use "cond1")
(use "NotGtIsLt")
(autoreal)
(assume "H2")
(by-assume "H" "p" "Hprop")
(by-assume "H2" "p0" "Hprop2")
(use "LeIsNotGtExFree"   (pt "x*(~y)") (pt "ReaRat 0") (pt "PosS(PosS(PosS(p0+p)))"))
(realproof)
(simp "ReaRat0CompRule")
(autoreal)
(use "RealLeUMinusInv")
(ng #t)
(use "RealLeTrans" (pt "x*y"))
(auto)
(simpreal "RealTimesIdUMinus")
(simpreal "RealUMinusUMinus")
(use "RealLeRefl")
(autoreal)
(simp "ReaRat0CompRule")
(use "RealLtTimesMon")
(autoreal)
(use "Hprop2")
(use "RealLtUMinus1")
(use "Hprop")
(save "RealLeTimesCancelLC")

(set-goal "all x,p (RealLt 0 x p -> RealPos x (PosS(p)))")
(cases)
(assume "as" "M")
(assume "p")
(ng #t)
(assume "cond")
(use "RatLeTrans" (pt "(1#2**p)"))
(use "RatLtToLe")
(ng #t)
(use "PosExpLtPosSExp")
(auto)
(save "RealLtToRealPos")

(set-goal "all x,y( Real x -> Real y -> (x===0  -> F) -> x*y ===0 -> y===0)")
(assume "x" "y" "Rx" "Ry" "xneq0" "x*yeq0")
(use "RealLeAntiSym")
(use "NotGtIsLt")
(autoreal)
(assume "Hyp1")
(by-assume "Hyp1" "p0" "Hyp1Prop")
(use "xneq0")
(use "RealEqTimesCancelR" (pt "y") (pt "PosS(p0)"))
(autoreal)
(use "RealLtToRealPos")
(auto)
(simpreal "RealZeroTimes")
(auto)
(use "NotGtIsLt")
(auto)
(autoreal)
(assume "Hyp2")
(by-assume "Hyp2" "p0" "Hyp2Prop")
(use "xneq0")
(use "RealEqTimesCancelR" (pt "~y") (pt "PosS(p0)"))
(auto)
(autoreal)
(use "RealLtToRealPos")
(use "RealLtUMinus1")
(use "Hyp2Prop")
(use "RealEqTrans" (pt "~(ReaRat 0)"))
(cut "Real(~(ReaRat 0))")
(assume "cutInst")
(simpreal "RealTimesIdUMinus")
(use "RealUMinusCompat")
(auto)
(simp "ReaRat0CompRule")
(autoreal)
(ng #t)
(simpreal "RealZeroTimes")
(use "RealEqRefl")
(autoreal)
(save "RealEqTimesCancelLC")



(set-goal "all x,y (0<<=x -> 0<<=y -> x*x === y*y -> x===y)")
(assume "x" "y" "0lex" "0ley" "cond")
(use "Stab")
(assume "Neq")
(assert "(x + ~y)*(x+y)===0")
(simpreal "RealBinomForm3")
(use "RealEqPlusCancelR" (pt "y*y"))
(autoreal)
(simpreal "<-" "RealPlusAssoc")
(simpreal (pf "~(y*y)+y*y===0"))
(simpreal (pf "x*x+0===x*x"))
(simpreal (pf "0+y*y===y*y"))
(use "cond")
(simpreal "RealPlusComm")
(use "RealPlusZero")
(autoreal)
(use "RealPlusZero")
(autoreal)
(simpreal "RealPlusComm")
(use "RealPlusMinusZero")
(autoreal)
(assume "Assertion")
(cut "x + ~y ===0")
(assume "cutInst")
(use "Neq")
(use "RealEqPlusCancelR" (pt "~y"))
(autoreal)
(simpreal (pf "y+ ~y===0"))
(auto)
(use "RealPlusMinusZero")
(autoreal)
(use "RealEqTimesCancelLC" (pt "(x+y)"))
(autoreal)
(assume "x+yeq0")
(assert "x===0")
(use "RealLeAntiSym")
(use "RealLeTrans" (pt "x+y"))
(use "RealLeTrans" (pt "x+0"))
(use "RealLeReflNC")
(use "RealEqSym")
(use "RealPlusZero")
(autoreal)
(use "RealLeMonPlus")
(use "RealLeRefl")
(autoreal)
(auto)
(use "RealLeReflNC")
(auto)
(assume "x=0")
(assert "y===0")
(use "RealEqTrans" (pt "x+y"))
(simpreal "x=0")
(simpreal "RealPlusComm")
(use "RealEqSym")
(use "RealPlusZero")
(autoreal)
(auto)
(assume "y=0")
(use "Neq")
(simpreal "x=0")
(simpreal "y=0")
(use "RealEqRefl")
(autoreal)
(simpreal "RealTimesComm")
(auto)
(autoreal)
(save "SqrRevCompat")



(animate "RealBound")

(set-goal "all as,M Zero<cRealBound as M")
(assume "as" "M")
(use "Truth")
(save "RealBoundPos")

(deanimate "RealBound")



(set-goal "all x,n ( Real x -> n*x+x===(Succ n)*x)")
(assume "x" )
(assume "n")
(assume "Rx")
(simpreal (pf "Succ n===(n+1)"))
;;(simpreal "<-" "RealTimesPlusDistrLeft")
(inst-with-to "RealTimesPlusDistrLeft" (pt "ReaRat(n)") (pt "ReaRat(1)") (pt "x") "DistrInst")
(use "RealEqTrans" (pt "(ReaRat n+ReaRat 1)*x")) 
(simpreal "DistrInst")
(ng #t)
(use "RealPlusCompat")
(use "RealEqRefl")
(autoreal)
(simpreal "RealTimesComm")
(simpreal "RealTimesOne")
(use "RealEqRefl")
(realproof)
(realproof)
(realproof)
(realproof)
(realproof)
(simp "ReaRat0CompRule")
(realproof)
(simp "ReaRat0CompRule")
(realproof)
(use "RealTimesCompat")
(ng #t)
(use "RatEqvToRealEq")
(ng #t)
(assert "all n IntPlus n 1=IntS n")
(ind)
(ng #t)
(auto)
(assume "n0" "Ih")
(ng #t)
(use "IntPredInj")
(ng #t)
(use "Ih")
(auto)
(use "RealEqRefl")
(autoreal)
(ng #t)
(use "RatEqvToRealEq")
(auto)
(save "RealSuccDistr")

(set-goal "all x,y ( Real x -> Real y -> (x<<=y -> F) -> exca p RealLt y x p)")
(assume "x" "y" "Rx" "Ry")
(assume "RealNNegNot")
(assume "p0")
(use "RealNNegNot")
(use "NotGtIsLt")
(use "Rx")
(use "Ry")
(assume "ExP")
(by-assume "ExP" "p0" "Expprop")
(use "p0" (pt "p0"))
(use "Expprop")
(save "ClassicalComparison")

(set-goal "all x,y ( Real x -> Real y -> exca p RealLt y x p ->  (x<<=y -> F) )")
(assume "x" "y" "Rx" "Ry")
(assume "ExCa")
(assume "xley")
(use "ExCa")
(assume "p")
(assume "y<x")
(use "LeIsNotGt" (pt "x") (pt "y"))
(auto)
(intro 0 (pt "p"))
(auto)
(save "ClassicalComparison2")

(set-goal "all x,y ( Real x -> Real y -> exca p RealLt x y p -> x<<=y)")
(assume "x" "y" "Rx" "Ry" "x<y")
(by-assume "x<y" "p" "LtProp") 
(use "RealLtToLe" (pt "p"))
(auto)
(save "RealLtToLeClass")






(set-goal "all x,p (RealLt (0) x p -> RealLt (~x) (ReaRat 0) p)")
(cases)
(assume "as" "M")
(assume "p")
(assume "RealLt1")
(use "RealLtIntro")
(ng #t)
(ng "RealLt1")
(auto)
(save "RealLtToGtNegReaRat")


(set-goal "all x,p (Real x -> RealPos x p -> RealLt 0 x (PosS(PosS p)))")
(cases)
(assume "as" "M")
(assume "p")
(assume "Rx" "Rpos")
(simp "RealLt0CompRule")
(simp "RealMinus0CompRule")
(simp "RealUMinus0CompRule")
(simp "RealPlus0CompRule")
(use "RealPosCompat" (pt "as") (pt "M"))
(use "RealEqSToEq")
(realproof)
(simp "<-" "RealPlus0CompRule")
(simp "<-" "RealUMinus0CompRule")
(autoreal)
(use "RealEqSIntro")
(ng #t)
(auto)
(save "RealPosLtCompat")


(set-goal "all x(Real x -> exr p RealLt 0 x p -> exr p RealPos x p)")
(cases)
(assume "as" "M")
(assume "Rx")
(assume "ExInst")
(by-assume "ExInst" "p0" "ExInstProp")
(intro 0 (pt "((PosS p0))"))
(ng)
(use "RatLeTrans" (pt "(1#2**p0)"))
(ng #t)
(use "PosLtToLe")
(use "PosExpLtPosSExp")
(auto)
(save "RealLtRealPosExR")


(set-goal "all x,y (Real x -> abs(x)<<=y -> ~y<<=x & x<<=y)")
(assume "x" "y")
(assume "Rx")
(assume "absxley")
(split)
(use "RealLePlusCancelR" (pt "y"))
(autoreal)
(simpreal (pf "~y+y===0"))
(use "RealLePlusCancelL" (pt "~x"))
(autoreal)
(simpreal "RealPlusAssoc")
(simpreal (pf "~x+0=== ~x"))
(simpreal (pf "~x+x===0"))
(simpreal (pf "0+y===y"))
(use "RealLeTrans" (pt "abs x"))
(use "RealAbsInvLeEqAbs")
(autoreal)
(auto)
(simpreal "RealPlusComm")
(use "RealPlusZero")
(autoreal)
(simpreal "RealPlusComm")
(use "RealPlusMinusZero")
(autoreal)
(use "RealPlusZero")
(autoreal)
(simpreal "RealPlusComm")
(use "RealPlusMinusZero")
(autoreal)
(use "RealLeTrans" (pt "abs(x)"))
(use "RealLeAbsId")
(autoreal)
(auto)
(save "RealAbsLeCases")

(set-goal "all x(Real x -> abs x===x max (~x))")
(cases)
(assume "as" "M" "Ras")
(use "RealEqSToEq")
(autoreal)
(use "RealEqSIntro")
(ng #t)
(assume "n")
(simp "RatAbsMax")
(auto)
(save "RealAbsMax")


(set-goal "all x,y (Real x ->  ~y<<=x & x<<=y -> abs(x)<<=y )")
(assume "x" "y")
(assume "Rx")
(assume "caseprop")
(cut "Real y")
(assume "Ry")
(simpreal "RealAbsMax")
(use "RealMaxLUB")
(auto)
(use "RealLePlusCancelR" (pt "x"))
(autoreal)
(simpreal (pf " ~x+ x===0"))
(use "RealLePlusCancelL" (pt "~y"))
(autoreal)
(simpreal (pf "~y+0=== ~y"))
(simpreal "RealPlusAssoc")
(simpreal (pf"~y+y===0"))
(simpreal (pf "0+x===x"))
(auto)
(simpreal "RealPlusComm")
(use "RealPlusZero")
(autoreal)
(simpreal "RealPlusComm")
(use "RealPlusMinusZero")
(autoreal)
(use "RealPlusZero")
(autoreal)
(simpreal "RealPlusComm")
(use "RealPlusMinusZero")
(realproof)
(realproof)
(realproof)
(realproof)
(use "RealLeElim1" (pt "x"))
(auto)
(save "RealAbsLeCases2")



(set-goal "all x,y(Real x -> Real y -> abs(x+ ~y)===abs(y + ~x))")
(assume "x" "y" "Rx" "Ry")
(simpreal (pf "x + ~y=== ~(~x + y)"))
(simpreal "RealAbsUMinus")
(simpreal "RealPlusComm")
(use "RealEqRefl")
(autoreal)
(simpreal "RealUMinusPlus")
(simpreal "RealUMinusUMinus")
(use "RealEqRefl")
(autoreal)
(save "RealAbsUMinusPlusComm")


(set-goal "all x,y,z,z1(Real x -> Real y -> Real z -> Real z1 -> abs(z+ ~z1) - abs(z+ ~x) - abs(z1+ ~y)<<= abs(x+ ~y)) ")
(assume "x" "y" "z" "z1")
(assume "Rx" "Ry" "Rz" "Rz1")
(simp "RealMinus0CompRule")
(simp "RealMinus0CompRule")
(use "RealLePlusCancelR" (pt "abs(z1 + ~y)"))
(autoreal)
(simpreal "<-" "RealPlusAssoc")
(simpreal (pf "~abs(z1+ ~y)+abs(z1+ ~y)===0"))
(use "RealLeTrans" (pt "abs(z+ ~z1)+ ~abs(z+ ~x)"))
(ng #t)
(use "RealLeReflNC")
(use "RealPlusZero")
(autoreal)
(use "RealLePlusCancelR" (pt "abs(z + ~x)"))
(autoreal)
(simpreal "<-" "RealPlusAssoc")
(simpreal (pf "~abs(z+ ~x)+abs(z+ ~x)===0"))
(use "RealLeTrans" (pt "abs(z+ ~z1)"))
(use "RealLeReflNC")
(use "RealPlusZero")
(autoreal)
(use "RealLeTrans" (pt "abs(z + ~x) + abs(x + ~y) + (abs(z1 + ~y))"))
(simpreal (pf "abs(z1 + ~y)===abs(y + ~z1)"))
(use "RealLeAbsInvTriangle2")
(autoreal)
(use "RealAbsUMinusPlusComm")
(autoreal)
(simpreal "<-" "RealPlusAssoc")
(simpreal "RealPlusComm")
(use "RealLeRefl")
(autoreal)
(simpreal "RealPlusComm")
(use "RealPlusMinusZero")
(autoreal)
(simpreal "RealPlusComm")
(use "RealPlusMinusZero")
(autoreal)
(save "RealLeAbsInvTriangle2LB")

(set-goal "all x,y( 0<<=x -> x<<=y -> abs(x)<<=abs(y))")
(assume "x" "y")
(assume "0<=x")
(assume "x<=y")
(use "RealLeTrans" (pt "x"))
(use "RealAbsId")
(use "RealLeToRealNNeg")
(auto)
(use "RealLeTrans" (pt "y"))
(auto)
(use "RealLeAbsId")
(autoreal)
(save "RealLeAbsCompat")




(set-goal "all x,p((1#2**p)<<=x -> RealPos x (PosS(PosS p)))")
(cases)
(assume "as" "M" "p" "0<x")
(inst-with-to "RealLeCharOneRealConstrFree" (pt "ReaRat (1#2**p)") (pt "RealConstr as M ") "Inst")
(ng "Inst")
(cut "all p0 exl n all n0(n<=n0 -> (1#2**p)<=as n0+(1#2**p0))")
(assume "Inst2")
(inst-with-to "Inst2" (pt "PosS p") "InstEx")
(by-assume "InstEx" "n0" "InstExProp")
(use "RealPosChar2" (pt "n0"))
(autoreal)
(assume "n" "n0<=n")
(simprat (pf "(1#2**PosS p)== (1#2**p)+ ~(1#2**PosS p)"))
(use "RatLePlusCancelR" (pt "1#2**PosS p"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "~(1#2**PosS p)+(1#2**PosS p)==0"))
(simprat (pf "(1#2**p)+0==(1#2**p)"))
(use "InstExProp")
(auto)
(use "RatEqvPlusCancelR" (pt "1#2**PosS p"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "(~(1#2**PosS p)+(1#2**PosS p))==0"))
(simprat "RatPlusHalfExpPosS")
(auto)
(use "Inst")
(auto)
(save "RealEpsLeToLt")

(set-goal "all x,y,p(Real x -> Real y -> (1#2**p)<<=y+ ~x -> RealLt x y (PosS(PosS p)))")
(cases)
(assume "as" "M")
(cases)
(assume "bs" "N")
(assume "p")
(assume "Rx" "Ry") 
(assume "cond")
(simp "RealLt0CompRule")
(inst-with-to "RealEpsLeToLt" (pt "RealConstr bs N-RealConstr as M") (pt "p") "Inst") 
(use "Inst")
(auto)
(save "RealEpsLeToLt2")


(add-computation-rules "(RealConstr as M) min (RealConstr bs N)" "RealConstr ([n] as n min bs n) ([p] (N (PosS p)) max (M (PosS p)))")

(set-totality-goal "RealMin")
	(assume "x^1" "Tx1" "x^2" "Tx2")
	(elim "Tx1")
	(assume "as^1" "Tas1" "M^1" "TM1")
	(elim "Tx2")
	(assume "as^2" "Tas2" "M^2" "TM2")
	(ng #t)
	(use "TotalReaRealConstr")
	(ng #t)
	(assume "n^1" "Tn1")
	(use "RatMinTotal")
	(use "Tas1")
	(use "Tn1")
	(use "Tas2")
	(use "Tn1")
	(assume "p^1" "Tp1")
	(ng #t)
	(use "NatMaxTotal")
	(use "TM2")
	(use "PosSTotal")
	(use "Tp1")
	(use "TM1")
	(use "PosSTotal")
	(use "Tp1")
(save-totality)

(set-goal "all x,y (Real x -> Real y -> Real (x min y))")
(assume "x" "y" "Rx" "Ry")
(elim "Rx")
(cases)
(assume "as" "M" "Cas" "Mas")
(elim "Ry")
(cases)
(assume "bs" "N" "Cbs" "Mbs")
(use "RealIntro")
(ng #t)
(use "CauchyIntro")
(assume "p" "n" "m")
(ng #t)
(assume "M(PosS p)max N(PosS p)<=n")
(assume "M(PosS p)max N(PosS p)<=m")
(use "RatAbsLeCases2")
(use "RatLePlusCancelR" (pt "as m min bs m"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "~(as m min bs m)+as m min bs m==0"))
(ng #t)
(use "RatLePlusCancelL" (pt "1#2**p"))
(ng #t)
(simprat (pf "(0#2**p*2**p)==0"))
(ng #t)
(simp "RatPlusComm")
(cases (pt "as n<=bs n"))
(assume "Case1")
(use "RatLeTrans" (pt "as m"))
(use "RatMinLB1")
(simp "RatMinCaseL")
(use "RatLeTrans" (pt "as m + (1#2**(PosS p))"))
(auto)
(use "RatLePlusCancelR" (pt "~(1#2**PosS p)"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "(1#2**PosS p)+ ~(1#2**PosS p)==0"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "(1#2**p)+ ~(1#2**PosS p)==(1#2**PosS p)"))
(use "RatLePlusCancelL" (pt "~(as n)"))
(ng #t)
(simprat (pf "~(as n)+as n==0"))
(ng #t)
(simp "RatPlusComm")
(use "RatLeTrans" (pt "abs(as m + ~(as n))"))
(auto)
(use "CauchyElim" (pt "M"))
(use "Cas")
(use "NatLeTrans" (pt "N(PosS p)max M(PosS p)"))
(use "NatMaxUB2")
(auto)
(use "NatLeTrans" (pt "N(PosS p)max M(PosS p)"))
(use "NatMaxUB2")
(auto)
(simprat "<-" "RatPlusHalfExpPosS")
(simp "<-" "RatPlusAssoc")
(simprat (pf "(1#2**PosS p)+ ~(1#2**PosS p)==0"))
(auto)
(assume "case2")
(assert "bs n<as n")
(use "RatNotLeToLt")
(auto)
(assume "case2c")
(use "RatLeTrans" (pt "bs m"))
(use "RatMinLB2")
(simp "RatMinCaseR")
(use "RatLeTrans" (pt "bs m+(1#2**(PosS p))"))
(auto)
(use "RatLePlusCancelR" (pt "~(1#2**PosS p)"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "(1#2**PosS p)+ ~(1#2**PosS p)==0"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "(1#2**p)+ ~(1#2**PosS p)==(1#2**PosS p)"))
(use "RatLePlusCancelL" (pt "~(bs n)"))
(ng #t)
(simprat (pf "~(bs n)+bs n==0"))
(ng #t)
(simp "RatPlusComm")
(use "RatLeTrans" (pt "abs(bs m+ ~(bs n))"))
(auto)
(use "CauchyElim" (pt "N"))
(auto)
(use "NatLeTrans" (pt "N(PosS p)max M(PosS p)"))
(use "NatMaxUB1")
(auto)
(use "NatLeTrans" (pt "N(PosS p)max M(PosS p)"))
(use "NatMaxUB1")
(auto)
(simprat "<-" "RatPlusHalfExpPosS")
(simp "<-" "RatPlusAssoc")
(simprat (pf "(1#2**PosS p)+ ~(1#2**PosS p)==0"))
(auto)
(use "RatLePlusCancelR" (pt "as m min bs m"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "~(as m min bs m)+as m min bs m==0"))
(ng #t)
(simp "RatPlusComm")
(cases (pt "as m<=bs m"))
(assume "case1")
(use "RatLeTrans" (pt "as n"))
(use "RatMinLB1")
(simp "RatMinCaseL")
(use "RatLeTrans" (pt "as n + (1#2**(PosS p))"))
(auto)
(use "RatLePlusCancelR" (pt "~(1#2**PosS p)"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "(1#2**PosS p)+ ~(1#2**PosS p)==0"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "(1#2**p)+ ~(1#2**PosS p)==(1#2**PosS p)"))
(use "RatLePlusCancelL" (pt "~(as m)"))
(ng #t)
(simprat (pf "~(as m)+as m==0"))
(simp "RatPlusComm")
(use "RatLeTrans" (pt "abs(as n + ~(as m))"))
(auto)
(ng #t)
(use "CauchyElim" (pt "M"))
(auto)
(use "NatLeTrans" (pt "N(PosS p)max M(PosS p)"))
(use "NatMaxUB2")
(auto)
(use "NatLeTrans" (pt "N(PosS p)max M(PosS p)"))
(use "NatMaxUB2")
(auto)
(simprat "<-" "RatPlusHalfExpPosS")
(simp "<-" "RatPlusAssoc")
(simprat (pf "(1#2**PosS p)+ ~(1#2**PosS p)==0"))
(auto)
(assume "case2")
(assert "bs m< as m")
(use "RatNotLeToLt")
(auto)
(assume "case2c")
(use "RatLeTrans" (pt "bs n"))
(use "RatMinLB2")
(simp "RatMinCaseR")
(use "RatLeTrans" (pt "bs n + (1#2**(PosS p))"))
(auto)
(use "RatLePlusCancelL" (pt "~(bs m)"))
(simp "RatPlusAssoc")
(simp "RatPlusAssoc")
(simprat (pf "~(bs m)+bs m==0"))
(simp "RatPlusComm")
(use "RatLePlusCancelL" (pt "~(1#2**PosS p)"))
(simp  "RatPlusAssoc")
(simprat (pf "~(1#2**PosS p)+(1#2**PosS p)==0"))
(simp  "RatPlusAssoc")
(simp  "RatPlusAssoc")
(simprat (pf " ~(1#2**PosS p)+0+(1#2**p)==(1#2**PosS p)"))
(ng #t)
(simp "RatPlusComm")
(use "RatLeTrans" (pt "abs(bs n+ ~(bs m))"))
(auto)
(ng #t)
(use "CauchyElim" (pt "N"))
(auto)
(use "NatLeTrans" (pt "N(PosS p)max M(PosS p)"))
(use "NatMaxUB1")
(auto)
(use "NatLeTrans" (pt "N(PosS p)max M(PosS p)"))
(use "NatMaxUB1")
(auto)
(simprat (pf "~(1#2**PosS p)+0== ~(1#2**PosS p)"))
(use "RatEqvPlusCancelL" (pt "(1#2**PosS p)"))
(simp "RatPlusAssoc")
(simprat (pf "(1#2**PosS p)+ ~(1#2**PosS p)==0"))
(simprat "<-" "RatPlusHalfExpPosS")
(auto)
(use "MonIntro")
(assume "p" "q")
(ng #t)
(assume "p<=q")
(ng #t)
(use "NatMaxLUB")
(use "NatLeTrans" (pt "N(PosS q)"))
(use "MonElim")
(auto)
(use "NatMaxUB1")
(use "NatLeTrans" (pt "M(PosS q)"))
(use "MonElim")
(auto)
(use "NatMaxUB2")
(save "RealMinReal")


(set-goal "all x,y( Real x -> Real y -> x min y<<=x)")
(cases)
(assume "as" "M")
(cases)
(assume "bs" "N")
(assume "Ras" "Rbs")
(use "RealLeIntro")
(use "RealMinReal")
(auto)
(use "RealNNegIntro")
(use "RealPlusReal")
(auto)
(use "RealUMinusReal")
(use "RealMinReal")
(auto)
(assume "p")
(ng #t)
(use "RatLeTrans" (pt "as(M(PosS p)max N(PosS(PosS p))max M(PosS(PosS p)))+ ~(as(M(PosS p)max N(PosS(PosS p))max M(PosS(PosS p)))min bs(M(PosS p)max N(PosS(PosS p))max M(PosS(PosS p))))"))
(use "RatLePlusCancelR" (pt "(as(M(PosS p)max N(PosS(PosS p))max M(PosS(PosS p)))min bs(M(PosS p)max N(PosS(PosS p))max M(PosS(PosS p))))"))
(ng #t)
(simp "<-" "RatPlusAssoc")
(simprat (pf "~(as(M(PosS p)max N(PosS(PosS p))max M(PosS(PosS p)))min bs(M(PosS p)max N(PosS(PosS p))max M(PosS(PosS p))))+as(M(PosS p)max N(PosS(PosS p))max M(PosS(PosS p)))min bs(M(PosS p)max N(PosS(PosS p))max M(PosS(PosS p)))==0"))
(ng #t)
(use "RatMinLB1")
(auto)
(save "RealMinLB1")

(set-goal "all x,y( Real x -> Real y -> x min y<<=y)")
(cases)
(assume "as" "M")
(cases)
(assume "bs" "N")
(assume "Ras" "Rbs")
(use "RealLeIntro")
(use "RealMinReal")
(auto)
(use "RealNNegIntro")
(use "RealPlusReal")
(auto)
(use "RealUMinusReal")
(use "RealMinReal")
(auto)
(assume "p")
(ng #t)
(use "RatLeTrans" (pt "bs(N(PosS p)max N(PosS(PosS p))max M(PosS(PosS p)))+ ~(as(N(PosS p)max N(PosS(PosS p))max M(PosS(PosS p)))min bs(N(PosS p)max N(PosS(PosS p))max M(PosS(PosS p))))"))
(use "RatLePlusCancelR" (pt "(as(N(PosS p)max N(PosS(PosS p))max M(PosS(PosS p)))min bs(N(PosS p)max N(PosS(PosS p))max M(PosS(PosS p))))"))
(ng #t)
(simp "<-" "RatPlusAssoc")
(simprat (pf "(~(as(N(PosS p)max N(PosS(PosS p))max M(PosS(PosS p)))min bs(N(PosS p)max N(PosS(PosS p))max M(PosS(PosS p))))+as(N(PosS p)max N(PosS(PosS p))max M(PosS(PosS p)))min bs(N(PosS p)max N(PosS(PosS p))max M(PosS(PosS p))))==0"))
(ng #t)
(use "RatMinLB2")
(auto)
(save "RealMinLB2")

(set-goal "all x,y,z( z <<= x ->  z<<= y ->  z <<= x min y )")
  (cases)
  (assume "as" "M")
  (cases)
  (assume "bs" "N")
  (cases)
  (assume "cs" "L")
  (assume "xLez" "yLez")
  (use "RealLeIntro")
  (realproof)
  (use "RealMinReal")
  (autoreal)
  (use "RealNNegIntro")
  (realproof)
  (assume "q")
  (ng)
  (simp "RatPlusComm")
  (ng #t)
  (use "RatLePlusCancelR" (pt "(cs(N(PosS(PosS q))max M(PosS(PosS q))max L(PosS q)))")) 
  (simp "<-" "RatPlusAssoc")
  (simprat (pf "~(cs(N(PosS(PosS q))max M(PosS(PosS q))max L(PosS q)))+cs(N(PosS(PosS q))max M(PosS(PosS q))max L(PosS q))==0"))
  (ng #t)
  (use "RatLePlusCancelL" (pt "~(1#2**q)"))
  (simp "RatPlusAssoc")
  (simprat (pf "~(1#2**q)+(1#2**q)==0"))
  (ng #t)
  (use "RatMinLB")
  


(set-goal "all k exl p RealLt 0((1#2)**k) p ")
(cases)
(assume "p")
(intro 0 (pt "p"))
(use "Truth")
(intro 0 (pt "One"))
(ng #t)
(use "Truth")
(assume "p")
(intro 0 (pt "One"))
(ng #t)
(use "Truth")
(save "EpsPosBoundEpsIntTwo")



(set-goal "all x (Real x -> ex n x<<= n)")
(cases)
(assume "as" "M")
(assume "Rx")
(inst-with-to "RealBound" "RealBoundInst")
(assert "exl m all n abs(as n)<=2**m")
(use "RealBoundInst" (pt "M"))
(use "RealConstrToCauchy")
(use "Rx")
(assume "ExInst")
(by-assume "ExInst" "n0" "ExInstProp")
(inst-with-to "PosToNatBound" (pt "2**n0") "PosToNatBoundInst")
(by-assume "PosToNatBoundInst" "n1" "PosToNatBoundProp")
(ex-intro "n1")
(use "RealLeTrans" (pt "abs(RealConstr as M)"))
(use "RealLeAbsId")
(use "Rx")
(use "RealLeSToLe")
(realproof)
(use "RealRat")
(use "RealLeSIntro")
(use "RealNNegSIntro")
(ng #t)
(assume "n")
(use "RatLePlusCancelR" (pt "abs(as n)"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "~abs(as n)+abs(as n)==0"))
(ng #t)
(use "RatLeTrans" (pt "(2**n0)#1"))
(use "ExInstProp")
(use "PosToNatBoundProp")
(ng #t)
(use "Truth")
(save "RealNatBound")


; (set-goal "all x,y,p (Real x -> RealNNeg y-> RealPos (x*y) p  -> exl p0 (RealPos x p0))")
; (assume "x" "y" "p")
; (assume "Rx" "ynneg" "Rp")
; (ng)
; (inst-with-to "RealPosChar1RealConstrFree" (pt "x*y") "Inst")
; (inst-with-to "RealNNegCharOneExFreeConstrFree" (pt "y") "Inst2")
; (intro 0 (pt "PosS(PosS(PosS(p)))"))
; (use "RealPosChar2RealConstrFree" (pt "Zero"))
; (autoreal)
; (assume "n" "cond")
; (use "")



(set-goal "all x,p(Real x -> RealPos x p -> (1#2**PosS p)<<=x)")
(cases)
(assume "as" "M" "p" "Rx" "0<x")
(use "RealLeChar2RealConstrFree")
(autoreal)
(assume "q")
(ng #t)
(intro 0 (pt "M(PosS p)"))
(assume "n" "Mp+1<=n")
(use "RatLeTrans" (pt "as n"))
(use "RealPosChar1" (pt "M"))
(use "Rx")
(use "0<x")
(use "Mp+1<=n")
(use "Truth")
(save "RealPosToLe")

(set-goal "all x,y,p(Real x -> Real y -> RealLt x y p -> (1#2**PosS p)<<=y + ~x)")
(assume "x" "y" "p")
(assume "Rx" "Ry" "<")
(use "RealPosToLe")
(autoreal)
(use "RealLtElim")
(auto)
(save "RealLtToEpsLe")

(set-goal "all x,p(Real x  -> (1#2**p)<<=x -> RealPos x (PosS(PosS p)))")
(assume "x" "p" "Rx" "cond")
(inst-with-to "RealLeCharOneRealConstrFree" (pt "ReaRat(1#2**p)") (pt "x") "Inst")
(ng "Inst")
(cut "all p0 exl n all n0(n<=n0 -> (1#2**p)<=x seq n0+(1#2**p0))")
(assume "cutInst")
(inst-with-to "cutInst" (pt "PosS p") "cutInstSpec")
(by-assume "cutInstSpec" "n0" "cutInstSpecProp")
(use "RealPosChar2RealConstrFree" (pt "n0"))
(auto)
(assume "n" "n0")
(simprat (pf "(1#2**PosS p)==(1#2**p)+ ~(1#2**PosS p)"))
(use "RatLePlusCancelR" (pt "(1#2**PosS p)"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "(~(1#2**PosS p)+(1#2**PosS p))==0"))
(use "cutInstSpecProp")
(auto)
(use "RatEqvPlusCancelR" (pt "(1#2**PosS p)"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "~(1#2**PosS p)+(1#2**PosS p)==0"))
(simprat (pf "(1#2**p)+0==(1#2**p)"))
(use "RatPlusHalfExpPosS")
(auto)
(use "Inst")
(use "cond")
(save "RealEpsLeToRealPos")


(set-goal "all x,y,p(Real x -> Real y ->  (1#2**p)<<=y + ~x ->  RealLt x y (PosS(PosS p)))")
(assume "x" "y" "p")
(assume "Rx" "Ry" "<")
(use "RealLtIntro")
(use "RealEpsLeToRealPos")
(autoreal)
(auto)
(save "RealEpsLeToRealLt")



(set-goal "all x,y,p( Real x -> Real y -> RealLt x y p -> ex a (exl p RealLt x a p andi exl p RealLt a y p))")
(cases)
(assume "as" "M")
(cases)
(assume "bs" "N")
(assume "p")
(assume "Rx" "Ry" "Rlt")
(ex-intro (pt "as (M (PosS(PosS(PosS(PosS p))))) + (1#2**(PosS(PosS(PosS p))))"))
(split)
(intro 0 (pt "(PosS(PosS(PosS((PosS(PosS p))))))"))
(use "RealLtIntro")
(use "RealPosChar2RealConstrFree" (pt "M (PosS(PosS(PosS(PosS p))))"))
(autoreal)
(assume "n" "cond")
(ng #t)
(simp "RatPlusComm")
(use "RatLePlusCancelR" (pt "~(1#2**(PosS(PosS(PosS p))))"))
(simp "<-" "RatPlusAssoc")
(simp "<-" "RatPlusAssoc")
(simprat (pf "(1#2**PosS(PosS(PosS p)))+ ~(1#2**PosS(PosS(PosS p)))==0"))
(simprat (pf "(1#2**PosS(PosS(PosS(PosS p))))+ ~(1#2**PosS(PosS(PosS p)))== ~(1#2**PosS(PosS(PosS(PosS p))))"))
(use "RatLeUMinusToLeSwitch")
(ng #t)
(use "RatLeTrans" (pt "abs(as n+ ~(as(M(PosS(PosS(PosS(PosS p)))))))"))
(auto)
(use "CauchyElim" (pt "M"))
(use "RealConstrToCauchy")
(auto)
(use "RatEqvPlusCancelR" (pt "(1#2**PosS(PosS(PosS(PosS p))))"))
(simprat (pf "~(1#2**PosS(PosS(PosS(PosS p))))+(1#2**PosS(PosS(PosS(PosS p))))==0"))
(simp "RatPlusComm")
(simp "RatPlusAssoc")
(simprat (pf "(1#2**PosS(PosS(PosS(PosS p))))+(1#2**PosS(PosS(PosS(PosS p))))==(1#2**PosS(PosS(PosS p)))"))
(auto)
(use "RatPlusHalfExpPosS")
(auto)
(intro 0 (pt "PosS((PosS(PosS(PosS p))))"))
(use "RealLtIntro")
(use "RealPosChar2RealConstrFree" (pt "( M(PosS(PosS(PosS p))) max N (PosS(PosS p)))"))
(realproof)
(ng #t)
(assume "n" "cond")
(assert "RealPos(RealConstr bs N+ ~(RealConstr as M))p")
(use "RealLtElim")
(auto)
(assume "Rpos")
(inst-with-to "RealPosChar1" (pt "(RealConstr bs N+ ~(RealConstr as M))seq") (pt "(RealConstr bs N+ ~(RealConstr as M))mod") (pt "p") "RPosChar")
(use "RatLePlusCancelR" (pt "(1#2**PosS(PosS(PosS p)))"))
(simprat (pf "(1#2**PosS(PosS(PosS p)))+(1#2**PosS(PosS(PosS p)))==(1#2**PosS(PosS p))"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "(IntN 1#2**PosS(PosS(PosS p)))+(1#2**PosS(PosS(PosS p)))==0"))
(use "RatLeTrans" (pt "bs n+ ~(as(M(PosS(PosS(PosS(PosS p))))))"))
(simprat (pf "(1#2**PosS(PosS p))==(1#2**(PosS p)) + ~((1#2**PosS(PosS p)))"))
(use "RatLeTrans" (pt "bs n+ ~(as n) +  ~(as(M(PosS(PosS(PosS(PosS p)))))) + as n"))
(simp "<-" "RatPlusAssoc")
(use "RatLeMonPlus")
(use "RPosChar")
(use "RealEqSModEqReal" (pt "RealConstr bs N + ~(RealConstr as M)"))
(autoreal)
(use "RealEqSIntro")
(auto)
(ng #t)
(use "NatLeTrans" (pt "M(PosS(PosS(PosS p)))max N(PosS(PosS p))"))
(use "NatMaxLUB")
(use "NatMaxUB2")
(use "NatLeTrans" (pt "M(PosS(PosS(PosS p)))"))
(use "MonElim")
(use "RealConstrToMon" (pt "as"))
(auto)
(use "NatMaxUB1")
(auto)
(use "RatLeUMinusToLeSwitch")
(ng #t)
(use "RatLeTrans" (pt "abs(as(M(PosS(PosS(PosS(PosS p)))))+ ~(as n))"))
(auto)
(use "CauchyElim" (pt "M"))
(use "RealConstrToCauchy")
(auto)
(use "MonElim")
(use "RealConstrToMon" (pt "as"))
(auto)
(use "PosLeTrans" (pt "PosS(PosS(PosS p))"))
(auto)
(use "NatLeTrans" (pt "M(PosS(PosS(PosS p)))max N(PosS(PosS p))"))
(use "NatLeTrans" (pt "M(PosS(PosS(PosS p)))"))
(use "MonElim")
(use "RealConstrToMon" (pt "as"))
(auto)
(use "NatMaxUB1")
(auto)
(use "RatLePlusCancelL" (pt "~(bs n)"))
(simp "RatPlusAssoc")
(simp "RatPlusAssoc")
(simp "RatPlusAssoc")
(simp "RatPlusAssoc")
(simprat (pf "~(bs n)+bs n==0"))
(ng #t)
(simp "RatPlusComm")
(simp "RatPlusAssoc")
(simprat (pf "as n+ ~(as n)==0"))
(auto)
(use "RatEqvPlusCancelR" (pt " (1#2**PosS(PosS p)) "))
(simp "<-" "RatPlusAssoc")
(simprat (pf "~(1#2**PosS(PosS p))+(1#2**PosS(PosS p))==0"))
(simprat (pf "(1#2**PosS p)+0==(1#2**PosS p)")) 
(use "RatPlusHalfExpPosS")
(auto)
(use "RatPlusHalfExpPosS")
(save "RealLtMidPoint")
;; coq: CRlt_Qmid

(set-goal "all x,a,p (Real x -> (1#2**p)<=a -> x<<= x seq (x mod p) + a)")
(assume "x" "a" "p")
(assume "RasM")
(assume "cond")
(use "RealLeChar2RealConstrFree")
(autoreal)
(assume "p0")
(ng #t)
(intro 0 (pt "x mod p"))
(assume "n" "xmodc")
(use "RatLePlusCancelL" (pt "~(x seq(x mod p))"))
(simp "RatPlusAssoc")
(simp "RatPlusAssoc")
(simprat (pf "~(x seq(x mod p))+(x seq(x mod p))==0"))
(ng #t)
(use "RatLeTrans" (pt "a"))
(use "RatLeTrans" (pt "(1#2**p)"))
(simp "RatPlusComm")
(use "RatLeTrans" (pt "abs(x seq n+ ~(x seq(x mod p)))"))
(auto)
(use "CauchyElim" (pt "x mod"))
(use "RealToCauchy")
(autoreal)
(auto)
(save "RealApproxUp")

(set-goal "all x,a,p (Real x -> (1#2**p)<=a -> x seq (x mod p) + ~a <<= x )")
(assume "x" "a" "p")
(assume "RasM")
(assume "cond")
(use "RealLeUMinusInv")
(ng #t)
(inst-with-to "RealApproxUp" (pt "~x") "Inst")
(ng "Inst")
(use "RealLeTrans" (pt "ReaRat ((~x)seq((~x)mod p)+a)"))
(use "Inst")
(autoreal)
(auto)
(ng #t)
(use "RealLeReflNC")
(use "RealEqSToEq")
(autoreal)
(use "RealEqSIntro")
(ng #t)
(assume "n")
(assert "all x (~x)seq((~x)mod p)== ~(x seq(x mod p))")
(cases)
(assume "as" "M")
(ng #t)
(auto)
(save "RealApproxLow")

(set-goal "all a,b(a<b oru b<=a)")
(assume "a" "b")
(cases (pt "a<b"))
(assume "Case1")
(intro 0)
(auto)
(assume "Case2")
(intro 1)
(use "RatNotLtToLe")
(auto)
(save "QLtLeCases")




(set-goal "all x,y,z,p(Real x -> Real y -> Real z -> RealLt x z p -> exl p RealLt x y p ori exl p RealLt y z p)")
(assume "x" "y" "z" "p")
(assume "Rx" "Ry" "Rz")
(assume "RealLtProp")
(inst-with-to "RealLtMidPoint" (pt "x") (pt "z") "Inst")
(assert "ex a(exl p0 RealLt x a p0 andd exl p0 RealLt a z p0)")
(use "Inst" (pt "p"))
(auto)
(assume "InstEx")
(by-assume  "InstEx" "a1" "ExInstProp")
(cut "exl p RealLt x a1 p")
(assume "x<a1")
(cut "exl p RealLt a1 z p")
(assume "a1<z")
(inst-with-to "RealLtMidPoint" (pt "ReaRat a1") (pt "z") "Inst2")
(by-assume "a1<z" "p0" "a1<z_wit")
(assert "ex a(exl p0 RealLt(ReaRat a1)a p0 andd exl p0 RealLt a z p0)")
(use "Inst2" (pt "p0"))
(ng #t)
(autoreal)
(auto)
(assume "InstEx2")
(by-assume "InstEx2" "a2" "InstEx2Prop")
(assert "0<(1#2)*(a2-a1)")
(use "RatLeLtTrans" (pt "(1#2)*0"))
(auto)
(use "RatLtTimesCancelL" (pt "2#1"))
(auto)
(ng #t)
(assert "exl p RealLt(ReaRat a1)a2 p")
(use "InstEx2Prop")
(assume "IntExAux")
(by-assume "IntExAux" "p6" "InstExAuxProp")
(ng "InstExAuxProp")
(use "RatLtLeTrans" (pt "(1#2**p6)"))
(auto)
(assume "threshold")
(inst-with-to "RatLeftPosBound" (pt "(1#2)*(a2-a1)") "thresholdtoeps")
(cut "exl q (1#2**q)<=(1#2)*(a2-a1)")
(assume "thresholdtoepsmod")
(by-assume "thresholdtoepsmod" "r"  "thresholdtoepsmodprop")
(inst-with-to "QLtLeCases" (pt "y seq(y mod r)") (pt "(1#2)*(a2+a1)") "QltLeEl" )
(elim "QltLeEl")
(assume "Case1")
(intro 1)
(assert "exl p RealLt a2 z p")
(use "InstEx2Prop")
(assume "a2<z")
(by-assume "a2<z" "q1" "a2<z_wit")
(intro 0 (pt "PosS(PosS(PosS q1))"))
(use "RealLeLtTrans" (pt "ReaRat a2"))
(realproof)
(ng #t)
(realproof)
(autoreal)
(ng #t)
(use "RealLeTrans" (pt "ReaRat(y seq(y mod r) + (1#2)*(a2-a1))"))
(use "RealApproxUp")
(autoreal)
(use "thresholdtoepsmodprop")
(ng #t)
(use "RatLeToRealLe")
(use "RatLeTrans" (pt "(1#2)*(a2+a1) + (1#2)*(a2+ ~a1)"))
(use "RatLeMonPlus")
(use "RatLtToLe")
(auto)
(simprat "RatTimesPlusDistr")
(simprat "RatTimesPlusDistr")
(ng #t)
(use "RatLePlusCancelL" (pt "~(1#2)*a2"))
(ng #t)
(simprat (pf "~((1#2)*a2)+(1#2)*a2==0"))
(ng #t)
(simp "RatPlusComm")
(ng #t)
(simprat (pf "~((1#2)*a1)+(1#2)*a1==0"))
(ng #t)
(use "RatLePlusCancelL" (pt "(1#2)*a2"))
(ng #t)
(simprat (pf "(1#2)*a2+ ~((1#2)*a2)==0"))
(ng #t)
(simprat "<-" "RatTimesPlusDistr")
(simprat (pf "a2+a2==2*a2"))
(ng #t)
(auto)
(use "RatPlusIdEqvTimesTwo")
(auto)
(assume "Case2")
(intro 0)
(by-assume "x<a1" "q1" "x<a1_wit")
(intro 0 (pt "PosS(PosS(PosS(q1)))"))
(use "RealLtLeTrans" (pt "ReaRat a1"))
(auto)
(ng #t)
(realproof)
(realproof)
(ng #t)
(use "RealLeTrans" (pt "ReaRat(y seq(y mod r) + ~((1#2)*(a2-a1)))"))
(ng #t)
(use "RatLeToRealLe")
(use "RatLeTrans" (pt "(1#2)*(a2+a1) + ~ ((1#2)*(a2+ ~a1))"))
(ng #t)
(simprat "RatTimesPlusDistr")
(simprat "RatTimesPlusDistr")
(ng #t)
(use "RatLeTrans" (pt "(1#2)*a2+ ~((1#2)*a2)+(1#2)*a1+(1#2)*a1"))
(simprat (pf "(1#2)*a2+ ~((1#2)*a2)==0"))
(ng #t)
(simprat (pf "(1#2)*a1+(1#2)*a1==2*(1#2)*a1"))
(auto)
(inst-with-to "RatPlusIdEqvTimesTwo" (pt "(1#2)*a1") "RatInst")
(use "RatInst")
(auto)
(ng #t)
(use "RatLePlusCancelL" (pt "~(1#2)*a2"))
(ng #t)
(simprat (pf "~((1#2)*a2)+(1#2)*a2==0"))
(ng #t)
(simp "RatPlusComm")
(auto)
(use "RealApproxLow")
(auto)
(use "ExInstProp")
(use "ExInstProp")
(save "ApproxSplitLt")


(set-goal "all x,y,z (Real x -> Real y ->Real z -> exl p RealLt 0 z p  -> exl p RealLt x y p -> exl p RealLt (x*z) (y*z) p)")
(assume "x" "y" "z" "Rx" "Ry" "Rz")
(assume "0<z" "x<y")
(assert "exl p RealLt 0 (y+ ~x) p")
(by-assume "x<y" "p0" "ExI")
(intro 0 (pt "PosS(PosS p0)"))
(use "RealLtIntro")
(use "RealPosCompatRealConstrFree" (pt "y+ ~x"))
(simpreal "<-" "RealPlusAssoc")
(use "RealPlusCompat")
(use "RealEqRefl")
(autoreal)
(ng #t)
(use "RealEqSym")
(use "RealPlusZero")
(autoreal)
(use "RealLtElim")
(auto)
(assume "Assertion1")
(inst-with-to "RealLtTimesMon"  (pt "(y+ ~x)") (pt "z") "Inst")
(by-assume "0<z" "p0" "Ex0")
(by-assume "Assertion1" "p1" "Ex1")
(intro 0 (pt "PosS(PosS(PosS(PosS(PosS(PosS(p1+p0))))))"))
(use "RealLtIntro")
(use "RealLtToRealPos")
(use "RealLtCompatRealConstrFree" (pt "ReaRat 0") (pt "(y+ ~x)*z"))
(ng #t)
(use "RealEqRefl")
(autoreal)
(simpreal "RealTimesPlusDistrLeft")
(ng #t)
(use "RealPlusCompat")
(use "RealEqRefl")
(autoreal)
(simpreal "RealTimesUMinusId")
(use "RealEqRefl")
(autoreal)
(use "Inst")
(autoreal)
(auto)
(save "RealLtMonTimes")


(set-goal "all as,M (Real(RealConstr as M) -> all n abs(as n)<= 2**cNatPos(RealBd as M))")
(assume "as" "M" "RasM")
(assume "n")
(assert "PosToNat(cNatPos(RealBd as M))=RealBd as M")
(simp "NatPosExFree")
(use "PosToNatToPosId")
(use "Truth")
(assume "EqHyp")
(simp "EqHyp")
(use "RealBdProp")
(use "RealConstrToCauchy")
(use "RasM")
(save "RealBdPropCNat")


(set-goal "all x,q(Real x -> RealPos  x q -> exl p RealPos (RealUDiv x q) p)")
(cases)
(assume "as" "M")
(assume "q")
(assume "RasM")
(assume "Rpos")
(inst-with-to "RealPosChar1" (pt "as") (pt "M") (pt "q") "Rposchar")
(intro 0 (pt "PosS(cNatPos(RealBd (as) (M)))"))
(simp "RealUDiv0CompRule")
(use "RealPosChar2" (pt "M(PosS q)"))
(simp "<-" "RealUDiv0CompRule")
(use "RealUDivReal")
(autoreal)
(use "RealPosAbs")
(use "Rpos")
(assume "n" "Mcond")
(simprat (pf "([n0]RatUDiv(as n0))n == (RatUDiv (as n))*1 ") )
(simprat (pf "1== (as n)*(RatUDiv (as n)) "))
(simp "RatTimesAssoc")
(use "RatLeTimesCancelR" (pt "as n"))
(use "RatLtLeTrans" (pt "(1#2**PosS q)"))
(auto)
(simp "<-" "RatTimesAssoc")
(simprat (pf "RatUDiv(as n)*as n==1"))
(simprat (pf "RatTimes 1 1==1"))
(use "RatLeTrans" (pt "(1#2**cNatPos(RealBd as M))*2**(cNatPos(RealBd as M))"))
(use "RatLeMonTimesTwo")
(auto)
(use "RatLeTrans" (pt "(1#2**PosS q)"))
(auto)
(use "RatLeTrans" (pt "abs(as n)"))
(auto)
(use "RealBdPropCNat")
(auto)
(use "RatUDivIdEqOne")
(use "RatLtLeTrans" (pt "(1#2**PosS q)"))
(auto)
(use "RatLeTrans" (pt "as n"))
(auto)
(simp "RatTimesComm")
(use "RatEqvSym")
(use "RatUDivIdEqOne")
(use "RatLtLeTrans" (pt "(1#2**PosS q)"))
(auto)
(use "RatLeTrans" (pt "as n"))
(auto)
(save "RealPosToRealPosUDiv")

(set-goal "all x,p(Real x -> RealPos abs(x) p -> (RealUDiv x p)*x===1)")
(cases)
(assume "as" "M" "p" "Rx" "Rp")
(inst-with-to "RealPosChar1RealConstrFree" (pt "abs(RealConstr as M)") (pt "p") "RealInst")
(use "RealEqChar2RealConstrFreev2")
(use "RealTimesReal")
(use "RealUDivReal")
(autoreal)
(auto)
(autoreal)
(assume "p0")
(intro 0 (pt "(abs(RealConstr as M))mod(PosS p)"))
(assume "n" "m")
(assume "cond1" "cond2")
(ng #t)
(simprat (pf "RatUDiv(as n)*as n==1"))
(auto)
(use "RatUDivIdEqOne")
(use "RatLtLeTrans" (pt "(1#2**PosS p)"))
(auto)
(use "RealInst")
(autoreal)
(use "Rp")
(auto)
(save "RealUDivIdEqOne")



(set-goal "all x,y,z (Real x -> Real y ->Real z -> exl p RealLt 0 z p  -> exl p RealLt (x*z) (y*z) p  -> exl p RealLt x y p)")
(assume "x" "y" "z" "Rx" "Ry" "Rz" "0<z" "xzLt")
(by-assume "0<z" "p0" "PosZ")
(by-assume "xzLt" "p1" "PosxzLt")
(inst-with-to "RealUDivIdEqOne" (pt "z") "Inst")
(inst-with-to "RealLtMonTimes" (pt "x*z") (pt "y*z") (pt "(RealUDiv z (PosS p0))") "Main")
(assert "Real(RealUDiv z(PosS p0))")
(use "RealUDivReal")
(auto)
(use "RealPosAbs")
(use "RealLtToRealPos")
(auto)
(assume "RealDivz")
(assert "exl p RealLt(x*z*RealUDiv z(PosS p0))(y*z*RealUDiv z(PosS p0))p")
(use "Main")
(use "RealTimesReal")
(realproof)
(realproof)
(use "RealTimesReal")
(realproof)
(realproof)
(auto)
(inst-with-to "RealPosToRealPosUDiv" (pt "z") (pt "PosS p0") "RPosDiv")
(assert "exl p RealPos(RealUDiv z(PosS p0))p")
(use "RPosDiv")
(auto)
(use "RealLtToRealPos")
(auto)
(assume "RrPosPos")
(by-assume "RrPosPos" "p2" "RRProp")
(intro 0 (pt "PosS(PosS p2)"))
(use "RealPosLtCompat")
(auto)
(assume "ExInst1Main")
(by-assume "ExInst1Main" "p3" "ExInst1MainProp")
(intro 0 (pt "PosS(PosS p3)"))
(use "RealLtCompatRealConstrFree" (pt "x*z*RealUDiv z(PosS p0)") (pt "y*z*RealUDiv z(PosS p0)"))
(use "RealEqTrans" (pt "x*1"))
(simpreal "<-" "RealTimesAssoc")
(use "RealTimesCompat")
(use "RealEqRefl")
(autoreal)
(simpreal "RealTimesComm")
(use "Inst")
(autoreal)
(use "RealPosAbs")
(use "RealLtToRealPos")
(auto)
(use "RealTimesOne")
(auto)
(use "RealEqTrans" (pt "y*1"))
(simpreal "<-" "RealTimesAssoc")
(use "RealTimesCompat")
(use "RealEqRefl")
(autoreal)
(simpreal "RealTimesComm")
(use "Inst")
(auto)
(use "RealPosAbs")
(use "RealLtToRealPos")
(auto)
(use "RealTimesOne")
(auto)
(save "RealLtTimesMonRev")




(set-goal "all x,y (Real x -> 0<<=y -> exl p RealLt 0 (x*y) p -> exl p RealLt 0 x p)")
(assume "x" "y" "Rx" "0<=y" "0<x*y")
(assert "exl p RealLt 0 1 p")
(intro 0 (pt "One"))
(ng #t)
(use "Truth")
(assume "Assertion1")
(inst-with-to "ApproxSplitLt" (pt "ReaRat 0") (pt "x") (pt "ReaRat 1") "ApproxS")
(assert "exl p0 RealLt(ReaRat 0)x p0 ord exl p0 RealLt x(ReaRat 1)p0")
(by-assume "Assertion1" "p1" "Assertion1Prop")
(use "ApproxS" (pt "p1"))
(ng #t)
(realproof)
(realproof)
(ng #t)
(realproof)
(use "Assertion1Prop")
(elim)
(assume "Ex1")
(by-assume "Ex1" "p2" "Ex1Prop")
(intro 0 (pt "p2"))
(use "Ex1Prop")
(assume "Exl2")
(assert "x<<=1")
(by-assume "Exl2" "p2" "Exl2Prop")
(use "RealLtToLe" (pt "p2")) 
(autoreal)
(use "Exl2Prop")
(assume "x<<=1")
(assert "x*y<<=y")
(use "RealLeTrans" (pt "1*y"))
(use "RealLeMonTimesL")
(use "RealLeToRealNNeg")
(use "0<=y")
(use "x<<=1")
(use "RealLeReflNC")
(use "RealEqSym")
(simpreal "RealTimesComm")
(simpreal "RealTimesOne")
(use "RealEqRefl")
(autoreal)
(assume "Assertion2")
(assert "exl p RealLt 0 y p")
(by-assume "0<x*y" "p0" "PosP")
(intro 0 (pt "PosS(PosS(PosS(p0)))"))
(use "RealLtLeTrans" (pt "x*y"))
(autoreal)
(use "Assertion2")
(use "PosP")
(assume "Assertion3")
(assert "0===0*y")
(simpreal "RealTimesComm")
(simpreal "RealTimesZero")
(use "RealEqRefl")
(autoreal)
(assume "Assertion4")
(assert "exl p RealLt (0*y) (x*y) p")
(by-assume  "0<x*y" "p0" "PosP")
(intro 0 (pt "PosS(PosS p0)"))
(use "RealLtCompatRealConstrFree" (pt "ReaRat 0") (pt "x*y"))
(use "Assertion4")
(use "RealEqRefl")
(autoreal)
(use "PosP")
(assume "Assertion5")
(use "RealLtTimesMonRev" (pt "y"))
(autoreal)
(use "Assertion3")
(use "Assertion5")
(save "RealLtZeroWeaken")
;; coq:CRMult_lt_0_weaken


(add-program-constant "RealApart" (py "rea=>rea=>pos=>boole"))

(add-computation-rules
 "RealApart(RealConstr as M)(RealConstr bs N)p"
 "RealPos abs(RealConstr bs N-RealConstr as M) p")



(set-goal "all x,y,p (RealApart x y p -> RealLt x y p oru RealLt y x p)")
(cases)
(assume "as" "M")
(cases)
(assume "bs" "N")
(assume "p")
(ng #t)
(ng #t)
(simp "RatAbsMax")
(assume "Rapart")
(inst-with-to "RatMaxLeToOrRev" (pt "(1#2**p)") (pt "(bs(N(PosS(PosS p))max M(PosS(PosS p)))+ ~(as(N(PosS(PosS p))max M(PosS(PosS p)))))") (pt "~(bs(N(PosS(PosS p))max M(PosS(PosS p)))+ ~(as(N(PosS(PosS p))max M(PosS(PosS p)))))") "Inst")
(assert "(1#2**p)<=
       bs(N(PosS(PosS p))max M(PosS(PosS p)))+ 
       ~(as(N(PosS(PosS p))max M(PosS(PosS p)))) oru 
       (1#2**p)<= 
       ~(bs(N(PosS(PosS p))max M(PosS(PosS p)))+ 
         ~(as(N(PosS(PosS p))max M(PosS(PosS p)))))")
(auto)
(elim)
(assume "case")
(intro 0)
(auto)
(assume "case")
(intro 1)
(use "RatLeTrans" (pt "~(bs(N(PosS(PosS p))max M(PosS(PosS p)))+ 
         ~(as(N(PosS(PosS p))max M(PosS(PosS p)))))"))
(auto)
(simp "RatPlusUMinDistr")
(ng #t)
(simp "RatPlusComm")
(simp (pf "N(PosS(PosS p))max M(PosS(PosS p)) =  M(PosS(PosS p)) max N(PosS(PosS p))"))
(auto)
(use "NatMaxComm")
(save "RealApartToLtOru")



(set-goal "all x,y,p ( RealLt x y p oru RealLt y x p -> RealApart x y p)")
(cases) 
(assume "as" "M")
(cases)
(assume "bs" "N")
(assume "p")
(elim)
(assume "case")
(ng)
(use "RatLeTrans" (pt "bs(N(PosS(PosS p))max M(PosS(PosS p)))+ 
       ~(as(N(PosS(PosS p))max M(PosS(PosS p))))"))
(auto)
(assume "case")
(ng)
(simprat "RatAbsPlusMinusComm")
(simp (pf "N(PosS(PosS p))max M(PosS(PosS p))=M(PosS(PosS p))max N(PosS(PosS p))"))
(use "RatLeTrans" (pt "as(M(PosS(PosS p))max N(PosS(PosS p)))+ 
       ~(bs(M(PosS(PosS p))max N(PosS(PosS p))))"))
(auto)
(use "NatMaxComm")
(save "RealLtOruToRealApart")

(set-goal "all x,y (Real x -> Real y -> (exl p RealApart x y p -> F) -> x===y)")
(assume "x" "y" )
(assume "Rx" "Ry" "RapartF")
(use "RealLeAntiSym")
(use "NotGtIsLt")
(auto)
(assume "ExInst")
(use "RapartF")
(by-assume "ExInst" "p0" "Inst")
(intro 0 (pt "p0"))
(use "RealLtOruToRealApart")
(intro 1)
(auto)
(use "NotGtIsLt")
(auto)
(assume "ExInst")
(by-assume "ExInst" "p0" "Inst")
(use "RapartF")
(intro 0 (pt "p0"))
(use "RealLtOruToRealApart")
(intro 0)
(use "Inst")
(save "RealNotApartToRealEq")


(add-program-constant "RegularFunction" (py "rea=>rat=>rat"))
(add-computation-rule "RegularFunction x a" "[if (0<a) (x seq (x mod (cRatLeftPosBound a))) (Inhab rat) ]")

(set-totality-goal "RegularFunction")
(use "AllTotalElim")
(assume "x")
(use "AllTotalElim")
(assume "a")
(use "RatTotalVar")
(save-totality)


(add-application (pt "RegularFunction"))

(add-var-name "eps" (py "rat"))

(deanimate "RatLeftPosBound")

(set-goal "all x,eps1,eps2 ( 0< eps1 -> 0<eps2 -> Real x -> abs( (x eps1) - (x eps2))<= eps1 + eps2 )")
(assume "x" "eps1" "eps2")
(assume "ep1" "ep2" "Rx")
(use "RealLeToRatLe")
(simp "RatMinus0CompRule")
(inst-with-to "RealLeAbsInvTriangleInj" (pt "ReaRat (x eps1)") (pt "ReaRat (x eps2)") (pt "x") (pt "ReaRat(eps1 + eps2)") "RInst")
(use "RInst")
(ng #t)
(realproof)
(ng #t)
(realproof)
(realproof)
(simp "ReaRat0CompRule")
(simp "ReaRat0CompRule")
(simp "ReaRat0CompRule")
(use "RealLeTrans" (pt "ReaRat eps1 + ReaRat eps2"))
(use "RealLeMonPlus")
(simp "ReaRat0CompRule")
(use "RealLeTrans" (pt "ReaRat (1#2**cRatLeftPosBound eps1)"))
(simp "RegularFunction0CompRule")
(simp "ep1")
(ng #t)
(inst-with-to "RealApproxExFree" (pt "x") (pt "cRatLeftPosBound eps1") "RApproxInst1")
(use "RApproxInst1")
(auto)
(ng #t)
(use "RatLeToRealLe")
(use "RatLeftPosBoundCorr")
(auto)
(simp "ReaRat0CompRule")
(simpreal "RealAbsUMinusPlusComm")
(simp "ep2")
(ng #t)
(use "RealLeTrans" (pt "ReaRat (1#2**cRatLeftPosBound eps2)"))
(ng #t)
(use "RealApproxExFree")
(auto)
(ng #t)
(use "RatLeToRealLe")
(use "RatLeftPosBoundCorr")
(auto)
(realproof)
(realproof)
(ng #t)
(use "RatLeToRealLe")
(auto)
(save "RegularFunctionCorr")

(add-ids
 (list (list "DecrAlternating" (make-arity (py "nat=>rat"))))
 '("all as( all n (abs(as (Succ n))<= abs(as n)) -> all n ((as (Succ n))*(as n)<=0) -> DecrAlternating as)" "DecrAlternatingIntro"))



(set-goal "all as(DecrAlternating as -> all n (abs(as (Succ n))<=abs(as n) & (as (Succ n))*(as n)<=0 ))")
(assume "as")
(elim)
(assume "as0" "cond1" "cond2")
(assume "n0")
(split)
(auto)
(save "DecrAlternatingElimAll")

(set-goal "all as,n (DecrAlternating as -> 0<= (as n)*(as (Succ(Succ n))) )")
(assume "as" "n")
(elim)
(assert "all a,b,c (abs(b)<=abs(a) -> abs(c)<=abs(b) ->  a*b<=0 -> b*c<=0 -> 0<=a*c )")
(cases)
(cases)
(assume "p")
(assume "p0")
(cases)
(cases)
(assume "p1")
(assume "p2")
(cases)
(cases)
(assume "p3")
(assume "p4")
(ng #t)
(auto)
(assume "p1")
(cases)
(cases)
(assume "p2" "p3")
(ng #t)
(auto)
(assume "p2" "p3")
(cases)
(cases)
(assume "p1" "p4")
(ng #t)
(auto)
(assume "p")
(cases)
(cases)
(assume "p0")
(assume "p1")
(cases)
(cases)
(assume "p2" "p3")
(ng #t)
(auto)
(assume "p0")
(cases)
(cases)
(assume "p1" "p2")
(ng #t)
(auto)
(assume "p0" "p1")
(cases)
(cases)
(assume "p2" "p3")
(ng #t)
(auto)
(assume "p" "p0")
(cases)
(cases)
(assume "p1" "p2")
(cases)
(cases)
(assume "p3" "p4")
(ng #t)
(auto)
(assume "p1")
(cases)
(cases)
(ng #t)
(auto)
(assume "p1" "p2")
(cases)
(cases)
(assume "p3" "p4")
(ng #t)
(auto)
(assume "Assertion")
(assume "as0" "cond1" "cond2")
(use "Assertion" (pt "as0 (Succ n)"))
(use "cond1")
(auto)
(simp "RatTimesComm")
(auto)
(simp "RatTimesComm")
(auto)
(save "DecrAlternatingEvenNNeg")


(set-goal "all x,y(x<+=y -> all n (x seq n<=y seq n))")
(cases)
(assume "as" "M")
(cases)
(assume "bs" "N")
(assume "Cond")
(ng #t)
(inst-with-to "RealNNegSElim" (pt "RealConstr bs N + ~(RealConstr as M)") "Inst")
(assume "n")
(use "RatLePlusCancelR" (pt "~(as n)"))
(simprat (pf "as n+ ~(as n)==0"))
(use "Inst")
(use "RealLeSElim")
(auto)
(save "RealLeSElim1")

(set-goal "all x,y( all n (x seq n<=y seq n) -> x<+=y)")
(cases)
(assume "as" "M")
(cases)
(assume "bs" "N")
(assume "Cond")
(use "RealLeSIntro")
(use "RealNNegSIntro")
(assume "n")
(ng #t)
(use "RatLePlusCancelR" (pt "as n"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "~(as n)+as n==0"))
(use "Cond")
(auto)
(save "RealLeSIntro1")

(set-goal "all x,y,z (x<+=y -> y<+=z -> x<+=z)")
(assume "x" "y" "z")
(assume "x<=y")
(assume "y<=z")
(use "RealLeSIntro1")
(assume "n")
(use "RatLeTrans" (pt "y seq n"))
(use "RealLeSElim1")
(auto)
(use "RealLeSElim1")
(auto)
(save "RealLeSTrans")

(set-goal "all x,y (x=+=y -> x<+=y)")
(assume "x" "y")
(elim)
(assume "x0" "y0" "cond")
(use "RealLeSIntro1")
(assume "n")
(simprat "cond")
(auto)
(save "RealLeSRefl")



(set-goal "all x,y(Real x -> Real y -> all p ( abs(x+ ~y) <<=(1#2**p)) -> x===y)")
(assume "x" "y" "Rx" "Ry")
(assume "cond")
(use "RealEqChar2RealConstrFree")
(autoreal)
(assume "p")
(intro 0 (pt "(x mod (PosS(PosS p))) max (y mod (PosS(PosS p)))"))
(assume "n")
(assume "cond1")
(simprat "<-" "RatPlusHalfExpPosS")
(simprat "<-" "RatPlusHalfExpPosS")
(use "RatInvTriangle2Inj" (pt "x seq (x mod (PosS(PosS(PosS p))))") (pt "y seq (y mod (PosS(PosS(PosS p))))") )
(simp "<-" "RatPlusAssoc")
(simp "<-" "RatPlusAssoc")
(use "RatLeMonPlus")
(use "CauchyElim" (pt "x mod"))
(use "RealToCauchy")
(auto)
(use "NatLeTrans" (pt "x mod(PosS(PosS p))max y mod(PosS(PosS p))"))
(use "NatMaxUB1")
(auto)
(use "MonElim")
(use "RealToMon")
(auto)
(simp "RatPlusAssoc")
(use "RatLeMonPlus")
(simprat  "RatPlusHalfExpPosS")
(use "RealLeToRatLe")
(use "RealLeTrans" (pt "ReaRat(1#2**PosS p)"))
(use "RealLeTrans" (pt "abs(ReaRat(x seq(x mod(PosS(PosS(PosS p))))) + ~(ReaRat(y seq(y mod(PosS(PosS(PosS p)))))))"))
(ng #t)
(use "RealLeRefl")
(autoreal)
(use "RealLeAbsInvTriangle2Inj" (pt "x") (pt "y"))
(simp "ReaRat0CompRule")
(realproof)
(simp "ReaRat0CompRule")
(realproof)
(realproof)
(realproof)
(simp "ReaRat0CompRule")
(realproof)
(use "RealLeTrans" (pt "ReaRat(1#2**(PosS(PosS(PosS p)))) + ReaRat(1#2**(PosS(PosS p))) + ReaRat(1#2**(PosS(PosS(PosS p))))"))
(use "RealLeMonPlus")
(use "RealLeMonPlus")
(simp "ReaRat0CompRule")
(simp "ReaRat0CompRule")
(use "RealApproxExFree")
(autoreal)
(simp "ReaRat0CompRule")
(auto)
(simp "ReaRat0CompRule")
(simp "ReaRat0CompRule")
(simpreal "RealAbsUMinusPlusComm")
(use "RealApproxExFree")
(autoreal)
(cut "Real(ReaRat(1#2**PosS p))")
(assume "cut")
(simpreal "RealPlusComm")
(simpreal "RealPlusAssoc")
(assert "all p (ReaRat(1#2**PosS(p)) + ReaRat(1#2**PosS(p))===ReaRat(1#2**p))")
(assume "p0")
(simp "ReaRat0CompRule")
(simp "ReaRat0CompRule")
(use "RatEqvToRealEq")
(simprat "<-" "RatPlusHalfExpPosS")
(ng #t)
(auto)
(assume "Assertion")
(cut "Real(ReaRat(1#2**PosS(PosS p)))")
(assume "cut2")
(simpreal "Assertion")
(simpreal "Assertion")
(simp "ReaRat0CompRule")
(use "RatLeToRealLe")
(auto)
(simp "ReaRat0CompRule")
(realproof)
(simp "ReaRat0CompRule")
(realproof)
(simp "ReaRat0CompRule")
(realproof)
(simp "ReaRat0CompRule")
(realproof)
(simp "ReaRat0CompRule")
(realproof)
(use "RealPlusReal")
(simp "ReaRat0CompRule")
(realproof)
(simp "ReaRat0CompRule")
(realproof)
(simp "ReaRat0CompRule")
(realproof)
(ng #t)
(use "RealLeRefl")
(realproof)
(use "CauchyElim" (pt "y mod"))
(use "RealToCauchy")
(auto)
(use "MonElim")
(use "RealToMon")
(auto)
(use "NatLeTrans" (pt "x mod(PosS(PosS p))max y mod(PosS(PosS p))"))
(use "NatMaxUB2")
(auto)
(save "RealEqChar2RLe")

(set-goal "all x,y(x=+=y-> all p(x mod p = y mod p) -> Real x -> Real y)")
(assume "x")
(assume "y")
(assume "x=y")
(assume "modcont")
(assume "Rx")
(use "RealIntro")
(use "CauchyIntro")
(assume "p0" "n" "m")
(assume "ymod" "ymod2")
(simprat "<-" (pf "x seq n == y seq n"))
(simprat "<-" (pf "x seq m == y seq m"))
(use "CauchyElim" (pt "x mod"))
(use "RealToCauchy")
(use "Rx")
(inst-with-to "modcont" (pt "p0") "ModInst")
(simp "ModInst")
(auto)
(inst-with-to "modcont" (pt "p0") "ModInst")
(simp "ModInst")
(auto)
(use "RealEqSElim")
(auto)
(use "RealEqSElim")
(auto)
(use "MonIntro")
(assume "p" "q")
(assume "p<=q")
(inst-with-to "modcont" (pt "p") "ModInst")
(simp "<-" "ModInst")
(inst-with-to "modcont" (pt "q") "ModInst2")
(simp "<-" "ModInst2")
(use "MonElim")
(use "RealToMon")
(auto)
(save "RealEqSToRealElim")


(set-goal "all x,y(x=+=y-> all p(x mod p <= y mod p)-> Mon (y mod) -> Real x -> Real y)")
(assume "x")
(assume "y")
(assume "x=y")
(assume "modcont")
(assume "modcont2")
(assume "Rx")
(use "RealIntro")
(use "CauchyDiffModAuxCauchy" (pt "x mod"))
(use "CauchyIntro")
(assume "p0" "n" "m")
(assume "ymod" "ymod2")
(simprat "<-" (pf "x seq n == y seq n"))
(simprat "<-" (pf "x seq m == y seq m"))
(use "CauchyElim" (pt "x mod"))
(use "RealToCauchy")
(use "Rx")
(auto)
(use "RealEqSElim")
(auto)
(use "RealEqSElim")
(auto)
(save "RealEqSToRealElimDiffMod")




(set-goal "all x (Real x -> exl p RealLt 0 x p -> ex y ( Real y & (exl p RealLt y x p) & (exl p RealLt 0 y p)))")
(assume "x" "Rx" "PosX")
(inst-with-to "RealLtMidPoint" (pt "ReaRat 0") (pt "x") "RMid")
(assert "ex a(exl p0 RealLt(ReaRat 0)a p0 andd exl p0 RealLt a x p0)")
(by-assume "PosX" "q" "PosXP")
(use "RMid" (pt "q"))
(ng #t)
(autoreal)
(use "PosXP")
(assume "RMidP")
(by-assume "RMidP" "a" "RMidPS")
(ex-intro "ReaRat a")
(split)
(ng #t)
(realproof)
(split)
(use "RMidPS")
(use "RMidPS")
(save "PosChooseProperAux")



(set-goal "all x(Real x -> 0<<=x*x)")
(cases)
(assume "as" "M")
(assume "Rx")
(use "RealNNegSToZeroLe")
(autoreal)
(use "RealNNegSIntro")
(ng #t)
(auto)
(save "SqrNNeg")


(set-goal "all x (Real x -> ~x* ~x === x*x)")
(cases)
(assume "as" "M")
(assume "Ras")
(use "RealEqSToEq")
(autoreal)
(use "RealEqSIntro")
(ng #t)
(auto)
(save "RealUMinusSqr")


(set-goal "all x,y,z,z1(Real x -> Real y -> Real z -> Real z1 -> (x+y)*(z+z1)===x*z + x*z1 + y*z + y*z1)")
(assume "x" "y" "z" "z1")
(assume "Rx" "Ry" "Rz" "Rz1")
(simpreal "RealTimesPlusDistrLeft")
(simpreal "RealTimesPlusDistr")
(simpreal "RealTimesPlusDistr")
(ng #t)
(simpreal "RealPlusAssoc")
(use "RealEqRefl")
(autoreal)
(save "RealPlusTimesDistrDouble")


(set-goal "all x,y (Real x -> Real y -> (x+ ~y)*(x+ ~y)===x*x + ~(x*y) + ~(x*y) + y*y )")
(assume "x" "y" "Rx" "Ry")
(simpreal "RealPlusTimesDistrDouble")
(use "RealPlusCompat")
(simpreal "<-" "RealPlusAssoc")
(simpreal "<-" "RealPlusAssoc")
(use "RealPlusCompat")
(use "RealEqRefl")
(autoreal)
(simpreal "RealTimesUMinusId")
(simpreal "RealTimesComm")
(simpreal "RealTimesUMinusId")
(use "RealPlusCompat")
(use "RealUMinusCompat")
(use "RealTimesComm")
(autoreal)
(use "RealUMinusCompat")
(use "RealTimesComm")
(autoreal)
(use "RealUMinusSqr")
(autoreal)
(save "RealBinomForm2")




(set-goal "all x,y( 0<<=x -> 0<<=y -> x+y===0 -> y===0)")
(assume "x" "y")
(assume "0lex" "0ley")
(assume "x+y=0") 
(use "RealLeAntiSym")
(use "RealLeTrans" (pt "~x"))
(use "RealLePlusCancelR" (pt "x"))
(autoreal)
(simpreal "RealPlusComm")
(use "RealLeTrans" (pt "ReaRat 0"))
(ng #t)
(use "RealLeReflNC")
(auto)
(ng #t)
(simpreal "RealPlusComm")
(simpreal "RealPlusMinusZero")
(use "RealLeRefl")
(autoreal)
(use "RealLePlusCancelL" (pt "x"))
(autoreal)
(simpreal "RealPlusMinusZero")
(simpreal "RealPlusZero")
(auto)
(autoreal)
(auto)
(save "RealPlusInjZero")



(set-goal "all x (Real x -> abs(x)===0 -> x===0)")
(cases)
(assume "as" "M")
(assume "Rx")
(assume "Rabs")
(inst-with-to "RealEqElim2" (pt "abs(RealConstr as M)") (pt "ReaRat 0") "Inst")
(ng "Inst")
(use "RealEqIntro")
(auto)
(realproof)
(ng #t)
(use "Inst")
(auto)
(save "RealAbsPosDef1")



(set-goal "all x(Real x -> x*x===0 -> x===0)")
(cases)
(assume "as" "M")
(assume "Ras")
(assume "x*x=0")
(use "RealAbsPosDef1")
(realproof)
(use "RealEqTrans" (pt "abs(ReaRat 0)"))
(use "SqrRevCompat")
(use "RealAbsNNeg")
(autoreal)
(simp "ReaRat0CompRule")
(use "RealAbsNNeg")
(autoreal)
(simp "ReaRat0CompRule")
(simpreal "<-" "RealAbsTimes")
(simpreal "<-" "RealAbsTimes")
(simpreal "<-" "RealSquarToAbs")
(simpreal "<-" "RealSquarToAbs")
(auto)
(autoreal)
(ng #t)
(use "RealEqRefl")
(autoreal)
(save "RealSqrZeroIsZero")