(display "loading rat.scm extension")(newline)

;; Appendix
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;_____APPENDIX_____;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;(set-goal "all a,b,c,d(a==b -> c==d -> (a<c)=(b<d))") 
;(assert "all a,b,c,d(a==b -> c==d -> a<c -> b<d)")  
;(assume "a" "b" "c" "d" "a=b" "c=d" "a<c")
;(use "RatLeLtTrans" (pt "a"))  
;(use "RatLeRefl")  
;(use "RatEqvSym")  
;(use "a=b")  
;(use "RatLtLeTrans" (pt "c"))  
;(use "a<c")  
;(use "RatLeRefl")  
;(use "c=d") 
;(assume "RatLtCompatAux") 
;(assume "a" "b" "c" "d") 
;(cases (pt "a<c")) 
;(ng #t) 
;(assume "a<c")
;(assume "a==b") 
;(assume "c==d")
;(assert "b<d")
;(use "RatLtCompatAux" (pt "a") (pt "c"))
;(use "a==b")
;(use "c==d")
;(use "a<c")
;(assume "b<d")
;(simp "b<d")
;(auto)
;(assume "(a<c -> F)")
;(assume "a==b" "c==d")
;(assert "(b<d)->F")
;(assume "b<d")
;(use "(a<c -> F)")
;(use "RatLtCompatAux" (pt "b") (pt "d")) 
;(use "RatEqvSym") 
;(use "a==b") 
;(use "RatEqvSym") 
;(use "c==d") 
;(use "b<d") 
;(assume "(b<d)->F") 
;(simp "(b<d)->F") 
;(use "Truth") 
;(save "RatLtCompat")

(set-goal "all p,q exl p0 (p#q)<=2**p0")
(assume "p" "q")
(intro 0 (pt "cNatPos(Succ(Succ(PosLog p)--PosLog q))"))
(simp "NatPosExFree")
(use "RatLeTrans" (pt "2**Succ(PosLog p)#2**PosLog q"))
(use "RatLePosExpTwo")
;;(simp "NatToPosToNatId")
(simp "PosToNatToPosId")
(use "RatLeTrans" (pt "(2**(Succ(PosLog p)--PosLog q)#1)"))
(use "RatLePosExpTwoMinus")
(ng)
(use "Truth")
(ng)
(use "Truth")
(save "RatBoundPos")

(animate "RatBoundPos")

(set-goal "all p,q (p#q)<=2**cRatBoundPos p q")
(assume "p" "q")
(simp "cRatBoundPos0CompRule")
(simp (pf "([p0,p1]cNatPos(Succ(Succ(PosLog p0)--PosLog p1)))p q=cNatPos(Succ(Succ(PosLog p)--PosLog q))"))
(simp "NatPosExFree")
(use "RatLeTrans" (pt "2**Succ(PosLog p)#2**PosLog q"))
(use "RatLePosExpTwo")
;;(simp "NatToPosToNatId")
(simp "PosToNatToPosId")
(use "RatLeTrans" (pt "(2**(Succ(PosLog p)--PosLog q)#1)"))
(use "RatLePosExpTwoMinus")
(ng)
(auto)
(save "RatBoundPosExFree")

(set-goal "all a exl p abs a<=2**p")
(cases)
(cases)
(use "RatBoundPos")
(ng)
(assume "p")
(intro 0 (pt "One"))
(use "Truth")
(use "RatBoundPos")
(save "RatLeAbsBoundPos")

(animate "RatBoundPos")
(animate "RatLeAbsBoundPos")

(set-goal "all a abs a<=2**cRatLeAbsBoundPos a")
(cases)
(cases)
(assume "p1" "p2")
(simp  "cRatLeAbsBoundPos0CompRule")
(ng #t)
(use "RatBoundPosExFree")
(auto)
(ng #t)
(use "RatBoundPosExFree")
(save "RatLeAbsBoundPosExFree")

(set-goal "all a Zero< cRatLeAbsBoundPos a")
(cases)
(cases)
(assume "p" "p0")
(ng)
(use "Truth")
(ng #t)
(assume "p")
(use "Truth")
(assume "p" "p0")
(ng)
(use "Truth")
(save "RatLeAbsBoundPosPos")

(set-goal "all a,b,c(~b+a<=c -> a<=b+c)")
(assume "a" "b" "c" "~b+a<=c")
(simprat (pf "a== b+ ~b+a"))
(simp "<-" "RatPlusAssoc")
(use "RatLeMonPlus")
(use "Truth")
(use "~b+a<=c")
(simprat (pf "b+ ~b==0"))
(use "Truth")
(use "Truth")
;; Proof finished.
(save "RatLePlusMinusToRatLePlus")

(set-goal "all a(0<a->a max 0=a)")
(cases)
(cases)
(assume "p" "q")
(ng #t)
(auto)
(save "RatMaxPosElim")

(set-goal "all a,b,c(b<=c -> a+b<=a+c)")
(assume "a" "b" "c")
(assume "InEq")
(ng #t)
(use "InEq")
;; proven
(save "RatLePlusCancelLInv")

;; RatLePlusCancelRInv
(set-goal "all a,b,c(b<=c -> b+a<=c+a)")
(assume "a" "b" "c" "InEq")
(ng #t)
(use "InEq")
;; proven
(save "RatLePlusCancelRInv")

;; RatLePlusCancelRSW 
(set-goal "all a,b,c((b<=c)=(b+a<=c+a))")
(assume "a" "b" "c")
(ng #t)
(use "Truth")
(save "RatLePlusCancelRSW")

;; RatLeTimesCancelLInv
(set-goal "all a,b,c(0<=a -> b <=c -> a*b <= a*c)")
(cases)
(cases)
(assume "p1" "p2")
(cases)
(cases)
(assume "q1" "q2")
(ind)
(cases)
(assume "r1" "r2")
(ng #t)
(assume 1)
(assume 1)
(simp (pf "(p1*q1*p2*r2)=((p1*p2)*q1*r2)"))
(simp (pf "(p1*r1*p2*q2)=((p1*p2)*r1*q2)"))
(inst-with "PosLeTimesCancelL" (pt "p1*p2") (pt "q1*r2") (pt "r1*q2"))
(simp 3)
(use 2)
(inst-with "PosTimesCancelLInv" (pt "p1") (pt "r1*p2*q2") (pt "p2*r1*q2"))
(ng 3)
(simp 3)
(simp (pf "r1*p2*q2 = p2*q2*r1"))
(simp-with "PosTimesCancelLInv" (pt "p2") (pt "q2*r1") (pt "r1*q2"))
(simp "PosTimesComm")
(use "Truth")
(simp "PosEqSym")
(simp "PosEqSym")
(auto)
(simp "PosTimesComm")
(ng #t)
(simp "PosTimesComm")
(ng #t)
(use "Truth")
(simp-with "PosTimesCancelLInv" (pt "p1") (pt "q1*p2*r2") (pt "p2*q1*r2"))
(simp "PosTimesComm")
(simp "PosEqSym")
(simp "PosTimesComm")
(simp-with "PosTimesCancelLInv" (pt "r2") (pt "p2*q1") (pt "q1*p2"))
(use "PosTimesComm")
(assume "p")
(ng #t)
(assume 1)
(use "Efq")
(assume "p" "q")
(ng #t)
(assume 1)
(use "Efq")
(assume "p")
(cases)
(cases)
(assume "r1" "r2")
(ng #t)
(strip)
(use "Truth")
(assume "r")
(ng #t)
(strip)
(use "Truth")
(assume "q" "r")
(ng #t)
(assume 1)
(use "Efq")
(assume "p" "q")
(cases)
(cases)
(assume "r1" "r2")
(ng #t)
(strip)
(use "Truth")
(assume "r")
(ng #t)
(strip)
(use "Truth")
(assume "r1")
(assume "r2")
(ng #t)
(assume 1)
(assume 1)
(simp (pf "(p1*r1*p2*q) = (p1*p2*r1*q)"))
(simp (pf "(p1*p*p2*r2) = (p1*p2*p*r2)"))
(simp-with "PosLeTimesCancelL" (pt "p1*p2") (pt "r1*q") (pt "p*r2"))
(use 2)
(simp-with "PosTimesCancelLInv" (pt "p1") (pt "p*p2*r2") (pt "p2*p*r2"))
(simp "PosTimesComm")
(simp "PosEqSym")
(simp "PosTimesComm")
(simp-with "PosTimesCancelLInv" (pt "r2") (pt "p2*p") (pt "p*p2"))
(use "PosTimesComm")
(simp-with "PosTimesCancelLInv" (pt "p1") (pt "r1*p2*q") (pt "p2*r1*q"))
(simp "PosTimesComm")
(simp "PosEqSym")
(simp "PosTimesComm")
(simp-with "PosTimesCancelLInv" (pt "q") (pt "p2*r1") (pt "r1*p2"))
(use "PosTimesComm")
(assume "p" "b" "c")
(ng #t)
(assume 1 1)
  (assert "all a,q ((0#q)*a == (0#q))")
  (cases)
  (assume "k" "q1" "q2")
  (use "Truth")
(assume 1)
(simprat 3)
(simprat 3)
(use "Truth")
(assume "p" "q" "b" "c")
(ng #t)
(use "Efq")
(save "RatLeTimesCancelLInv")

;; RatLeTimesCancelRInv
(set-goal "all a,b,c(0<=a -> b <=c -> b*a <= c*a)")
(assume "a" "b" "c" 1 1)
(inst-with "RatTimesComm" (pt "b") (pt "a"))
(simp 3)
(inst-with "RatTimesComm" (pt "c") (pt "a"))
(simp 4)
(use "RatLeTimesCancelLInv")
(use 1)
(use 2)
(save "RatLeTimesCancelRInv")

;; RatLeTimesMonR
(set-goal "all a,b(0<=a-> 0<=b -> 0 <=a*b)")
(cases)
(cases)
(assume "p1" "q1")
(ind)
(cases)
(assume "p2" "q2")
(ng #t)
(strip)
(use "Truth")
(assume "q2")
(ng #t)
(strip)
(use "Truth")
(assume "p2" "q2")
(ng #t)
(assume 1)
(use "Efq")
(assume "p")
(cases)
(cases)
(assume "p2" "q2")
(ng #t)
(strip)
(use "Truth")
(assume "q2")
(ng #t)
(strip)
(use "Truth")
(assume "p2" "q2")
(ng #t)
(strip)
(use "Truth")
(assume "p1 ""q1")
(cases)
(cases)
(assume "p2" "q2")
(ng #t)
(use "Efq")
(assume "q2")
(ng #t)
(assume 1 1)
(use 2)
(assume "p2" "q2")
(ng #t)
(strip)
(use "Truth")
(save "RatLeTimesMonR")

;; RatAbsToAbsInterValue
(set-goal "all a1,a2,a3,a4,a5( abs(a1+ ~(a3)) + abs(a3+ ~(a4)) + abs(a4+ ~(a2)) <= a5 -> abs(a1+ ~a2)<=a5)")
(assume "a1" "a2" "a3" "a4" "a5")
(assume 1)
(use "RatLeTrans" (pt "abs(a1+ ~a4)+abs(a4+ ~a2)"))
(use "RatLeAbsMinus")
(use "RatLePlusCancelR" (pt "~abs(a4+ ~a2)"))
(simprat (pf "(abs(a1+ ~a4)+abs(a4+ ~a2)+ ~abs(a4+ ~a2)) == (abs(a1+ ~a4))"))
(use "RatLeTrans" (pt "abs(a1+ ~a3)+abs(a3+ ~a4)"))
(use "RatLeAbsMinus")
(use "RatLePlusCancelR" (pt "abs(a4+ ~a2)"))
(simprat (pf "(a5+ ~abs(a4+ ~a2)+abs(a4+ ~a2)) == a5"))
(use 1)
(simp "RatPlusComm")
(ng #t)
(simp "RatPlusComm")
(ng #t)
(simprat (pf "(~(abs(a4+ ~a2))+ abs(a4+ ~a2)) == (0#1)"))
(use "Truth")
(use "Truth")
(simp "RatPlusComm")
(ng #t)
(simp "RatPlusComm")
(ng #t)
(simprat (pf "(abs(a4+ ~a2)+ ~(abs(a4+ ~a2))) == (0#1)"))
(use "Truth")
(use "Truth")
(save "RatAbsToAbsInterValue")

;; RatNegLePlusToZeroLeSum
(set-goal "all a,b,c(0<=a+b+ c -> ~c<=a+b)")
(assume "a" "b" "c")
(assume "RHSeq")
(use "RatLeTrans" (pt "a+b+ ~c+c"))
(simp (pf "(a+b+ ~c)=(~c+a+b)") )
(inst-with-to "RatLePlusCancelLInv" (pt "~c") (pt "0#1") (pt "a+b+c") "TransInv")
(use "TransInv")
(use "RHSeq")
(simp "RatPlusComm")
(use "Truth")
(simp "RatPlusComm")
(simp (pf "(a+b+ ~c) =(~c+a+b)"))
(ng #t)
(simprat (pf "(c+ ~c)==(0#1)"))
(use "Truth")
(simp "RatPlusComm")
(use "Truth")
(simp "RatPlusComm")
(use "Truth")
;; proven
(save "RatNegLePlusToZeroLeSum")

;; RatLeToZeroLePlus
(set-goal "all a,b(0<=a+ ~b -> b <=a)")
(inst-with-to "RatNegLePlusToZeroLeSum" (pt "a") (pt "0#1") (pt "~b") "Trans")
(ng "Trans")
(assume "a" "b")
(use "Trans")
;; proven
(save "RatLeToZeroLePlus")

;; RatLeZeroLeDouble
(set-goal "all a,b,c(~c <=a+b -> 0<=a+b+c)")
(assume "a" "b" "c")
(assume "RHSeq")
(simprat (pf "0 == ~c+c"))
(inst-with-to "RatLePlusCancelRInv" (pt "c") (pt "~c") (pt "a+b") "Trans")
(use "Trans")
(use "RHSeq")
(use "RatEqvSym")
(use "Truth")
;; proven
(save "RatZeroLeSumToNegLePlus")

;; reduction of former goal
(set-goal "all a,b(b <=a -> 0<=a+ ~b)")
(inst-with-to "RatZeroLeSumToNegLePlus" (pt "a") (pt "0#1") (pt "~b") "Trans")
(ng "Trans")
(assume "a" "b")
(use "Trans")
;; proven
(save "RatLeZeroPlusToRatLe")

;; RatLeZeroEqSumNeg
(set-goal "all a,b,c(0<=a+b+c)=(~c<=a+b)")
(assume "a" "b" "c")
(use "BooleAeqToEq")
(use "RatNegLePlusToZeroLeSum")
(use "RatZeroLeSumToNegLePlus")
;; Just A step
(save "RatLeZeroEqSumNeg")

;; RatLeToLeUMinusSwitch
(set-goal "all a,b(a <= b -> ~b <= ~a)")
(assume "a" "b")
(assume 1)
(ng #t)
(use 1)
(save "RatLeToLeUMinusSwitch")

;; RatLeUMinusToLeSwitch
(set-goal "all a,b(~a <= ~b -> b <= a)")
(assume "a" "b")
(assume 1)
(use 1)
(save "RatLeUMinusToLeSwitch")

;; ReaLeUMinusEqLeSwitch
(set-goal "all a,b((~a <= ~b) = (b <= a))")
(assume "a" "b")
(use "BooleAeqToEq")
(use "RatLeUMinusToLeSwitch")
(use "RatLeToLeUMinusSwitch")
(save "ReaLeUMinusEqLeSwitch")

;; RatLeSumToUMinusLeL
(set-goal "all a,b,c( a+ ~b <=c -> a <=b +c)")
(assume "a" "b" "c")
(inst-with "RatLeZeroEqSumNeg" (pt "c") (pt "0#1") (pt "~(a + ~b)"))
(ng 1)
(simp "<-" 1)
(assume 1)
(inst-with "RatLeZeroEqSumNeg"  (pt "0#1") (pt "b+c") (pt "~a") )
(ng 3)
(simp "<-" 3)
(ng #t)
(simp "RatPlusComm")
(ng #t)
(simp "RatPlusComm")
(ng #t)
(use 2)
(save "RatLeSumToUMinusLeL")

;; RatLeEqSumR
(set-goal "all a,b,c(0<=a+b+ ~c) = (c<=a+b)")
(assume "a" "b" "c")
(inst-with "RatLeZeroEqSumNeg" (pt "a") (pt "b") (pt "~c"))
(ng 1)
(use 1)
(save "RatLeEqSumR")

;; RatPlusTimesZero
(set-goal "all a,b((a+b)*0 == 0)")
(cases)
(assume "k" "p")
(cases)
(assume "i" "q")
(ng #t)
(use "Truth")
(save "RatPlusTimesZero")

;; RatBinomForm3
(set-goal "all a,b((a*a + ~(b*b))==((a+b)*(a + ~b)))")
(assume "a" "b")
(simprat (pf "((a+b)*(a+ ~b)) == (a*(a+b) + (~b)*(a+b))"))
(inst-with "RatTimesPlusDistr" (pt "a") (pt "a") (pt "b"))
(simprat 1)
(inst-with "RatTimesPlusDistr" (pt "~b") (pt "a") (pt "b"))
(simprat 2)
(ng #t)
(simp (pf "(b*a)=(a*b)"))
(simp "RatEqvSym")
(use "Truth")
(simp "RatPlusComm")
(ng #t)
(simp "RatPlusComm")
(ng #t)
(simprat (pf "((a*b)+ ~(a*b)) == 0"))
(use "Truth")
(use "Truth")
(use "RatTimesComm")
(inst-with "RatTimesPlusDistr" (pt "(a+b)") (pt "a") (pt "~b"))
(simprat 1)
(ng #t)
(simp "RatTimesComm")
(simp-with "RatTimesComm" (pt "(a+b)") (pt "b"))
(use "Truth")
(save "RatBinomForm3")

;; RatNZeroToLtAbs
(set-goal "all a((a==0->F)-> 0 < abs a)")
(cases)
(cases)
(assume "p1" "p2")
(ng #t)
(auto)
(save "RatNZeroToLtAbs")

;; RatLeToAbsId
(set-goal "all a (0<=a-> abs a = a)")
(cases)
(cases)
(assume "p" "q")
(ng #t)
(auto)
(save "RatLeToAbsId")

;; RatLeOneToLeUDiv
(set-goal "all a (1 <= a -> RatUDiv a <= a)")
(cases)
(cases)
(ng #t)
(assume "p1" "p2")
(assume 1)
(use "PosLeTrans" (pt "p2*p1"))
(inst-with "PosLeTimesCancelL" (pt "p2") (pt "p2") (pt "p1"))
(simp 2)
(use 1)
(simp "PosTimesComm")
(simp "PosLeTimesCancelL")
(use 1)
(assume "p")
(assume 1)
(ng #t)
(use "Truth")
(assume "p1" "p2")
(ng #t)
(use "Efq")
(save "RatLeOneToLeUDiv")

;; RatLeToLeUDivSwitch
(set-goal "all a,b(0 < a -> 0 < b -> a <= b -> RatUDiv b <= RatUDiv a) ")
(cases)
(cases)
(assume "p1" "p2")
(cases)
(cases)
(assume "q1" "q2")
(ng #t)
(assume 1)
(assume 1)
(assume 1)
(simp "PosTimesComm")
(simp (pf "p2*q1=q1*p2"))
(use 3)
(use "PosTimesComm")
(assume "p")
(ng #t)
(assume 1 1 1)
(use "Truth")
(assume "q1" "q2")
(ng #t)
(assume 1 1 1)
(use "Truth")
(assume "p" "b")
(ng #t)
(use "Efq")
(assume "p1" "p2")
(cases)
(cases)
(assume "q1" "q2")
(ng #t)
(use "Efq")
(assume "p")
(ng #t)
(use "Efq")
(assume "q1" "q2")
(ng #t)
(use "Efq")
(save "RatLeToLeUDivSwitch")

;; RatZeroLt
(set-goal "all p((0<(0#p)) = False)")
(ng #t)
(assume "p")
(use "Truth")
(save "RatZeroLt")
(add-rewrite-rule "0<(0#p)" "F")

;; RatUDivDivEqId
(set-goal "all a(RatUDiv(RatUDiv a) == a)")
(cases)
(cases)
(ng #t)
(assume "p" "q")
(use "Truth")
(assume "q")
(use "Truth")
(assume "p" "q")
(ng #t)
(use "Truth")
(save "RatUDivDivEqId")

;; RatUDivPosToRatPos
(set-goal "all a(0<a -> 0 < RatUDiv a)")
(cases)
(cases)
(assume "p" "q")
(ng #t)
(assume 1)
(use 1)
(assume "q")
(ng #t)
(assume 1)
(use 1)
(assume "p" "q")
(ng #t)
(assume 1)
(use 1)
(save "RatUDivPosToRatPos")

;; RatAbsUMinusAbsId
(set-goal "all a ( abs(~a) = abs(a))")
(assume "a")
(ng #t)
(use "Truth")
(save "RatAbsUMinusAbsId")


(add-program-constant "RatToNat" (py "rat=>nat"))
(add-computation-rule "RatToNat (i#p)" "NatDiv (IntToNat (abs i)) (IntToNat (abs i)) (PosToNat p)")

(set-totality-goal "RatToNat")
(assume "a^" "Ta")
(elim "Ta")
(assume "k^" "Tk" "p^" "Tp")
(ng #t)
(use "NatDivTotal")
(use "IntToNatTotal")
(use "IntAbsTotal")
(use "Tk")
(use "IntToNatTotal")
(use "IntAbsTotal")
(use "Tk")
(use "PosToNatTotal")
(use "Tp")
(save-totality)

;; RatEqvTimesConstrOne
(set-goal "all p,b(b == (b*p)*(1#p))")
(assert "all p( (IntPos p#p) == (1#1))")
  (ng #t)
  (assume "p1")
  (use "Truth")
(assume "TrivAss")
(ind)
(assume "b")
(use "Truth")
(assume "p" "IH")
(assume "b")
(simp "RatTimesComm")
(ng #t)
(simp "RatTimesComm")
(ng #t)
(simprat "TrivAss")
(use "Truth")
(assume "p" "IH")
(assume "b")
(simp "RatTimesComm")
(ng #t)
(simp "RatTimesComm")
(ng #t)
(simprat "TrivAss")
(use "Truth")
(save "RatEqvTimesConstrOne")

(set-goal "all p,a(One < p -> p*a+ ~a == (PosPred p)*a)")
(ind)
(assume "a")
(ng #t)
(use "Efq")
(assume "p" "IH")
(assume "a" "Lim")
(simprat (pf "SZero p*a+ ~a == (SZero p+ ~One)*a"))
(use "Truth")
(inst-with "RatTimesPlusDistrLeft" (pt "((IntPos (SZero p))#1)") (pt "(~1#1)") (pt "a"))
(ng 3)
(ng #t)
(simprat (pf "~a == ~1*a"))
(simprat 3)
(simprat (pf "~a == ~1*a"))
(use "Truth")
(use "Truth")
(use "Truth")
(assume "p" "IH")
(assume "a" "Lim")
(simprat (pf "SOne p*a+ ~a == (SOne p+ ~One)*a"))
(ng #t)
(use "Truth")
(inst-with "RatTimesPlusDistrLeft" (pt "((IntPos (SOne p))#1)") (pt "(~1#1)") (pt "a"))
(ng 3)
(ng #t)
(simprat (pf "~a == ~1*a"))
(simprat 3)
(simprat (pf "~a == ~1*a"))
(use "Truth")
(use "Truth")
(use "Truth")
(save "RatPosTimesUMinEqvPosTimes")

(set-goal "all p,a,b(One < p -> (a+b)*(1#p)+ ~b == (a+ ~(p-1)*b)*(1#p))")
(ind)
(assume "a" "b")
(ng #t)
(use "Efq")
(assume "p" "IH1" "a" "b" "Lim")
(ng #t)
(inst-with "RatEqvTimesConstrOne" (pt "SZero p") (pt "~b"))
(simprat 3)
(simprat "<-" "RatTimesPlusDistrLeft")
(ng #t)
(inst-with "RatPosTimesUMinEqvPosTimes" (pt "SZero p") (pt "~b"))
(ng 4)
(simprat "<-" 4)
(simp "RatPlusComm")
(ng #t)
(simp "RatPlusComm")
(ng #t)
(simp "RatTimesComm")
(use "Truth")
(use "Truth")
(assume "p" "IH")
(assume "a" "b" "Lim")
(ng #t)
(inst-with "RatEqvTimesConstrOne" (pt "SOne p") (pt "~b"))
(simprat 3)
(simprat "<-" "RatTimesPlusDistrLeft")
(ng #t)
(inst-with "RatPosTimesUMinEqvPosTimes" (pt "SOne p") (pt "~b"))
(ng 4)
(simprat "<-" 4)
(simp "RatPlusComm")
(ng #t)
(simp "RatPlusComm")
(ng #t)
(simp "RatTimesComm")
(use "Truth")
(use "Truth")
(save "RatFracSumUMinL")

;; RatPlusUMinDistr
(set-goal "all a,b((a+ ~b) = ~(~a+b))")
(ng #t)
(strip)
(use "Truth")
(save "RatPlusUMinDistr")

(set-goal "all a(~a+a == (0#1))")
(assume "a")
(use "Truth")
(save "RatZeroElim1")

(set-goal "all a,b((a==b)=(b==a))")
(cases)
(assume "k" "p")
(cases)
(assume "j" "q")
(ng #t)
(use "BooleAeqToEq")
(assume 1)
(simp 1)
(use "Truth")
(assume 1)
(simp 1)
(use "Truth")
(save "RatEqSym")

(set-goal "all n,m((2**n)*(2**m) = 2**(n+m))")
(ind)
(cases)
(ng #t)
(use "Truth")
(assume "m")
(ng #t)
(use "Truth")
(assume "n" "IH")
(assume "m")
(ng #t)
(use "IH")
(save "NatTwoExpEqPlusExp")

(set-goal "all n,p((2**n)*(2**p) = 2**(n+p))")
(cases)
(cases)
(ng #t)
(use "Truth")
(assume "p")
(ng #t)
(use "Truth")
(assume "p")
(ng #t)
(use "Truth")
(assume "n")
(cases)
(ng #t)
(use "Truth")
(assume "p")
(ng #t)
(inst-with "NatTwoExpEqPlusExp" (pt "n") (pt "NatDouble(PosToNat p)"))
(use 1)
(assume "p")
(ng #t)
(inst-with "NatTwoExpEqPlusExp" (pt "n") (pt "NatDouble(PosToNat p)"))
(use 1)
(save "PosExpTwoNatPlusPos")

(set-goal "all n,m,l((l**n) * (l**m) = l**(n+m))")
(ind)
(cases)
(assume "l")
(use "Truth")
(assume "m" "l")
(use "Truth")
(assume "n")
(assume "IH")
(assume "m" "l")
(ng #t)
(simp "NatTimesComm")
(inst-with "NatTimesCancelR" (pt "l**m*l**n") (pt "l") (pt "l**(n+m)"))
(cases (pt "l = Zero"))
(assume "case")
(simp "case")
(use "Truth")
(assume "case")
(ng #t)
(simp "NatTimeCancelR")
(simp "<-" "IH")
(simp "NatTimesComm")
(use "Truth")
(use "NatNotLeToLt")
(assume 1)
(use "case")
(simp "<-" "NatLeToEq")
(use 4)
(save "NatExpTimesEqPlus")

(set-goal "all a,b,c(a==c -> a max b == c max b)")
(assume "a" "b" "c")
(assume "eq")
(use "RatLeAntiSym")
(use "RatMaxLUB")
(simprat "eq")
(use "RatMaxUB1")
(use "RatMaxUB2")
(use "RatMaxLUB")
(simprat "<-" "eq")
(use "RatMaxUB1")
(use "RatMaxUB2")
(save "RatMaxEqvCancelR")

(set-goal "all a,b,c(a==c -> a max b <= c max b)")
(assume "a" "b" "c")
(assume "eq")
(use "RatMaxLUB")
(simprat "eq")
(use "RatMaxUB1")
(use "RatMaxUB2")
(save "RatMaxLeCancelR")

(set-goal "all a (0 < a -> 0 < 1/a)")
(cases)
(cases)
(ng #t)
(strip)
(use "Truth")
(ng #t)
(strip)
(use 1)
(ng #t)
(strip)
(use 1)
(save "RatPosUDivTrans")

(set-goal "all a((0#1) < abs a -> (1/a*a)==(1#1))")
(cases)
(cases)
(ng #t)
(strip)
(use "PosTimesComm")
(ng #t)
(strip)
(use 1)
(ng #t)
(strip)
(use "PosTimesComm")
(save "RatUDivIdEqOne")

(set-goal "all a,p((1#p) < RatUDiv abs a -> abs a < ((IntPos p)#1))")
(cases)
(cases)
(assume "p1" "q1" "p")
(ng #t)
(assume 1)
(simp "PosTimesComm")
(use 1)
(assume "q1" "p")
(ng #t)
(assume 1)
(use "Truth")
(assume "p1" "q1" "p")
(ng #t)
(assume 1)
(simp "PosTimesComm")
(use 1)
(save "RatPosUDivRule1")

(set-goal "all a,p(0 < abs a -> abs a <= ((IntPos p)#1) -> (1#p) <= RatUDiv abs a)")
(cases)
(cases)
(assume "p1" "q1" "p")
(ng #t)
(assume 1 1)
(simp "PosTimesComm")
(use 2)
(assume "q1" "p")
(ng #t)
(assume 1 1)
(use 1)
(assume "p1" "q1" "p")
(ng #t)
(assume 1 1)
(simp "PosTimesComm")
(use 2)
(save "RatPosUDivRule1Inv")

(set-goal "all a,b,c (0<a -> (a*b)max(a*c) == a*(b max c))")
(assume "a" "b" "c")
(assume "Cond1")
(use "RatLeAntiSym")
(use "RatMaxLUB")
(use "RatLeTimesCancelLInv")
(use "RatLtToLe")
(use "Cond1")
(use "RatMaxUB1")
(use "RatLeTimesCancelLInv")
(use "RatLtToLe")
(use "Cond1")
(use "RatMaxUB2")
(use "RatLeTimesCancelL" (pt "1/a"))
(use "RatPosUDivTrans")
(use "Cond1")
(ng #t)
(simprat "RatUDivIdEqOne")
(ng #t)
(use "RatMaxLUB")
(use "RatLeTimesCancelL" (pt "a"))
(use "Cond1")
(ng #t)
(inst-with "RatTimesComm" (pt "a") (pt "1/a"))
(ng 2)
(simp 2)
(simprat "RatUDivIdEqOne")
(ng #t)
(use "RatMaxUB1")
(simp "RatAbsId")
(use "Cond1")
(use "RatLtToLe")
(use "Cond1")
(use "RatLeTimesCancelL" (pt "a"))
(use "Cond1")
(inst-with "RatTimesComm" (pt "a") (pt "1/a"))
(ng 2)
(ng #t)
(simp 2)
(simprat "RatUDivIdEqOne")
(ng #t)
(use "RatMaxUB2")
(simp "RatAbsId")
(use "Cond1")
(use "RatLtToLe")
(use "Cond1")
(simp "RatAbsId")
(use "Cond1")
(use "RatLtToLe")
(use "Cond1")
(save "RatMaxTimesDistr")

(set-goal "all a,b(a==b-> a<=b)")
(assume "a" "b")
(assume "s")
(simprat "s")
(use "Truth")
(save "RatEqvToLe")

(set-goal "all a (a*(0#1) == (0#1))")
(cases)
(ng #t)
(assume "k" "p")
(use "Truth")
(save "RatTimesZeroEqRatZero")
;; (add-rewrite-rule "a*(0#1)" "(0#1)") ;; Cant be proven!

(set-goal "all a,b,c (a == c andnc b==c -> a max b == c)")
(assume "a" "b" "c")
(assume 1)
(use "RatLeAntiSym")
(use "RatMaxLUB")
(assert "a==c")
(use 1)
(assume "eq")
(simprat "eq")
(use "Truth")
(assert "b==c")
(use 1)
(assume "eq")
(simprat "eq")
(use "Truth")
(assert "c == a")
(simp "RatEqSym")
(use 1)
(assume "eq")
(simprat "eq")
(use "RatMaxUB1")
(save "RatMaxToCases")

(set-goal "all a,b((~a<= ~b) = (b <= a))")
(search)
(save "RatLeNegToPos")

(set-goal "all a,b,c((0#1) < abs a -> (abs(a*b) <= abs(a*c)) = (abs b <= abs c))")
  (assert "all p1,p2,q1,q3,p3,q2(p1*p2*q1*q3<=p1*p3*q1*q2)=(p2*q3<=p3*q2)")
    (assume "p1" "p2" "q1" "q3" "p3" "q2")
    (use "BooleAeqToEq")
    (assume "LHS")
    (simp "<-" "PosLeTimesCancelL" (pt "p1"))
    (ng #t)
    (simp-with "PosTimesComm" (pt "p1*p2") (pt "q3"))
    (simp-with "PosTimesComm" (pt "p1*p3") (pt "q2"))
    (ng #t)
    (simp "<-" "PosLeTimesCancelL" (pt "q1"))
    (ng #t)
    (simp-with "PosTimesComm" (pt "q1*q3") (pt "p1*p2"))
    (simp-with "PosTimesComm" (pt "q1*q2") (pt "p1*p3"))
    (use "LHS")
    (assume "RHS")
    (simp-with "PosLeTimesCancelL" (pt "p1") (pt "p2*q1*q3") (pt "p3*q1*q2"))
    (simp-with "PosTimesComm" (pt "p2") (pt "q1*q3"))
    (simp-with "PosTimesComm" (pt "p3") (pt "q1*q2"))
    (simp-with "PosLeTimesCancelL" (pt "q1") (pt "q3*p2") (pt "q2*p3"))
    (simp-with "PosTimesComm" (pt "q3") (pt" p2"))
    (simp-with "PosTimesComm" (pt "q2") (pt "p3"))
    (use "RHS")
  (assume "Ass1")
(cases)
(cases)
(assume "p1" "q1")
(cases)
(cases)
(assume "p2" "q2")
(cases)
(cases)
(assume "p3" "q3")
(ng #t)
(assume 1)
(use "Ass1")
(assume "q3")
(ng #t)
(assume 1)
(use "Truth")
(assume "p3" "q3")
(ng #t)
(assume 1)
(use "Ass1")
(assume "q2")
(cases)
(cases)
(assume "p3" "q3")
(ng #t)
(assume 1)
(use "Truth")
(assume "q3")
(ng #t)
(assume 1)
(use "Truth")
(assume "p3" "q3")
(ng #t)
(assume 1)
(use "Truth")
(assume "p2" "q2")
(cases)
(cases)
(assume "p3" "q3")
(ng #t)
(assume 1)
(use "Ass1")
(assume "q3")
(ng #t)
(assume 1)
(use "Truth")
(assume "p3" "q3")
(ng #t)
(assume 1)
(use "Ass1")
(assume "p1")
(assume "b" "c")
(ng #t)
(use "Efq")
(assume "p1" "q1")
(cases)
(cases)
(assume "p2" "q2")
(cases)
(cases)
(assume "p3" "q3")
(ng #t)
(assume 1)
(use "Ass1")
(assume "q3")
(ng #t)
(assume 1)
(use "Truth")
(assume "p3" "q3")
(ng #t)
(assume 1)
(use "Ass1")
(assume "q2")
(cases)
(cases)
(assume "p3" "q3")
(ng #t)
(assume 1)
(use "Truth")
(assume "q3")
(ng #t)
(assume 1)
(use "Truth")
(assume "p3" "q3")
(ng #t)
(assume "1")
(use "Truth")
(assume "p2" "q2")
(cases)
(cases)
(assume "p3" "q3")
(ng #t)
(assume 1)
(use "Ass1")
(assume "q3")
(ng #t)
(assume 1)
(use "Truth")
(assume "p3" "q3")
(ng #t)
(assume 1)
(use "Ass1")
(save "RatLeAbsTimesCancelL")

(set-goal "all a((abs a <= 0) = (a == (0#1)))")
(cases)
(cases)
(auto)
(save "RatAbsLeEqZero")
(add-rewrite-rule "abs a <= 0" "a == (0#1)")

(set-goal "all a1,a2,a3,a4(a1 <= a3 andb a2 <=a4 -> a1 + a2 <= a3 + a4)")
(assume "a1" "a2" "a3" "a4")
(assume 1)
(use "RatLeTrans" (pt "a1+a4"))
(use "RatLePlusCancelLInv")
(use 1)
(use "RatLePlusCancelRInv")
(use 1)
(save "RatLeSumToCases")

(set-goal "k*(p*r) = k*p*r")
(ng #t)
(cases)
(assume "p1")
(assume "p3")
(assume "p4")
(auto)
(save "IntPosTimesReWriteRule1")
(add-rewrite-rule "k*(p*r)" "k*p*r")

(set-goal "all a,b,c(0<abs a -> (a*b==a*c) = (b==c))")
(cases)
(assume "k" "p")
(cases)
(assume "j" "q")
(cases)
(assume "i" "r")
(assume "Cond")
(ng #t)
(use "BooleAeqToEq")
(assume "EqHyp")
(use "IntTimesCancelL" (pt "k"))
(ng "Cond")
(use "Cond")
(ng #t)
(simp "IntTimesComm")
(ng #t)
(simp "IntTimesComm")
(ng #t)
(simp "IntTimesComm")
(ng #t)
(simp "IntTimesComm")
(ng #t)
(use "IntTimesCancelL" (pt "IntPos p"))
(use "Truth")
(ng #t)
(simp-with "IntTimesComm" (pt "IntPos p*IntPos r") (pt "k*j"))
(simp-with "IntTimesComm" (pt "p*k*i") (pt "IntPos q"))
(ng #t)
(simp-with "IntTimesComm" (pt "IntPos q") (pt "IntPos p"))
(simp-with "IntTimesComm" (pt "IntPos p* IntPos q") (pt "k*i"))
(use "EqHyp")
(assume "EqHyp")
(simp-with "IntTimesComm" (pt "k") (pt "j"))
(ng #t)
(simp-with "IntTimesComm" (pt "j*k*p") (pt "IntPos r"))
(ng #t)
(simp-with "IntTimesComm" (pt "IntPos r") (pt "j"))
(simp "EqHyp")
(simp-with "IntTimesComm" (pt "i*q*k") (pt "IntPos p"))
(ng #t)
(simp-with "IntTimesComm" (pt "IntPos p") (pt "i"))
(simp-with "IntTimesComm" (pt "i*p*q") (pt "k"))
(use "Truth")
(save "RatTimesCancelLSW")

(set-goal "all a((a==0->F)-> 0 < abs a)")
(cases)
(cases)
(ng #t)
(assume "p" "q" 1)
(use "Truth")
(ng #t)
(assume "q")
(assume 1)
(use 1)
(use "Truth")
(assume "p" "q")
(ng #t)
(assume 1)
(use "Truth")
(save "RatNotZeroToLtAbs")

(set-goal "all a,b(0<=a -> 0<=b -> 0<=a+b)")
(cases)
(cases)
(assume "p1" "q1")
(cases)
(cases)
(assume "p2" "q2")
(auto)
(assume "p2" "q2")
(ng #t)
(assume 1)
(use "Efq")
(assume "q1")
(cases)
(cases)
(assume "p2" "q2")
(auto)
(assume "p1" "q1")
(assume "b")
(ng #t)
(use "Efq")
(save "RatZeroLeSumCases")

(set-goal "all a,b(0<a -> 0<=b -> 0<a+b)")
(cases)
(cases)
(assume "p1" "q1")
(cases)
(cases)
(assume "p2" "q2")
(auto)
(assume "p2" "q2")
(ng #t)
(assume 1)
(use "Efq")
(assume "q1")
(cases)
(cases)
(assume "p2" "q2")
(auto)
(assume "p1" "q1")
(assume "b")
(ng #t)
(use "Efq")
(save "RatZeroLtSumCases")

(set-goal "all a (a+a == 2*a)")
(cases)
(cases)
(assume "p1" "q1")
(ng #t)
(simp "PosSZeroEqPlus")
(use "Truth")
(ng #t)
(assume "p1")
(use "Truth")
(assume "p1" "q1")
(ng #t)
(simp "PosSZeroEqPlus")
(use "Truth")
(save "RatPlusIdEqvTimesTwo")

(set-goal "all a,b(((0<a andb 0<b) orb (a<0 andb b<0))-> 0 < a*b)")
(cases)
(cases)
(assume "p1" "q1")
(cases)
(cases)
(assume "p2" "q2")
(ng #t)
(assume 1)
(use "Truth")
(assume "q2")
(ng #t)
(assume 1)
(use 1)
(assume "p2" "q2")
(ng #t)
(assume 1)
(use 1)
(assume "q1")
(cases)
(cases)
(ng #t)
(assume "p2" "q2")
(assume 1)
(use 1)
(assume "q2")
(ng #t)
(assume 1)
(use 1)
(assume "p2" "q2")
(ng #t)
(assume 1)
(use 1)
(assume "p1" "q1")
(ng #t)
(cases)
(cases)
(assume "p2" "q2")
(ng #t)
(assume 1)
(use 1)
(assume "q2")
(ng #t)
(assume 1)
(use 1)
(assume "p2" "q2")
(ng #t)
(assume 1)
(use "Truth")
(save "RatZeroLtTimesCases")

(set-goal "all p (1#2**PosS p)==(1#2**p)+ ~(1#2**PosS p)")
(assume "p")
(use "RatEqvPlusCancelR" (pt "(1#2**PosS p)"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "~(1#2**PosS p)+(1#2**PosS p) ==0"))
(simprat (pf "(1#2**p)+0==(1#2**p)"))
(use "RatPlusHalfExpPosS")
(auto)
;; Proof finished.
(save "RatPlusHalfExpPosSSplit")

(set-goal "all a ((abs a ==0 -> F) -> 0<abs(a))")
(cases)
(cases)
(ng #t)
(auto)
(save "RatAbsNotEqvZeroElim")

(set-goal "all a ((0<abs a -> F) -> abs a ==0)")
(cases)
(cases)
(ng #t)
(auto)
(save "RatAbsEqvZeroElim")

(set-goal "all a(0<=a->a max 0==a)")
(cases)
(cases)
(assume "p" "q")
(ng #t)
(auto)
(save "RatMaxNNegElim")

(set-goal "all a(abs(a) max 0 == abs(a))")
(assume "a")
(use "RatMaxNNegElim")
(ng #t)
(use "Truth")
(save "RatMaxAbsElim")


(set-goal "all a(abs(a) max 0 = abs(a))")
(cases)
(ng #t)
(assume "k" "p")
(auto)
(add-rewrite-rule "abs(a) max 0" "abs(a)")


(set-goal "all a,b,c(a<=c  -> a max b <= c max b)")
(assume "a" "b" "c" )
(assume "eq0" )
(use "RatMaxLUB")
(use "RatLeTrans" (pt "c"))
(use "eq0")
(use "RatMaxUB1")
(use "RatMaxUB2")
(save "RatMaxLeLeCompat")

; (set-goal "all a,b( a min b <= a)")
; (cases)
; (cases)
; (assume "p" "p0")
; (cases)
; (cases)
; (assume "p1" "p2")
; (ng #t)
; (cases (pt "p*p2<=p1*p0"))
; (ng #t)
; (auto)
; (assume "case2")
; (ng #t)
; (use "PosLtToLe")
; (use "PosNotLeToLt")
; (auto)
; (assume "p")
; (cases)
; (cases)
; (ng #t)
; (auto)
; (assume "p" "p0")
; (cases)
; (cases)
; (assume "p1" "p2")
; (ng #t)
; (auto)
; (assume "p1" "p2")
; (ng #t)
; (cases (pt "p1*p0<=p*p2"))
; (ng #t)
; (auto)
; (assume "case")
; (ng #t)
; (use "PosLtToLe")
; (use "PosNotLeToLt")
; (auto)
; (save "RatMinLB1")

; (set-goal "all a,b( a min b <= b)")
; (cases)
; (cases)
; (assume "p" "p0")
; (cases)
; (cases)
; (assume "p1" "p2")
; (ng #t)
; (cases (pt "p*p2<=p1*p0"))
; (ng #t)
; (auto)
; (assume "p")
; (cases)
; (cases)
; (assume "p0" "p1")
; (auto)
; (assume "p" "p0")
; (cases)
; (cases)
; (assume "p1" "p2")
; (ng #t)
; (auto)
; (assume "p1" "p2")
; (ng #t)
; (cases (pt "p1*p0<=p*p2"))
; (assume "case")
; (ng #t)
; (auto)
; (save "RatMinLB2")

(set-goal "all a (0<a -> exl q (1#2**q)<= a)")
(cases)
(cases)
(assume "p")
(ind)
(ng #t)
(assume "T")
(intro 0 (pt "One"))
(use "Truth")
(assume "p0")
(assume "Ih")
(ng #t)
(assume "T")
(assert "exl q (1#2**q)<=(p#p0)")
(use "Ih")
(auto)
(assume "ExHyp")
(by-assume "ExHyp" "p1" "ExHypProp")
(ng)
(intro 0 (pt "PosS p1"))
(ng #t)
(simp (pf "2**PosS p1 =2* 2**p1"))
(ng #t)
(use "ExHypProp")
(ng #t)
(simp (pf "2**PosS p1=2**p1*2"))
(ng #t)
(auto)
(simp (pf "PosS p1=p1+1"))
(simp "<-" "PosExpTwoPosPlus")
(ng #t)
(auto)
(assume "p0" "Ih")
(assert "exl q (1#2**q)<=(p#p0)")
(auto)
(assume "ExHyp")
(by-assume "ExHyp" "p1" "ExHypProp")
(assume "T")
(ng)
(intro 0 (pt "PosS(PosS p1)"))
(ng #t)
(simp (pf "2**PosS(PosS p1) =2**PosS(p1)*2"))
(ng #t)
(use "PosLeLtTrans" (pt "p*2**p1"))
(auto)
(use "PosLtTimesCancelLThm")
(use "PosExpLtPosSExp")
(ng #t)
(simp (pf  "PosS(PosS p1)=(PosS p1)+1"))
(simp "<-" "PosExpTwoPosPlus")
(ng #t)
(use "Truth")
(ng #t)
(use "Truth")
(assume "p")
(ng #t)
(use "Efq")
(assume "p" "p0")
(ng #t)
(use "Efq")
(save "RatLeftPosBound")

(add-sound "RatLeftPosBound")

(set-goal "all a (0<a -> exnc p (p eqd cRatLeftPosBound a andnc (1#2**p)<=a))")
(assume "a" "0<a")
(intro 0 (pt "cRatLeftPosBound a"))
(split)
(use "InitEqD")
(use-with "ExLTMRElim" (py "p") (make-cterm (pv "p") (pf "(1#2**p)<=a")) (pt "cRatLeftPosBound a") "?")
(use "RatLeftPosBoundSound")
(auto)
(save "RatLeftPosBoundSoundCorr")

(set-goal "all a (0<a -> (1#2**cRatLeftPosBound a)<=a)")
(assume "a" "0<a")
(inst-with-to "RatLeftPosBoundSoundCorr" (pt "a") "Sound1")
(assert "exnc p(p eqd cRatLeftPosBound a andnc (1#2**p)<=a)")
(auto)
(assume "ExInst")
(by-assume "ExInst" "p0" "ExInstProp")
(simp "<-" "ExInstProp")
(use "ExInstProp")
(save "RatLeftPosBoundCorr")


(set-goal "all a,b,c,d(a<b->c<=d->a+c<b+d)")
  (assume "a" "b" "c" "d")
  (assume "Rel1" "Rel2")
  (use "RatLtLeTrans" (pt "b+c"))
  (ng #t)
  (use "Rel1")
  (ng #t)
  (use "Rel2")
(save "RatLtLeMonPlus")

(set-goal "all a(~a <=abs(a))")
(cases)
(cases)
(assume "p" "p0")
(auto)
(save "RatAbsInvLeqAbs")

(set-goal "all a,p (a<a+(1#2**p))")
(assume "a")
(assume "p")
(use "RatLtPlusCancelL" (pt "~a"))
(simprat (pf "~a+a==0"))
(ng #t)
(simprat (pf "~a+a==0"))
(ng #t)
(use "Truth")
(use "Truth")
(use "Truth")
(save "RatPlusEpsLt")

(set-goal "all a,b,c(a<=b->0<=c-> a<=b+c)")
(assume "a" "b" "c")
(strip)
(simp (pf "a=a+0"))
(use "RatLeMonPlus")
(use 1)
(use 2)
(use "Truth")
;; proven
(save "RatLeMonPlusL")

(set-goal "all a,b(abs a <= b -> ~b <= a)")
  (cases)
  (cases)
  (assume "p1" "q1")
  (cases)
  (cases)
  (assume "p2" "q2")
  (ng #t)
  (assume 1)
  (use "Truth")
  (assume "p2")
  (ng #t)
  (assume 1)
  (use "Truth")
  (assume "p2" "q2")
  (ng #t)
  (use "Efq")
  (assume "q1")
  (cases)
  (cases)
  (assume "p2" "q2")
  (ng #t)
  (assume 1)
  (use "Truth")
  (assume "q2")
  (ng #t)
  (assume 1)
  (use "Truth")
  (assume "p2" "q2")
  (ng #t)
  (use "Efq")
  (assume "p1" "q1")
  (cases)
  (cases)
  (assume "p2" "q2")
  (ng #t)
  (assume "Rel")
  (use "Rel")
  (assume "q2")
  (ng #t)
  (use "Efq")
  (assume "p2" "q2")
  (ng #t)
  (use "Efq")
(save "RatAbsToMinusLe0")

(set-goal "all a,b(abs a <= b -> a <= b)")
  (cases)
  (cases)
  (assume "p1" "q1")
  (cases)
  (cases)
  (assume "p2" "q2")
  (ng #t)
  (assume "Rel")
  (use "Rel")
  (assume "q2")
  (ng #t)
  (use "Efq")
  (assume "p2" "q2")
  (ng #t)
  (use "Efq")
  (assume "q1")
  (cases)
  (cases)
  (assume "p2" "q2")
  (ng #t)
  (assume 1)
  (use "Truth")
  (assume "q2")
  (ng #t)
  (assume 1)
  (use "Truth")
  (assume "p2" "q2")
  (ng #t)
  (use "Efq")
  (assume "p1" "q1")
  (cases)
  (cases)
  (assume "p2" "q2")
  (ng #t)
  (assume 1)
  (use "Truth")
  (assume "q2")
  (ng #t)
  (assume 1)
  (use "Truth")
  (assume "p2" "q2")
  (ng #t)
  (use "Efq")
(save "RatAbsToMinusLe1")

;_________________ Term Transfor Libs ____________________

(set-goal "all a(0<=a*a)")
  (cases)
  (ind)
  (assume "p1" "p2")
  (ng)
  (use "Truth")
  (ng)
  (assume "p3")
  (use "Truth")
  (ng)
  (assume "p4" "p5")
  (use "Truth")
(add-rewrite-rule "0<=a*a" "True")
(save "RatTimesIdPos")

(set-goal "all a,b abs a*abs b == abs(a*b)")
  (cases)
  (assume "k" "p")
  (cases)
  (assume "j" "q")
  (use "Truth")
(save "RatAbsDistrTimes")

(set-goal "all a,b a* ~b= ~(a*b)")
  (cases)
  (assume "k" "p")
  (cases)
  (assume "j" "q")
  (ng)
  (use "Truth")
(save "RatTimesIdUMinus")

(set-goal "all a,b,c((a+b<a+c) = (b<c))")
  (assume "a" "b" "c")
  (use "BooleAeqToEq")
  (assume "Ext")
  (use "RatLtPlusCancelL" (pt "a"))
  (use "Ext")
  (assume "Rel")
  (use "RatLtPlusCancelL" (pt "~a"))
  (ng #t)
  (simprat (pf "~a+a == 0"))
  (use "Rel")
(add-rewrite-rule "(a+b<a+c)" "(b<c)")
(save "RatLtPlusCancelLInv")

(set-goal "all a,b,c((a+c<b+c) = (a<b))")
  (assume "a" "b" "c")
  (use "BooleAeqToEq")
  (assume "Ext")
  (use "RatLtPlusCancelR" (pt "c"))
  (use "Ext")
  (assume "Rel")
  (use "RatLtPlusCancelL" (pt "~c"))
    (ng #t)
    (simp "RatPlusComm")
    (ng #t)
  (simprat (pf "c+ ~c == 0"))
    (ng #t)
    (simp "RatPlusComm")
    (ng #t)
  (simprat (pf "c+ ~c == 0"))
  (use "Rel")
(add-rewrite-rule "(a+c<b+c)" "(a<b)")
(save "RatLtPlusCancelRInv")

(set-goal "all a,b((a<=a+b) = (0<=b))")
  (assume "a" "b")
  (use "BooleAeqToEq")
  (assume "Rel")
  (use "RatLePlusCancelL" (pt "a"))
  (use "Rel")
  (assume "Rel")
  (use "RatLePlusCancelL" (pt "~a"))
  (ng #t)
  (simprat (pf "~a+a == 0"))
  (use "Rel")
  (use "Truth")
(add-rewrite-rule "(a<=a+b)" "(0<=b)")
(save "RatLeElimL")

(set-goal "all a,b,c((a<= b+ ~c) = (a+c<=b))")
  (assume "a" "b" "c")
  (use "BooleAeqToEq")
  (assume "Rel")
  (use "RatLePlusCancelR" (pt "~c"))
  (simp-with "RatPlusComm" (pt "a") (pt "c+ ~c"))
  (simprat (pf "c+ ~c==0"))
  (ng #t)
  (use "Rel")
  (use "Truth")
  (assume "Rel")
  (use "RatLePlusCancelR" (pt "c"))
  (simp-with "RatPlusComm" (pt "b") (pt "~c+c"))
  (simprat (pf "~c+c == 0"))
  (use "Rel")
  (use "Truth")
;(add-rewrite-rule "(a<= b+ ~c)" "(a+c<=b)")
(save "RatLeNegElimR")

;; (set-goal "all a,b,c(0<=a -> b <=c -> a*b <= a*c)")
;;   (cases)
;;   (cases)
;;   (assume "p1" "p2")
;;   (cases)
;;   (cases)
;;   (assume "q1" "q2")
;;   (ind)
;;   (cases)
;;   (assume "r1" "r2")
;;   (ng #t)
;;   (assume 1)
;;   (assume 1)
;;   (simp (pf "(p1*q1*p2*r2)=((p1*p2)*q1*r2)"))
;;   (simp (pf "(p1*r1*p2*q2)=((p1*p2)*r1*q2)"))
;;   (inst-with "PosLeTimesCancelL" (pt "p1*p2") (pt "q1*r2") (pt "r1*q2"))
;;   (simp 3)
;;   (use 2)
;;   (inst-with "PosTimesCancelLInv" (pt "p1") (pt "r1*p2*q2") (pt "p2*r1*q2"))
;;   (ng 3)
;;   (simp 3)
;;   (simp (pf "r1*p2*q2 = p2*q2*r1"))
;;   (simp-with "PosTimesCancelLInv" (pt "p2") (pt "q2*r1") (pt "r1*q2"))
;;   (simp "PosTimesComm")
;;   (use "Truth")
;;   (simp "PosTimesComm")
;;   (ng #t)
;;   (simp "PosTimesComm")
;;   (ng #t)
;;   (use "Truth")
;;   (ng #t)
;;   (simp-with "PosTimesCancelLInv" (pt "p1") (pt "q1*p2*r2") (pt "p2*q1*r2"))
;;   (simp "<-" "PosTimesComm")
;;   (ng #t)
;;   (simp "<-" "PosTimesComm")
;;   (ng #t)
;;   (simp-with "PosTimesCancelLInv" (pt "p2") (pt "r2*q1") (pt "q1*r2"))
;;   (use "PosTimesComm")
;;   (assume "p")
;;   (ng #t)
;;   (assume 1)
;;   (use "Efq")
;;   (assume "p" "q")
;;   (ng #t)
;;   (assume 1)
;;   (use "Efq")
;;   (assume "p")
;;   (cases)
;;   (cases)
;;   (assume "r1" "r2")
;;   (ng #t)
;;   (strip)
;;   (use "Truth")
;;   (assume "r")
;;   (ng #t)
;;   (strip)
;;   (use "Truth")
;;   (assume "q" "r")
;;   (ng #t)
;;   (assume 1)
;;   (use "Efq")
;;   (assume "p" "q")
;;   (cases)
;;   (cases)
;;   (assume "r1" "r2")
;;   (ng #t)
;;   (strip)
;;   (use "Truth")
;;   (assume "r")
;;   (ng #t)
;;   (strip)
;;   (use "Truth")
;;   (assume "r1")
;;   (assume "r2")
;;   (ng #t)
;;   (assume 1)
;;   (assume 1)
;;   (simp (pf "(p1*r1*p2*q) = (p1*p2*r1*q)"))
;;   (simp (pf "(p1*p*p2*r2) = (p1*p2*p*r2)"))
;;   (simp-with "PosLeTimesCancelL" (pt "p1*p2") (pt "r1*q") (pt "p*r2"))
;;   (use 2)
;;   (simp-with "PosTimesCancelLInv" (pt "p1") (pt "p*p2*r2") (pt "p2*p*r2"))
;;   (simp "PosTimesComm")
;;   (simp "PosEqSym")
;;   (simp "PosTimesComm")
;;   (simp-with "PosTimesCancelLInv" (pt "r2") (pt "p2*p") (pt "p*p2"))
;;   (use "PosTimesComm")
;;   (simp-with "PosTimesCancelLInv" (pt "p1") (pt "r1*p2*q") (pt "p2*r1*q"))
;;   (simp "PosTimesComm")
;;   (simp "PosEqSym")
;;   (simp "PosTimesComm")
;;   (simp-with "PosTimesCancelLInv" (pt "q") (pt "p2*r1") (pt "r1*p2"))
;;   (use "PosTimesComm")
;;   (assume "p" "b" "c")
;;   (ng #t)
;;   (assume 1 1)
;;     (assert "all a,q ((0#q)*a == (0#q))")
;;       (cases)
;;       (assume "k" "q1" "q2")
;;       (use "Truth")
;;     (assume 1)
;;   (simprat 3)
;;   (simprat 3)
;;   (use "Truth")
;;   (assume "p" "q" "b" "c")
;;   (ng #t)
;;   (use "Efq")
;; (save "RatLeTimesCancelLInv")

(set-goal "all a((0 <= a -> F) -> abs a = ~a)")
  (cases)
  (cases)
  (ng #t)
  (assume "p" "q")
  (assume "Cond")
  (use "Cond")
  (use "Truth")
  (assume "q")
  (ng #t)
  (assume "Cond")
  (use "Truth")
  (assume "p" "q" "Cond")
  (use "Truth")
(save "RatAbsNegId")

(set-goal "all a (~a <= abs a)")
  (cases)
  (cases)
  (ng #t)
  (assume "p" "q")
  (use "Truth")
  (assume "q")
  (use "Truth")
  (assume "p" "q")
  (use "Truth")
(save "RatNegLeAbsTaut")
(add-rewrite-rule "~a <= abs a" "T")

(set-goal "all a,b(a+ ~(a max b) = ~(abs (a+ ~(a max b))))")
  (cases)
  (cases)
  (assume "p1" "q1")
  (cases)
  (cases)
  (assume "p2" "q2")
  (ng #t)
  (cases (pt "p2*q1<=p1*q2"))
  (assume "C1")
  (ng #t)
  (use "Truth")
  (assume "nC1")
  (ng #t)
  (cases (pt "p1*q2=p2*q1"))
  (assume "C2")
  (ng #t)
  (use "Truth")
  (assume "nC2")
  (ng #t)
    (assert "p1*q2<p2*q1")
      (use "PosNotLeToLt")
      (use "nC1")
    (assume "C3")
  (simp "C3")
  (ng #t)
  (use "Truth")
  (assume "q2")
  (ng #t)
  (use "Truth")
  (assume "p2" "q2")
  (ng #t)
  (use "Truth")
  (assume "q")
  (cases)
  (cases)
  (ng #t)
  (assume "p2" "q2")
  (use "Truth")
  (assume "q2")
  (ng #t)
  (use "Truth")
  (auto)
  (assume "p1" "q1")
  (cases)
  (cases)
  (auto)
  (assume "p2" "q2")
  (ng #t)
  (cases (pt "p1*q2<=p2*q1"))
  (assume "C1")
  (ng #t)
  (use "Truth")
  (assume "nC1")
  (ng #t)
  (cases (pt "p1*q2=p2*q1"))
  (assume "C2")
  (ng #t)
  (use "Truth")
  (assume "nC2")
  (ng #t)
    (assert "p1*q2<p2*q1->F")
      (use "PosLtToNotLt")
      (use "PosNotLeToLt")
      (use "nC1")
    (assume "C3")
  (simp "C3")
  (ng #t)
  (use "Truth")
(save "RatMaxLemma1")

;;(add-program-constant "RatToNat" (py "rat=>nat"))
;;(add-computation-rule "RatToNat (i#p)" "DivInt (IntToNat (abs i)) (IntToNat (abs i)) (PosToNat p)")
;;
;;(set-totality-goal "RatToNat")
;;  (assume "a^" "Ta")
;;  (elim "Ta")
;;  (assume "k^" "Tk" "p^" "Tp")
;;  (ng #t)
;;  (use "DivIntTotal")
;;  (use "IntToNatTotal")
;;  (use "IntAbsTotal")
;;  (use "Tk")
;;  (use "IntToNatTotal")
;;  (use "IntAbsTotal")
;;  (use "Tk")
;;  (use "PosToNatTotal")
;;  (use "Tp")
;;(save-totality)

(add-program-constant "RatQR" (py "rat=>(int yprod int)"))
(add-computation-rules
  "RatQR (p1#p2)" "PosQR p1 p2"
  "RatQR ((IntNeg p1)#p2)" "(~lft(PosQR p1 p2) pair rht(PosQR p1 p2))"
  "RatQR (IntZero#p)" "(IntZero pair IntZero)"
)

(set-totality-goal "RatQR")
  (use "AllTotalElim")
  (cases)
  (cases)
  (assume "p" "q")
  (ng #t)
  (use "PosQRTotal")
  (use "PosTotalVar")
  (use "PosTotalVar")
  (assume "q")
  (ng #t)
  (use "TotalYprodPairConstr")
  (use "IntTotalVar")
  (use "IntTotalVar")
  (assume "p" "q")
  (ng #t)
  (use "YprodTotalVar")
(save-totality)

(set-goal "all a,b(a==b-> a<=b)")
  (assume "a" "b")
  (assume "s")
  (simprat "s")
  (use "Truth")
(save "RatEqToLe")

(set-goal "all a((a*(0#1) == 0 ))")
  (cases)
  (assume "k" "p")
  (ng #t)
  (auto)
(save "RatTimesZero")

(set-goal "all a,b((0#1) <= b -> abs a*b==abs(a*b))")
  (cases)
  (cases)
  (assume "p1" "q1")
  (cases)
  (cases)
  (assume "p2" "q2")
  (ng #t)
  (assume 1)
  (use 1)
  (assume "q2")
  (ng #t)
  (assume 1)
  (use 1)
  (assume "p2" "q2")
  (ng #t)
  (assume 1)
  (use 1)
  (assume "q1")
  (assume "b")
  (ng #t)
  (assume 1)
    (assert "all c,r((0#r)*c == (0#1))")
      (cases)
      (ng #t)
      (assume "k" "q3" "r")
      (use "Truth")
    (assume "Ass1")
  (simprat "Ass1")
  (use "Truth")
  (assume "p1" "q1")
  (cases)
  (cases)
  (assume "p2" "q2")
  (ng #t)
  (auto)
(save "RatAbsTimesPosDist")

(set-goal "all a,b(a <= (0#1) -> ~a*abs b == abs(a*b))")
  (cases)
  (cases)
  (assume "p1" "q1")
  (cases)
  (cases)
  (assume "p2" "q2")
  (auto)
  (assume "q1" "b")
  (assume 1)
    (assert "all c,r((0#r)*c == (0#1))")
      (cases)
      (ng #t)
      (assume "k" "q3" "r")
      (use "Truth")
    (assume "Ass1")
    (assert "all r((0#r) == ~(0#r))")
      (ng #t)
      (assume "r")
      (use "Truth")
    (assume "Ass2")
  (simprat "<-" "Ass2")
  (simprat "Ass1")
  (simprat "Ass1")
  (use "Truth")
  (assume "p1" "q1")
  (cases)
  (cases)
  (assume "p2" "q2")
  (auto)
(save "RatAbsTimesNegDist")

(set-goal "all a,b(a<=b->(b < a ->F))")
  (cases)
  (cases)
  (assume "p1" "q1")
  (cases)
  (cases)
  (assume "p2" "q2")
  (ng #t)
  (assume "Cond1")
  (use "PosLeToNotLt")
  (use "Cond1")
  (assume "q2")
  (ng #t)
  (assume 1 1)
  (use 1)
  (assume "p2" "q2")
  (ng #t)
  (assume 1 1)
  (use 1)
  (assume "q1")
  (cases)
  (assume "k2" "q2")
  (assume "Cond1")
  (use "IntLeToNotLt")
  (use "Cond1")
  (assume "p1" "q1")
  (cases)
  (ng #t)
  (assume "k2" "q2")
  (assume "Cond1")
  (use "IntLeToNotLt")
  (use "Cond1")
(save "RatLeToNotLt")

(set-goal "all a,b(a<b->(b <= a ->F))")
  (cases)
  (assume "k1" "q1")
  (cases)
  (assume "k2" "q2")
  (ng #t)
  (assume "Cond1")
  (use "IntLtToNotLe")
  (use "Cond1")
(save "RatLtToNotLe")

(set-goal "all a,b(b<=a -> a max b = a)")
  (cases)
  (cases)
  (assume "p1" "q1")
  (cases)
  (cases)
  (assume "p2" "q2")
  (ng #t)
  (assume "Case")
  (simp "Case")
  (use "Truth")
  (ng #t)
  (assume "p")
  (auto)
  (assume "q1")
  (cases)
  (cases)
  (assume "p2" "q2")
  (ng #t)
  (auto)
  (assume "p1" "q1")
  (cases)
  (cases)
  (ng #t)
  (auto)
  (assume "p2" "q2")
  (ng #t)
  (assume "Case")
  (simp "Case")
  (use "Truth")
(save "RatMaxCaseL")

(set-goal "all a,b(a<b -> a max b = b)")
  (cases)
  (assume "k1" "q1")
  (cases)
  (assume "k2" "q2")
  (ng #t)
  (assume "Cond1")
    (assert "k2*q1<=k1*q2 -> F")
      (use "IntLtToNotLe")
      (use "Cond1")
    (assume "A1")
  (simp "A1")
  (use "Truth")
(save "RatMaxCaseR")

(set-goal "all a(a max a = a)")
  (cases)
  (assume "k1" "q1")
  (ng #t)
  (use "Truth")
(save "RatMaxId")
(add-rewrite-rule "a max a" "a")

(set-goal "all a,b(a <= b -> (a == b -> F) -> a < b)")
  (cases)
  (assume "k1" "q1")
  (cases )
  (assume "k2" "q2")
  (ng #t)
  (assume "Cond1" "Cond2")
  (use "IntLtCases")
  (use "Cond1")
  (simp "IntEqSym")
  (use "Cond2")
(save "RatLtCases")

(set-goal "all a,b,c((0#1) <= a -> (a*b < a*c) -> (b<c))")
  (cases)
  (cases)
  (assume "p1" "q1")
  (cases)
  (cases)
  (assume "p2" "q2")
  (cases)
  (cases)
  (assume "p3" "q3")
  (ng #t)
  (assume 1 1) 
  (simp "<-" "PosLtTimesCancelL" (pt "p1"))
  (ng #t)
  (simp "PosTimesComm" (pt "p1*p2") (pt "q3"))
  (simp-with "PosTimesComm" (pt "p1*p3") (pt "q2"))
  (ng #t)
  (simp "<-" "PosLtTimesCancelL" (pt "q1"))
  (ng #t)
  (simp-with "PosTimesComm" (pt "q1*q3") (pt "p1*p2"))
  (simp-with "PosTimesComm" (pt "q1*q2") (pt "p1*p3"))
  (use 2)
  (assume "q3")
  (ng #t)
  (assume 1 1)
  (use 2)
  (assume "p3" "q3")
  (ng #t)
  (assume 1 1)
  (use 2)
  (assume "p")
  (cases)
  (cases)
  (auto)
  (ng #t)
  (assume "p2" "q2")
  (cases)
  (cases)
  (ng #t)
  (auto)
  (assume "p3" "q3")
  (ng #t)
  (assume 1 1)
  (simp "<-" "PosLtTimesCancelL" (pt "p1"))
  (ng #t)
  (simp-with "PosTimesComm" (pt "p1*p3") (pt "q2"))
  (ng #t)
  (simp-with "PosTimesComm" (pt "p1*p2") (pt "q3"))
  (ng #t)
  (simp "<-" "PosLtTimesCancelL" (pt "q1"))
  (ng #t)
  (simp-with "PosTimesComm" (pt "q1*q2") (pt "p1*p3"))
  (ng #t)
  (simp-with "PosTimesComm" (pt "q1*q3") (pt "p1*p2"))
  (use 2)
  (ng #t)
  (assume "q1")
  (cases)
  (assume "k2" "q2")
  (cases)
  (assume "k3" "q3")
  (ng #t)
  (assume 1)
  (use "Efq")
  (ng #t)
  (assume "p1" "q1" "b" "c")
  (use "Efq")
(save "RatLtTimesCancelL")

(set-goal "all a,b (abs(a+ ~a)<=b)=(0<=b)")
  (assume "a" "b")
  (use "BooleAeqToEq")
  (assume "Rel")
  (use "RatLeTrans" (pt "abs (a+ ~a)"))
  (simprat (pf "a+ ~a==(0#1)"))
  (use "Truth")
  (use "Truth")
  (use "Rel")
  (assume "Rel")
  (simprat (pf "a+ ~a == (0#1)"))
  (use "Rel")
  (use "Truth")
(add-rewrite-rule "abs(a+ ~a)<=b" "0<=b")
(save "RatAbsIdMinusZero")

(set-goal "all p,q(p<q->lft (PosQR p q) = 0)")
  (ind)
  (cases)
  (ng #t)
  (use "Efq")
  (assume "p")
  (ng #t)
  (assume 1)
  (use 1)
  (assume "p")
  (ng #t)
  (assume 1)
  (use 1)
  (assume "p" "IH" "q")
  (ng #t)
  (assume "Case")
  (cases (pt "PosQR p q"))
  (assume "k1" "k2" "c1")
  (ng #t)
  (cases (pt "2*k2<q"))
  (assume "c2")
  (ng #t)
  (simp (pf "k1 = lft(RatQR(p#q))"))
  (simp "IntEqSym")
  (simp (pf "0 = 2*0"))
  (inst-with-to "IntEqTimesCancelL" (pt "IntPos 2") (pt "IntZero") (pt "lft(RatQR(p#q))") "TimeEl")
  (simp "TimeEl")
  (simp "IntEqSym")
  (use "IH")
  (use "PosLtTrans" (pt "SZero p"))
  (use "Truth")
  (use "Case")
  (use "Truth")
  (use "Truth")
  (ng #t)
  (simp "c1")
  (use "Truth")
  (assume "nc2")
  (ng #t)
    (assert "k1 = 0")
      (simp (pf "k1 = lft(RatQR(p#q))"))
      (use "IH")
      (use "PosLtTrans" (pt "(SZero p)"))
      (use "Truth")
      (use "Case")
      (ng #t)
      (simp "c1")
      (use "Truth")
    (assume "ass1")
  (simp "ass1")
  (ng #t)
  (use "nc2")
    (assert "p = lft(PosQR p q)*q+rht(PosQR p q)")
      (use "IntPosQRRWRule")
    (assume "ass2")
  (simphyp-with "ass2" "c1")
  (ng 7)
  (simphyp-with 7 "ass1")
  (ng 8)
  (simp "<-" 8)
  (ng #t)
  (use "Case")
  (assume "p")
  (assume "IH")
  (assume "q")
  (ng #t)
  (assume "Case")
  (cases (pt "PosQR p q"))
  (assume "k1" "k2")
  (ng #t)
  (assume "c1")
  (cases (pt "2*k2+1<q"))
  (assume "c2")
  (ng #t)
  (simp (pf "k1 = lft(RatQR(p#q))"))
  (simp "IntEqSym")
  (simp (pf "0 = 2*0"))
  (inst-with-to "IntEqTimesCancelL" (pt "IntPos 2") (pt "IntZero") (pt "lft(RatQR(p#q))") "TimeEl")
  (simp "TimeEl")
  (simp "IntEqSym")
  (use "IH")
  (use "PosLtTrans" (pt "SOne p"))
  (use "Truth")
  (use "Case")
  (use "Truth")
  (use "Truth")
  (ng #t)
  (simp "c1")
  (use "Truth")
  (assume "nc2")
  (ng #t)
    (assert "k1 = 0")
      (simp (pf "k1 = lft(RatQR(p#q))"))
      (use "IH")
      (use "PosLtTrans" (pt "SOne p"))
      (use "Truth")
      (use "Case")
      (ng #t)
      (simp "c1")
      (use "Truth")
    (assume "ass1")
  (simp "ass1")
  (ng #t)
  (use "nc2")
    (assert "p = lft(PosQR p q)*q+rht(PosQR p q)")
      (use "IntPosQRRWRule")
    (assume "ass2")
  (simphyp-with "ass2" "c1")
  (ng 7)
  (simphyp-with 7 "ass1")
  (ng 8)
  (simp "<-" 8)
  (ng #t)
  (use "Case")
(save "IntPosQRK1EqZero")

(set-goal "all p,q(p<q-> ~lft (PosQR p q) = 0)")
  (assume "p" "q" "Cond")
  (use "IntEqZeroLM1")
  (use "IntPosQRK1EqZero")
  (use "Cond")
(save "IntNegQRK1EqZero")

(set-goal "all k,q(abs k < q -> lft(RatQR(k#q)) = 0)")
  (cases)
  (ng #t)
  (use "IntPosQRK1EqZero")
  (ng #t)
  (assume "q")
  (assume 1)
  (use 1)
  (ng #t)
  (assume "p" "q" "Cond")
  (use "IntNegQRK1EqZero")
  (use "Cond")
(save "RatQRK1EqZero")

(set-goal "all b,a,c((IntZero#One)<=b -> a*b<c*b -> a<c)")
(assume "b" "a" "c")
(simp "RatTimesComm")
(simp (pf "c*b=b*c"))
(use "RatLtTimesCancelL")
(use "RatTimesComm")
;; Proof finished.
(save "RatLtTimesCancelR")

(set-goal "all a (0<a -> 0<RatUDiv a)")
(cases)
(cases)
(assume "p" "p0")
(ng #t)
(auto)
(save "ZeroLtToZeroLtRatUDiv")


(set-goal "all a ~(a*0)==0")
(cases)
(cases)
(ng #t)
(auto)
(add-rewrite-rule "~(a*0)==0" "True")

(set-goal "all a 0*abs a==0")
(cases)
(cases)
(ng #t)
(auto)
(add-rewrite-rule "0*abs a==0" "True")



(set-goal "all a a*0==0")
(cases)
(cases)
(assume "p" "p0")
(ng #t)
(auto)
(add-rewrite-rule "a*0==0" "True")


;;(set-goal "all a abs(a*0)==0")


(set-goal "all a (a*(0#1) == (0#1))")
(cases)
(ng #t)
(assume "k" "p")
(use "Truth")
(add-rewrite-rule "a*(0#1)== (0#1)" "True")

(set-goal "all a ( (a**1)==a)")
(cases)
(ng #t)
(assume "k" "p")
(use "Truth")
(add-rewrite-rule "(a**1)==a" "True")


(set-goal "all a,b ( (a+b)*(a+b)==a**2 + 2*a*b +b**2)")
(assume "a" "b")
(simprat "RatTimesPlusDistrLeft")
(ng #t)
(simprat "RatTimesPlusDistr")
(simprat "RatTimesPlusDistr")
(ng #t)
(use "RatEqvPlusCancelL" (pt "~(a**2)"))
(ng #t)
(simprat (pf "~(a**2)+a**2==0"))
(simprat (pf "~(a**2)+a*a==0"))
(ng #t)
(use "RatEqvPlusCancelR" (pt "~(b**2)"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "b*b+ ~(b**2)==0")) 
(ng #t)
(simp "<-" "RatPlusAssoc")
(simprat (pf "b**2+ ~(b**2)==0"))
(ng #t)
(simp "RatTimesComm")
(simprat (pf "b*a+b*a==2*b*a"))
(use "RatEqvTimesCancelL" (pt "(1#2)"))
(auto)
(ng #t)
(simp "RatTimesComm")
(auto)
(inst-with-to "RatPlusIdEqvTimesTwo" (pt "b*a") "RatInst")
(auto)
(inst-with-to "RatExpPosS" (pt "b" ) (pt "1") "RatInst2")
(simprat "RatInst2")
(simprat (pf "b**1==b"))
(ng #t)
(auto)
(inst-with-to "RatExpPosS" (pt "a" ) (pt "1") "RatInst")
(simprat "RatInst")
(auto)
(simprat (pf "a**1==a"))
(auto)
(save "RatBinomForm1")

(set-goal "all a,b ( (a-b)*(a-b)==a**2 - 2*a*b +b**2)")
(assume "a" "b")
(ng #t)
(simprat "RatTimesPlusDistrLeft")
(ng #t)
(simprat "RatTimesPlusDistr")
(simprat "RatTimesPlusDistr")
(ng #t)
(use "RatEqvPlusCancelL" (pt "~(a**2)"))
(ng #t)
(simprat (pf "~(a**2)+a**2==0"))
(simprat (pf "~(a**2)+a*a==0"))
(ng #t)
(use "RatEqvPlusCancelR" (pt "~(b**2)"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "b*b+ ~(b**2)==0"))
(ng #t)
(simp "RatTimesComm")
(simprat (pf "~(b*a)+ ~(b*a)== ~(2*b*a)"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "b**2+ ~(b**2)==0")) 
(use "RatEqvTimesCancelL" (pt "(1#2)"))
(auto)
(ng #t)
(simp "RatTimesComm")
(auto)
(inst-with-to "RatPlusIdEqvTimesTwo" (pt "~(b*a)") "RatInst")
(simprat "RatInst")
(ng #t)
(auto)
(inst-with-to "RatExpPosS" (pt "b" ) (pt "1") "RatInst")
(simprat "RatInst")
(simprat (pf "b**1==b"))
(ng #t)
(auto)
(inst-with-to "RatExpPosS" (pt "a" ) (pt "1") "RatInst")
(simprat "RatInst")
(simprat (pf "a**1==a"))
(auto)
(save "RatBinomForm2")


(set-goal "all a,b( (a*b)**2==a**2*b**2)")
(assume "a" "b")
(inst-with-to "RatExpPosS" (pt "a*b" ) (pt "1") "RatInst")
(simprat "RatInst")
(inst-with-to "RatExpPosS" (pt "a" ) (pt "1") "RatInst2")
(simprat "RatInst2")
(inst-with-to "RatExpPosS" (pt "b" ) (pt "1") "RatInst3")
(simprat "RatInst3")
(ng #t)
(use "RatTimesCompat")
(simp "RatTimesComm")
(ng #t)
(simprat (pf "(a*b)**1==a*b"))
(simprat (pf "(a)**1==a"))
(simprat (pf "(b)**1==b"))
(auto)
(save "RatExpTwoRewRule1")

(set-goal "all a,b( a<=b -> abs(b+ ~a)==b+ ~a)")
(assume "a" "b")
(assume "a<=b")
(inst-with-to "RatAbsId" (pt "b+ ~a") "RatAbsIdInst")
(simp "RatAbsIdInst")
(auto)
(use "RatLePlusCancelR" (pt "a"))
(ng #t)
(simp "<-" "RatPlusAssoc")
(simprat (pf "~a+a==0"))
(auto)
(save "RatAbsId2")


(set-goal "all a,b( b<=a -> abs(b+ ~a)==a + ~b)")
(assume "a" "b")
(assume "b<=a")
(inst-with-to "RatAbsUMinusAbsId" (pt "b+ ~a") "RatInst")
(simp "<-" "RatInst")
(ng #t)
(simp "RatPlusComm")
(use "RatAbsId2")
(auto)
(save "RatAbsId3")


(set-goal "all m,n (m<=n -> (1#2**n) <= (1#2**m))")
(assume "m")
(ind)
(ng #t)
(assume "m=Zero")
(simp "m=Zero")
(ng #t)
(auto)
(assume "n" "Ih")
(assume "cond")
(ng #t)
(ng "Ih")
(use "NatLeCases" (pt "m") (pt "Succ n"))
(auto)
(ng #t)
(assume "m<=n")
(use "PosLeTrans" (pt "2**n"))
(use "Ih")
(auto)
(assume "m=n")
(simp "m=n")
(auto)
(save "NatExpLe")


(set-goal "all m,n ((1#2**n)*(1#2**m)==(1#2**(n+m)))")
(assume "m")
(ind)
(ng #t)
(auto)
(save "NatExpPlus")


(set-goal "all a,n( abs(a) <= 2**n -> (1#2**n)*abs(a) <= 1 )")
(assume "a")
(assume "n")
(assume "cond")
(use "RatLeTimesCancelL" (pt "(2**n#1)"))
(auto)
(ng #t)
(simprat (pf "(2**n#2**n)==1"))
(auto)
(save "NatExpBound1")


(set-goal "all a,b,c (c<=a -> c<=b -> c<= a min b)")
(cases)
(assume "k" "p") 
(cases)
(assume "k0" "p0")
(cases)
(assume "k1" "p1")
(ng #t)
(assume "1" "2")
(cases (pt "k*p0<=k0*p"))
(assume "case1")
(ng #t)
(auto)
(save "RatMinLB")


(set-goal "all a(0<a -> 0 < RatUDiv a)")
(cases)
(cases)
(assume "p" "q")
(ng #t)
(auto)
(save "RatUDivPosToRatPostwo")

(set-goal "all a (0<a -> ex p((1#2**p)<=a)) ")
(cases)
(cases)
(ng #t)
(cases)
(cases)
(assume "T")
(ex-intro (pt "One"))
(ng #t)
(use "Truth")
(assume "p")
(assume "T")
(ng #t)
(ex-intro (pt "p"))
(ng #t)
(use "SZeroPosLePosExp")
(assume "p" "T")
(ng #t)
(ex-intro (pt "SZero p"))
(inst-with-to "SZeroPosLePosExp" (pt "SOne p") "Inst")
(ng "Inst")
(ng #t)
(use "Inst")
(assume "p" "p0")
(ng #t)
(assume "T")
(ex-intro (pt "p0"))
(use "PosLeTrans" (pt "2**p0"))
(use "PosLtToLe")
(ng #t)
(use "Truth")
(use "PosLeTrans" (pt "p*2**p0"))
(use "PosLeTrans" (pt "One*2**p0"))
(use "Truth")
(use "PosLeMonTimes")
(use "Truth")
(use "Truth")
(use "Truth")
(assume "p" "p0")
(ng #t)
(assume "T")
(ex-intro (pt "p0"))
(use "PosLeTrans" (pt "2**p0"))
(use "PosLtToLe")
(use "Truth")
(use "Truth")
(assume "p")
(ng #t)
(use "Efq")
(assume "p")
(assume "p0")
(ng #t)
(use "Efq")
(save "RatToPosZeroLB")


(set-goal "all a (a*a==a**2)")
(assume "a")
(inst-with-to "RatExpPosS" (pt "a") (pt "1") "RatInst")
(use "RatEqvSym")
(use "RatEqvTrans" (pt "a**PosS 1"))
(auto)
(use "RatEqvTrans" (pt "a**1*a"))
(auto)
(simprat (pf "a**1==a"))
(auto)
(save "RatExpTwoE")


(set-goal "all a (ex b a==b)")
(assume "a")
(ex-intro (pt "a"))
(auto)
(save "RatSubVar")

(set-goal "all a,b,c,c1 abs(a+ ~b)<=abs(a+ ~c)+abs(c+ ~c1)+abs(c1+ ~b)")
 (assume "a1" "b1" "c" "c1")
 (use "RatLeTrans" (pt "abs(a1+ ~c1)+abs(c1+ ~b1)"))
 (use "RatLeAbsMinus")
 (use "RatLeMonPlus")
 (use "RatLeAbsMinus")
 (use "Truth")
(save "RatInvTriangle2")

(set-goal "all a,b,c,c1,d (abs(a+ ~c)+abs(c+ ~c1)+abs(c1+ ~b)<=d -> abs(a+ ~b)<=d)")
(assume "a" "b" "c" "c1" "d")
(assume "cond")
(use "RatLeTrans" (pt "abs(a+ ~c)+abs(c+ ~c1)+abs(c1+ ~b)"))
(use "RatInvTriangle2")
(auto)
(save "RatInvTriangle2Inj")



(set-goal "all a,b (abs(a)<=b -> ~ b <= a & a <= b)")
(assume "a" "b" "cond")
(split)
(use "RatLeUMinusToLeSwitch")
(ng #t)
(use "RatLeTrans" (pt "abs a"))
(use "RatAbsInvLeqAbs")
(auto)
(use "RatLeTrans" (pt "abs(a)"))
(auto)
(save "RatAbsLeCases")


(set-goal "all a,b ( ~ b <= a -> a <= b -> abs(a)<=b)")
(assume "a" "b")
(assume "cond1" "cond2")
(simp "RatAbsMax")
(use "RatMaxLUB")
(auto)
(use "RatLeUMinusToLeSwitch")
(ng #t)
(auto)
(save "RatAbsLeCases2")


(set-goal "all a,b,c,c1( abs(a+ (~c))+abs(c+ (~b)) <= c1 -> abs(a+(~b)) <=c1)")
(auto)
(assume "a" "b" "c" "d")
(assume "1")
(use "RatLeTrans" (pt "abs(a+ ~c)+abs(c+ ~b)"))
(auto)
(save "RatAbsPlusMinusA")


(set-goal "all a,b (0<abs(a) -> 0<abs(b) -> 1/a+ ~(1/b)==(b+ ~a)/(a*b))")
(strip)
(ng #t)
(simprat  "RatTimesPlusDistrLeft")
(ng #t)
(simprat "RatUDivTimes")
(ng #t)
(simprat (pf "b*RatUDiv a*RatUDiv b==RatUDiv a"))
(simprat (pf "a*RatUDiv a*RatUDiv b==RatUDiv b"))
(auto)
(simprat (pf "a*RatUDiv a==1"))
(auto)
(use "RatTimesUDivR")
(auto)
(simp "RatTimesComm")
(ng #t)
(simprat (pf "RatUDiv b*b==1"))
(auto)
(simp "RatTimesComm")
(use "RatTimesUDivR")
(auto)
(save "RatUDivPlusUMinus")

(set-goal "all a(0<=a -> 0 <= RatUDiv a)")
(cases)
(cases)
(assume "p" "q")
(ng #t)
(assume 1)
(use 1)
(assume "q")
(ng #t)
(assume 1)
(use 1)
(assume "p" "q")
(ng #t)
(assume 1)
(use 1)
(save "RatNNegToRatUDivNNeg")


(set-goal "all a,b(abs(a+ ~b) == abs(b + ~a))")
(cases)
(assume "k" "p0")
(cases)
(assume "k1" "p1")
(ng #t)
(use "IntLeAntiSym")
(simp "<-" "IntTimesAssoc")
(simp (pf "IntTimes p1 p0=IntTimes p0 p1"))
(ng)
(use "IntLeRefl")
(use "IntAbsPlusMinusComm")
(ng #t)
(use "PosTimesComm")
(simp "<-" "IntTimesAssoc")
(simp (pf "IntTimes p0 p1=IntTimes p1 p0"))
(ng #t)
(use "IntLeRefl")
(use "IntAbsPlusMinusComm")
(ng #t)
(use "PosTimesComm")
(save "RatAbsPlusMinusComm")


(set-goal "all a,b( 0<=a -> a<=b -> abs(a)<=abs(b))")
(assume "a" "b")
(assume "0<=a")
(assume "a<=b")
(simp "RatAbsId")
(use "RatLeTrans" (pt "b"))
(auto)
(save "RatLeAbsCompat")

(set-goal "all a,b (a max b =a oru a max b = b)")
(assume "a" "b")
(cases (pt "a<b"))
(assume "case")
(intro 1)
(use "RatMaxCaseR")
(auto)
(assume "case2")
(intro 0)
(use "RatMaxCaseL")
(use "RatNotLtToLe")
(auto)
(save "RatMaxCases")



(set-goal "all a,b,c (a max b + c=(a + c) max (b + c))")
(assume "a" "b" "c") 
(inst-with-to "RatMaxCases" (pt "a") (pt "b") "RatInst")
(cases (pt "a<b"))
(assume "case1")
(simp "RatMaxCaseR")
(cut "a+c<b+c")
(assume "case11")
(simp "RatMaxCaseR")
(auto)
(assume "case2")
(simp "RatMaxCaseL")
(cut "b+c<=a+c")
(assume "case22")
(simp "RatMaxCaseL")
(auto)
(use "RatLeMonPlus")
(use "RatNotLtToLe")
(auto)
(use "RatNotLtToLe")
(auto)
(save "RatMaxDistrPlus")

(set-goal "all a,b(a<=b -> a min b = a)")
  (cases)
  (cases)
  (assume "p1" "q1")
  (cases)
  (cases)
  (assume "p2" "q2")
  (ng #t)
  (assume "Case")
  (simp "Case")
  (use "Truth")
  (ng #t)
  (assume "p")
  (auto)
  (assume "q1")
  (cases)
  (cases)
  (assume "p2" "q2")
  (ng #t)
  (auto)
  (assume "p1" "q1")
  (cases)
  (cases)
  (ng #t)
  (auto)
  (assume "p2" "q2")
  (ng #t)
  (assume "Case")
  (simp "Case")
  (use "Truth")
(save "RatMinCaseL")

(set-goal "all a,b(b<a -> a min b = b)")
  (cases)
  (assume "k1" "q1")
  (cases)
  (assume "k2" "q2")
  (ng #t)
  (assume "Cond1")
    (assert "k1*q2<=k2*q1 -> F")
      (use "IntLtToNotLe")
      (use "Cond1")
    (assume "A1")
  (simp "A1")
  (use "Truth")
(save "RatMinCaseR")


(set-goal "all a,b ( ~(a max b) = (~a) min (~b))")
(assume "a" "b")
(cases (pt "a<b"))
(assume "case")
(simp "RatMaxCaseR")
(simp "RatMinCaseR")
(auto)
(assume "case2")
(cut "b<=a")
(assume "case2m")
(simp "RatMaxCaseL")
(simp "RatMinCaseL")
(auto)
(use "RatNotLtToLe")
(auto)
(save "RatMinMaxDeMorgan1")



(set-goal "all a,b ( ~(a min b) = (~a) max (~b))")
(assume "a" "b")
(cases (pt "b<a"))
(assume "case")
(simp "RatMaxCaseR")
(simp "RatMinCaseR")
(auto)
(assume "case2")
(simp "RatMaxCaseL")
(simp "RatMinCaseL")
(auto)
(use "RatNotLtToLe")
(auto)
(ng #t)
(use "RatNotLtToLe")
(auto)
(save "RatMinMaxDeMorgan2")


(set-goal "all a,b,c (c + a min b=(c + a) min (c + b))")
(assume "a" "b" "c")
(cases (pt "a<=b"))
(assume "case")
(simp "RatMinCaseL")
(cut "c+a<=c+b")
(assume "case12")
(simp "RatMinCaseL")
(auto)
(assume "case2")
(cut "b<a")
(assume "case2m")
(simp "RatMinCaseR")
(cut "c+b<c+a")
(assume "case2mc")
(simp "RatMinCaseR")
(auto)
(use "RatNotLeToLt")
(auto)
(save "RatMinDistrPlus")

(set-goal "all a,b (abs(a max b)<=abs(a) max (abs b))")
(assume "a" "b")
(simp "RatAbsMax")
(use "RatMaxLUB")
(use "RatMaxLUB")
(use "RatLeTrans" (pt "abs a"))
(auto)
(use "RatMaxUB1")
(use "RatLeTrans" (pt "abs b"))
(auto)
(use "RatMaxUB2")
(ng #t)
(simp "RatMinMaxDeMorgan1")
(use "RatLeTrans" (pt "~a"))
(use "RatMinLB1")
(use "RatLeTrans" (pt "abs a"))
(auto)
(use "RatMaxUB1")
(save "RatAbsMax2")




(set-goal "all a,b,c,d ( abs(a max b - c max d)<= abs(a - c ) max abs(b - d ))")
(assume "a" "b" "c" "d")
(simp "RatAbsMax")
(use "RatMaxLUB")
(ng #t)
(simp "RatMaxDistrPlus")
(use "RatMaxLUB")
(use "RatLeTrans" (pt "a + ~c"))
(ng #t)
(use "RatMaxUB1")
(use "RatLeTrans" (pt "abs(a + ~c)"))
(auto)
(use "RatMaxUB1")
(use "RatLeTrans" (pt "b + ~d"))
(ng #t)
(use "RatMaxUB2")
(use "RatLeTrans" (pt "abs(b + ~d)"))
(auto)
(use "RatMaxUB2")
(ng #t)
(simp "RatPlusComm")
(simp "RatMaxDistrPlus")
(use "RatMaxLUB")
(use "RatLeTrans" (pt "c + ~a"))
(ng #t)
(use "RatMaxUB1")
(use "RatLeTrans" (pt "abs(c + ~a)")) 
(auto)
(use "RatLeTrans" (pt "abs(a + ~c)"))
(simprat "RatAbsPlusMinusComm")
(auto)
(use "RatMaxUB1")
(use "RatLeTrans" (pt "abs(d + ~b)"))
(use "RatLeTrans" (pt "d + ~b"))
(ng #t)
(use "RatMaxUB2")
(auto)
(simprat "RatAbsPlusMinusComm")
(use "RatMaxUB2")
(save "RatMaxTriangleRev")


(set-goal "all a ex b a=b")
(assume "a")
(ex-intro "a")
(auto)
(save "RatSubVarEq")



(set-goal "all a(a<0 -> abs a= ~a)")
(cases)
(cases)
(assume "p" "p0")
(ng #t)
(use "Efq")
(assume "p")
(ng #t)
(auto)
;; Proof finished.
(save "RatAbsIdUMinus")




(set-goal "all k exl p (1#2**p)<=(1#2)**k ")
(cases)
(assume "p")
(intro 0 (pt "p"))
(use "Truth")
(intro 0 (pt "One"))
(ng #t)
(use "Truth")
(assume "p")
(intro 0 (pt "One"))
(ng #t)
(use "Truth")
(save "EpsPosBoundEpsInt")



(set-goal "all p ex n RatLe p n")
(assert "all n0 n0+n0=IntPlus n0 n0")
(ind)
(auto)
(assume "n" "Ih0")
(ng #t)
(use "IntPredInj")
(ng #t)
(use "IntPredInj")
(ng #t)
(use "Ih0")
(assume "Assertion")
(ind)
(ex-intro (pt "Succ Zero")) 
(auto)
(assume "p" "Ih")
(by-assume "Ih" "n0" "NoProp")
(ex-intro "(n0 + n0)")
(use "RatLeTrans" (pt "RatPlus p p"))
(simp "IntPSZero")
(auto)
(simprat (pf "n0+n0==RatPlus n0 n0"))
(use "RatLeMonPlus")
(use "NoProp")
(use "NoProp")
(simp "NatToIntAux")
(ng #t)
(use "Assertion")
(assume "p" "Ih")
(by-assume "Ih" "n0" "NoProp")
(ex-intro "1+n0 + n0")
(use "RatLeTrans" (pt "RatPlus One (RatPlus p p)"))
(ng #t)
(use "Truth")
(simp "<-" "RatPlusAssoc")
(simp "<-" "RatPlusAssoc")
(use "RatLeTrans" (pt "(1#1)+(n0+n0)"))
(use "RatLeMonPlus")
(auto)
(simprat (pf "n0+n0==RatPlus n0 n0"))
(use "RatLeMonPlus")
(auto)
(save "PosToNatBound")


(set-goal "all c,a,b( c<=a max b -> c<=a ori c<=b)")
(assume "c" "a" "b")
(assume "MaxCond")
(inst-with-to "RatMaxCases" (pt "a") (pt "b") "Inst")
(elim "Inst")
(assume "case")
(intro 0)
(simp "<-" "case")
(auto)
(assume "case")
(intro 1)
(simp "<-" "case")
(auto)
(save "RatMaxLeToOrRev")



;; (from minlog HEAD)
(set-goal "all p,q exl n((p#q)<=2**n andnc all m((p#q)<=2**m -> n<=m))")
(assume "p" "q")
(intro 0 (pt "NatLeast (cRatLeBound p q) ([n](p#q)<=2**n)"))
(split)
;; 18,19
(assert "(p#q)<=2**(cRatLeBound p q) ")
(use "RatLeBoundExFree")
;; Assertion proved.
(assume "pqBd")
(inst-with-to
 "PropNatLeast" (pt "cRatLeBound p q") (pt "cRatLeBound p q") (pt "([n](p#q)<=2**n)")
 "Truth" "pqBd" "Inst")
(use "Inst")
;; 19
(assume "m" "pqBd")
(use "NatLeastLeIntro")
(use "pqBd")
;; Proof finished.
;; (cp)
(save "RatLeBoundSharp")

;; (from minlog HEAD)
(set-goal "all a exl n(abs a<=2**n andnc all m(abs a<=2**m -> n<=m))")
(cases)
(cases)
;; 3-5
(assume "p" "q")
(inst-with-to "RatLeBoundSharp" (pt "p") (pt "q") "Inst")
(by-assume "Inst" "n" "nProp")
(intro 0 (pt "n"))
(use "nProp")
;; 4
(assume "p")
(intro 0 (pt "Zero"))
(split)
(use "Truth")
(assume "m" "Useless")
(use "Truth")
;; 5
(assume "p" "q")
(inst-with-to "RatLeBoundSharp" (pt "p") (pt "q") "Inst")
(by-assume "Inst" "n" "nProp")
(intro 0 (pt "n"))
(use "nProp")
;; Proof finished.
;; (cp)
(save "RatAbsLeBoundSharp")


(set-goal "all a exl p(abs a<=2**p andnc all q(abs a<=2**q -> p<=PosS(PosS(q))))")
(assume "a")
(inst-with-to "RatAbsLeBoundSharp" (pt "a") "Inst")
(by-assume "Inst" "n0" "InstProp")
(intro 0 (pt "(cNatPos(Succ(Succ n0)))"))
(split)
(use "RatLeTrans" (pt "2**(Succ n0)#1"))
(use "RatLeTrans" (pt "2**n0#1"))
(use "InstProp")
(auto)
(ng #t)
(simp (pf "SZero(2**n0) = 2**(Succ n0)"))
(use "PosLeMonPosExp")
(simp "<-" "NatToPosLe")
(simp "NatPosExFree")
(simp "PosToNatToPosId")
(simp "NatToPosLe")
(auto)
(assume "q" "absCond")
(simp "<-" "PosToNatLe")
(simp "NatPosExFree")
(simp "PosSSucc")
(simp "PosSSucc")
(simp "PosToNatToPosId")
(ng #t)
(use "InstProp")
(use "absCond")
(auto)
(save "RatLeAbsBoundPosSharp")

(add-sound "RatLeAbsBoundPosSharp")

(set-goal "all a exnc p (p eqd cRatLeAbsBoundPosSharp a andnc abs a<=2**p andnc all q(abs a<=2**q -> p<=PosS(PosS(q))))")
(assume "a")
(intro 0 (pt "cRatLeAbsBoundPosSharp a"))
(split)
(use "InitEqD")
(inst-with-to "RatLeAbsBoundPosSharpSound" "Pro")
(use-with "ExLTMRElim" (py "pos") (make-cterm (pv "p") (pf "abs a<=2**p andnc all q(abs a<=2**q -> p<=PosS(PosS q))")) (pt "cRatLeAbsBoundPosSharp a") "?")
(use "RatLeAbsBoundPosSharpSound")
(save "RatLeAbsBoundPosSharpSoundCorr")


(set-goal "all a (abs a<=2**cRatLeAbsBoundPosSharp a)")
(assume "a")
(inst-with-to "RatLeAbsBoundPosSharpSoundCorr" (pt "a") "Inst1")
(by-assume "Inst1" "q1" "Inst1Prop")
(simp "<-" "Inst1Prop")
(use "Inst1Prop")
(save "RatLeAbsBoundPosSharpExFree")


(set-goal "all a,b (abs(a)<=abs(b) -> (2**cRatLeAbsBoundPosSharp(a))<=(2**PosS(PosS(cRatLeAbsBoundPosSharp(b)))))")
(assume "a" "b" "absCond")
(inst-with-to "RatLeAbsBoundPosSharpSoundCorr" (pt "a") "Inst1")
(inst-with-to "RatLeAbsBoundPosSharpSoundCorr" (pt "b") "Inst2")
(by-assume "Inst1" "q1" "Inst1Prop")
(by-assume "Inst2" "q2" "Inst2Prop")
(simp "<-" "Inst1Prop")
(simp "<-" "Inst2Prop")
(use "PosLeMonPosExpPos")
(use "Inst1Prop")
(use "RatLeTrans" (pt "abs(b)"))
(auto)
(use "Inst2Prop")
(save "cRatLeAbsBoundPosSharpMon")

