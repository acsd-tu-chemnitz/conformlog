
(display "loading dyn_sys_examples.scm")(newline)

(define MATCH-TREE-BOUND 1000)

;;
;; x+ = y/(1+x*x)
;; y+ = x/(1+y*y)
;;

(add-program-constant "fAB" (py "realVec=>realVec"))
(add-computation-rule "fAB xx" "ListReaToRealVector((xx__(Succ Zero)*(RealUDiv(1+(xx__Zero)*(xx__Zero)) (PosS(PosS(PosS(PosS One))))))::(xx__(Zero)*(RealUDiv(1+(xx__(Succ Zero))*(xx__(Succ Zero))) (PosS(PosS(PosS(PosS One)))))):)")

(set-totality-goal "fAB")
(use "AllTotalElim")
(assume "xx")
(use "RealVecTotalVar")
(save-totality)

(set-goal "all xx (xx dim = 2 -> xx eqd RealVecConstr (((xx__(Zero)) seq)::((xx__(Succ Zero)) seq):) (((xx__(Zero)) mod)::((xx__(Succ Zero)) mod):))")
(cases)
(cases)
(assume "MVs")
(ng #t)
(use "Efq")
(assume "as")
(cases)
(assume "MVs")
(ng #t)
(cases (pt "Succ Zero=(ListLength pos=>nat)MVs"))
(assume "case")
(ng #t)
(use "Efq")
(assume "case2")
(ng #t)
(use "Efq")
(assume "as0")
(cases)
(cases)
(ng #t)
(use "Efq")
(assume "M")
(cases)
(ng #t)
(use "Efq")
(assume "M0")
(cases)
(ng #t)
(assume "T")
(use "InitEqD")
(assume "M1")
(ng #t)
(assume "MVs")
(use "Efq")
(assume "as1")
(ng #t)
(assume "vVs" "MVs")
(cases (pt "Succ(Succ(Succ((ListLength nat=>rat)vVs)))=(ListLength pos=>nat)MVs"))
(assume "case")
(ng #t)
(use "Efq")
(assume "case")
(ng #t)
(use "Efq")
(save "RealVecSub2")

;;(set-goal "all xx,n (n< xx dim -> xx__n eqd (RealVectorDataToListRea(RealVecSeqs xx)(RealVecMods xx)__n))")
;;()



(set-goal "ProperRHS fAB 2")
(assert "all x (Real x -> RealPos abs(1+x*x)(PosS(PosS(PosS(PosS 1)))))")
(assume "x" "Rx")
(use "RealLtToRealPos")
(use "RealLtLeTrans" (pt "ReaRat 1"))
(realproof)
(ng #t)
(realproof)
(realproof)
(use "RealLeTrans" (pt "1+x*x"))
(use "RealLeTrans" (pt "ReaRat 1+0"))
(ng #t)
(use "RatLeToRealLe")
(auto)
(use "RealLeMonPlus")
(ng #t)
(use "RatLeToRealLe")
(auto)
(use "SqrNNeg")
(auto)
(use "RealLeAbsId")
(autoreal)
(auto)
(assume "Assertion1")
(assert "all x (Real x -> Real(RealUDiv(1+x*x)(PosS(PosS(PosS(PosS 1))))))")
(assume "x" "Rx")
(use "RealUDivReal")
(autoreal)
(use "Assertion1")
(autoreal)
(assume "Assertion2")
(assert "all xx (xx dim = 2 ->RealVector xx -> RealVector (fAB xx))")
(assume "xx" "dimcond" "Rxx")
(cut "Real(xx__Zero)")
(assume "Rx0")
(cut "Real(xx__(Succ Zero))")
(assume "Rx1")
(simp "fAB0CompRule")
(use "RealVectorIntro")
(use "CauchyVectorIntro")
(auto)
(use "RealToCauchy")
(use "RealEqSModEqReal" (pt "xx__Succ Zero*RealUDiv(1+xx__Zero*(xx__Zero))(PosS(PosS(PosS(PosS 1))))"))
(use "RealTimesReal")
(auto)
(use "RealEqSIntro")
(auto)
(use "CauchyVectorOneIntro")
(use "RealToCauchy")
(use "RealEqSModEqReal" (pt "xx__Zero*RealUDiv(1+xx__Succ Zero*(xx__Succ Zero))(PosS(PosS(PosS(PosS 1))))"))
(use "RealTimesReal")
(auto)
(use "RealEqSIntro")
(auto)
(use "MonVectorIntro")
(auto)
(use "RealToMon")
(use "RealEqSModEqReal" (pt "xx__Succ Zero*RealUDiv(1+xx__Zero*(xx__Zero))(PosS(PosS(PosS(PosS 1))))"))
(use "RealTimesReal")
(auto)
(use "RealEqSIntro")
(auto)
(use "MonVectorOneIntro")
(use "RealToMon")
(use "RealEqSModEqReal" (pt "xx__Zero*RealUDiv(1+xx__Succ Zero*(xx__Succ Zero))(PosS(PosS(PosS(PosS 1))))"))
(use "RealTimesReal")
(auto)
(use "RealEqSIntro")
(auto)
(use "RealVectorRealComponentWise")
(auto)
(simp "dimcond")
(auto)
(use "RealVectorRealComponentWise")
(auto)
(simp "dimcond")
(auto)
(assume "Assertion3")
(use "ProperRHSIntro")
(auto)
(assume "xx" "yy")
(assume "cond1" "cond2")
(assume "x=y")
(cut "Real(xx__Zero)")
(assume "Rx0")
(cut "Real(xx__(Succ Zero))")
(assume "Rx1")
(cut "Real(yy__(Zero))")
(assume "Ry0")
(cut "Real(yy__(Succ Zero))")
(assume "Ry1")
(simp "fAB0CompRule")
(simp "fAB0CompRule")
(use "RealVectorEqComponentsIntro")
(use "RealVectorCompatibleIntro")
(use "Assertion3")
(auto)
(use "RealVectorEqElim0" (pt "yy"))
(auto)
(use "Assertion3")
(auto)
(use "RealVectorEqElim1" (pt "xx"))
(auto)
(cases)
(assume "dim")
(simp "RealVectorNth0CompRule")
(simp "RealVectorToListRea0CompRule")
(simp "ListReaToRealVector0CompRule")
(simp "RealVecMods0CompRule")
(simp "RealVecSeqs0CompRule")
(simp "ListReaToSeqs1CompRule")
(simp "ListReaToMods1CompRule")
(simp "RealVectorDataToListRea3CompRule")
(simp "ListProjN1CompRule")
(simp "RealVectorNth0CompRule")
(use "RealEqTrans" (pt "RealConstr(yy__Succ Zero*RealUDiv(1+yy__Zero*(yy__Zero))(PosS((PosS(PosS(PosS 1))))))seq(yy__Succ Zero*RealUDiv(1+yy__Zero*(yy__Zero))(PosS(PosS(PosS(PosS 1)))))mod"))
(use "RealEqCompat" (pt "(xx__Succ Zero*RealUDiv(1+xx__Zero*(xx__Zero))(PosS(PosS(PosS(PosS 1)))))") (pt "(yy__Succ Zero*RealUDiv(1+yy__Zero*(yy__Zero))(PosS(PosS(PosS(PosS 1)))))"))
(use "RealEqSToEq")
(use "RealTimesReal")
(auto)
(use "RealEqSModEqReal" (pt "xx__Succ Zero*RealUDiv(1+xx__Zero*(xx__Zero))(PosS(PosS(PosS(PosS 1))))"))
(use "RealTimesReal")
(auto)
(use "RealEqSIntro")
(auto)
(use "RealEqSIntro")
(auto)
(use "RealEqSToEq")
(use "RealTimesReal")
(auto)
(use "RealEqSModEqReal" (pt "yy__Succ Zero*RealUDiv(1+yy__Zero*(yy__Zero))(PosS(PosS(PosS(PosS 1))))"))
(use "RealTimesReal")
(auto)
(use "RealEqSIntro")
(auto)
(use "RealEqSIntro")
(auto)
(use "RealTimesCompat")
(use "RealVectorEqComponentsElim1")
(auto)
(simp "cond1")
(auto)
(use "RealUDivCompat")
(use "RealPlusCompat")
(use "RealEqRefl")
(autoreal)
(use "RealTimesCompat")
(use "RealVectorEqComponentsElim1")
(auto)
(simp "cond1")
(auto)
(use "RealVectorEqComponentsElim1")
(auto)
(simp "cond1")
(auto)
(use "RealEqSToEq")
(use "RealEqSModEqReal" (pt "yy__Succ Zero*RealUDiv(1+yy__Zero*(yy__Zero))(PosS(PosS(PosS(PosS 1))))"))
(use "RealTimesReal")
(auto)
(use "RealEqSIntro")
(auto)
(use "RealEqSModEqReal" (pt "yy__Succ Zero*RealUDiv(1+yy__Zero*(yy__Zero))(PosS(PosS(PosS(PosS 1))))"))
(use "RealTimesReal")
(auto)
(use "RealEqSIntro")
(auto)
(ng #t)
(use "RealEqSIntro")
(auto)
(cases)
(assume "dimcond")
(use "RealEqTrans" (pt "xx__Zero*RealUDiv(1+xx__Succ Zero*(xx__Succ Zero))(PosS(PosS(PosS(PosS 1))))"))
(use "RealEqSToEq")
(use "RealEqSModEqReal" (pt "xx__Zero*RealUDiv(1+xx__Succ Zero*(xx__Succ Zero))(PosS(PosS(PosS(PosS 1))))"))
(use "RealTimesReal")
(auto)
(use "RealEqSIntro")
(auto)
(use "RealTimesReal")
(auto)
(use "RealEqSIntro")
(auto)
(use "RealEqTrans" (pt "yy__Zero*RealUDiv(1+yy__Succ Zero*(yy__Succ Zero))(PosS(PosS(PosS(PosS 1))))"))
(use "RealTimesCompat")
(use "RealVectorEqComponentsElim1")
(auto)
(simp "cond1")
(auto)
(use "RealUDivCompat")
(use "RealPlusCompat")
(use "RealEqRefl")
(autoreal)
(use "RealTimesCompat")
(use "RealVectorEqComponentsElim1")
(auto)
(simp "cond1")
(auto)
(use "RealVectorEqComponentsElim1")
(auto)
(simp "cond1")
(auto)
(use "RealEqSToEq")
(use "RealTimesReal")
(auto)
(use "RealEqSModEqReal" (pt "yy__Zero*RealUDiv(1+yy__Succ Zero*(yy__Succ Zero))(PosS(PosS(PosS(PosS 1))))"))
(use "RealTimesReal")
(auto)
(use "RealEqSIntro")
(auto)
(use "RealEqSIntro")
(auto)
(assume "n")
(ng #t)
(use "Efq")
(use "RealVectorRealComponentWise")
(use "RealVectorEqElim1" (pt "xx"))
(auto)
(simp "cond2")
(auto)
(use "RealVectorRealComponentWise")
(use "RealVectorEqElim1" (pt "xx"))
(auto)
(simp "cond2")
(auto)
(use "RealVectorRealComponentWise")
(use "RealVectorEqElim0" (pt "yy"))
(auto)
(simp "cond1")
(auto)
(use "RealVectorRealComponentWise")
(use "RealVectorEqElim0" (pt "yy"))
(auto)
(simp "cond1")
(auto)
(save "ProperRHSfAB")


;;; sqr function as class kappa


(add-program-constant "sqr" (py "contex"))

(add-computation-rules "sqr" "ContexConstr ([a,n] a*a) ([c,d,p] Zero) ([c,d,p] p+cRatLeAbsBoundPos(abs(c+c) max abs(d+d)) +1 )")

(set-totality-goal "sqr")
(use "ContexTotalVar")
(save-totality)

(add-program-constant "sqrb" (py "contex"))

(add-computation-rules "sqrb" "ContexConstr ([a,n] a*a) ([c,d,p] Zero) ([c,d,p] p+cRatLeAbsBoundPosSharp(abs(c+c) max abs(d+d)) +3 )")

(set-totality-goal "sqrb")
(use "ContexTotalVar")
(save-totality)


(set-goal "all fex,eta ( Contex fex ->  all a,p(RealLt 0 a (PosS p) -> RealLt 0 (fex a) (eta p)) -> all x (Real x -> exl p RealLt 0 x p -> exl p RealLt 0 (fex x) p))")
(cases)
(assume "h" "alcd" "omcd" "eta")
(assume "Cf")
(assume "cond") 
(cases)
(assume "as" "M")
(assume "Rx")
(assume "0ltx")
(by-assume "0ltx" "p" "ExHypProp")
(intro 0 (pt "PosS(PosS(PosS(PosS(eta p))))"))
(simp "ContexApplication0CompRule")
(simp "ContexApplicationbounded0CompRule")
(simp "RealLt0CompRule")
(simp "RealMinus0CompRule")
(simp "RealUMinus0CompRule")
(simp "RealPlus0CompRule")
(use "RealPosChar2" (pt "M(PosS(PosS p))max alcd IntN(2**cRealBound as M)(2**cRealBound as M)(PosS(PosS(PosS(eta p))))"))
(simp "<-" "RealPlus0CompRule")
(simp "<-" "RealUMinus0CompRule")
(simp "<-" "ContexApplicationbounded0CompRule")
(use "RealPlusReal")
(simp "<-" "ContexApplication0CompRule")
(use "ContexApplicationReal")
(auto)
(autoreal)
(assume "n" "n1len")
(ng #t)
(simprat "RatPlusHalfExpPosSSplit")
(assert "RealLt 0 (as n) (PosS p) -> RealLt 0 (ContexApplicationbounded (ContexConstr h alcd omcd) IntN(2**cRealBound as M) (2**cRealBound as M) (as n)) (PosS(PosS(eta p)))")
(assume "0leas")
(use "RealLtCompatRealConstrFree" (pt "ReaRat 0") (pt "ContexConstr h alcd omcd(as n)"))
(ng #t)
(use "RealEqRefl")
(autoreal)
(use "RealEqSToEq")
(use "ContexApplicationReal")
(auto)
(realproof)
(use "ContexAppBoundedReal")
(auto)
(autoreal)
(assume "n0")
(inst-with-to "RatAbsLeCases" (pt "as n") (pt "2**cRealBound as M#1") "RatInst")
(use "RatInst")
(use "RealBoundExFree")
(use "RealConstrToCauchy")
(auto)
(assume "n0")
(ng #t)
(use "RatAbsLeCases")
(use "RealBoundExFree")
(use "RealConstrToCauchy")
(autoreal)
(use "RealEqSIntro")
(assume "n0")
(ng #t)
(use "Truth")
(inst-with-to "cond" (pt "as n") "AuxCond")
(ng "AuxCond")
(use "AuxCond")
(ng "0leas")
(use "0leas")
(assume "Assertion")
(ng "Assertion")
(use "RatLeTrans" (pt "h(as n)n + ~(h(as n)(alcd IntN(2**cRealBound as M)(2**cRealBound as M)(PosS(PosS(PosS(PosS(PosS(PosS(eta p))))))))) + h(as n)(alcd IntN(2**cRealBound as M)(2**cRealBound as M)(PosS(PosS(PosS(PosS(PosS(PosS(eta p)))))))) "))
(use "RatLeTrans" (pt " ~(1#2**PosS(PosS(PosS(eta p)))) + (1#2**PosS(PosS(eta p)))"))
(simp "RatPlusComm")
(ng #t)
(use "Truth")
(use "RatLeMonPlus")
(use "RatLeUMinusToLeSwitch")
(ng #t)
(simp "RatPlusComm")
(use "RatLeTrans" (pt "abs(h(as n) (alcd IntN(2**cRealBound as M)(2**cRealBound as M) (PosS(PosS(PosS(PosS(PosS(PosS(eta p))))))))+ ~(h(as n)n))"))
(auto)
(use "CauchyElim" (pt "alcd IntN(2**cRealBound as M)(2**cRealBound as M)"))
(inst-with-to "ContexElim0" (pt "ContexConstr h alcd omcd") "ContexInst")
(use "ContexInst")
(auto)
(inst-with-to "RatAbsLeCases" (pt "as n") (pt "2**cRealBound as M#1") "RatInst")
(use "RatInst")
(use "RealBoundExFree")
(use "RealConstrToCauchy")
(auto)
(use "RatAbsLeCases")
(use "RealBoundExFree")
(use "RealConstrToCauchy")
(auto)
(inst-with-to "ContexElim2" (pt "ContexConstr h alcd omcd") "ContexInst")
(use "ContexInst")
(auto)
(ng #t)
(use "PosLeTrans" (pt "PosS(PosS(eta p))"))
(use "PosLeTrans" (pt "PosS(eta p)"))
(auto)
(use "NatLeTrans" (pt "M(PosS(PosS p))max alcd IntN(2**cRealBound as M)(2**cRealBound as M)(PosS(PosS(PosS(eta p))))"))
(use "NatMaxUB2")
(auto)
(use "Assertion")
(ng "ExHypProp")
(simprat "RatPlusHalfExpPosSSplit")
(use "RatLeTrans" (pt " ~(1#2**PosS p) + (1#2**p)"))
(simp "RatPlusComm")
(ng #t)
(use "Truth")
(use "RatLeTrans" (pt "as n + ~(as(M(PosS(PosS p)))) + as(M(PosS(PosS p))) "))
(use "RatLeMonPlus")
(use "RatLeUMinusToLeSwitch")
(ng #t)
(simp "RatPlusComm")
(use "RatLeTrans" (pt "abs(as(M(PosS(PosS p)))+ ~(as n))"))
(auto)
(use "CauchyElim" (pt "M"))
(use "RealConstrToCauchy")
(autoreal)
(use "MonElim")
(use "RealConstrToMon" (pt "as"))
(autoreal)
(auto)
(use "NatLeTrans" (pt "M(PosS(PosS p))max alcd IntN(2**cRealBound as M)(2**cRealBound as M)(PosS(PosS(PosS(eta p))))"))
(use "NatLeTrans" (pt "M(PosS(PosS p))"))
(use "MonElim")
(use "RealConstrToMon" (pt "as"))
(autoreal)
(auto)
(use "NatMaxUB1")
(auto)
(simp "<-" "RatPlusAssoc")
(simprat (pf "~(as(M(PosS(PosS p))))+as(M(PosS(PosS p)))==0"))
(auto)
(simp "<-" "RatPlusAssoc")
(simprat (pf "(~(h(as n)(alcd IntN(2**cRealBound as M)(2**cRealBound as M) (PosS(PosS(PosS(PosS(PosS(PosS(eta p)))))))))+ h(as n)(alcd IntN(2**cRealBound as M)(2**cRealBound as M)(PosS(PosS(PosS(PosS(PosS(PosS(eta p)))))))))==0"))
(auto)
(save "EtaWitToStrIncContex")

(deanimate "NatPos")

(set-goal "all Fcf,eta ( UCFall Fcf ->  all a,p(RealLt 0 a (PosS p) -> RealLt 0 (Fcf a) (eta p)) -> all x (Real x -> exl p RealLt 0 x p -> exl p RealLt 0 (Fcf x) p))")
(cases)
(assume "hc" "om" "eta")
(assume "UCF")
(assume "cond")
(cases)
(assume "as" "M")
(assume "Rx")
(assume "0ltx")
(by-assume "0ltx" "p" "ExHypProp")
(intro 0 (pt "(PosS(PosS(eta p)))"))
(simp "UCFallApplication0CompRule")
(simp "RealLt0CompRule")
(simp "RealMinus0CompRule")
(simp "RealUMinus0CompRule")
(simp "RealPlus0CompRule")
(use "RealPosChar2" (pt "M(PosS(PosS p))max PosToNat((eta p) max (PosS p))"))
(simp "<-" "RealPlus0CompRule")
(simp "<-" "RealUMinus0CompRule")
(simp  "<-" "UCFallApplication0CompRule")
(use "RealPlusReal")
(use "UCFallApplicationReal")
(auto)
(autoreal)
(assume "n" "n1len")
(ng #t)
(ng "cond")
(ng "ExHypProp")
(inst-with-to "cond" (pt "as(M(PosS(om(cNatPos n))))") (pt "p")  "condm")
(ng "condm")
(simprat "RatPlusHalfExpPosSSplit")
(inst-with-to "RatSubVar" (pt "(hc(as(M(PosS(om(cNatPos n))))))seq((hc(as(M(PosS(om(cNatPos n))))))mod(cNatPos(Succ(Succ n))))") "sub1")
(by-assume "sub1" "a1" "sub1Prop")
(simprat "sub1Prop")
(inst-with-to "RatSubVar" (pt "(hc(as(M(PosS(om(cNatPos n))))))seq((hc(as(M(PosS(om(cNatPos n))))))mod(cNatPos(Succ(Succ(Succ(PosToNat(PosS(PosS(eta p)))))))))") "sub2")
(by-assume "sub2" "b1" "sub2Prop")
(use "RatLeTrans" (pt "b1 + a1 + ~b1"))
(simp "<-" "RatPlusAssoc")
(use "RatLeMonPlus")
(simprat "<-" "sub2Prop")
(use "condm")
(simprat "RatPlusHalfExpPosSSplit")
(use "RatLeTrans" (pt "as(M(PosS(PosS p))) + as(M(PosS(om(cNatPos n)))) + ~(as(M(PosS(PosS p))))"))
(simp "<-" "RatPlusAssoc")
(use "RatLeMonPlus")
(use "ExHypProp")
(use "RatLeUMinusToLeSwitch")
(ng #t)
(simp "RatPlusComm")
(use "RatLeTrans" (pt "abs(as(M(PosS(PosS p)))+ ~(as(M(PosS(om(cNatPos n))))))"))
(auto)
(use "CauchyElim" (pt "M"))
(use "RealConstrToCauchy")
(auto)
(use "MonElim")
(use "RealConstrToMon" (pt "as"))
(auto)
(use "MonElim")
(use "RealConstrToMon" (pt "as"))
(auto)
(ng #t)
(use "PosLeTrans" (pt "om p"))
(inst-with-to "UCFallElim3" (pt "UCFallConstr hc om") "UCFInst")
(use "UCFInst")
(auto)
(inst-with-to "UCFallElim2" (pt "UCFallConstr hc om") "UCFInst")
(use "UCFInst")
(auto)
(simp "NatPosExFree")
(simp "<-" "PosToNatLe")
(use "NatLeTrans" (pt "M(PosS(PosS p))max PosToNat(eta p max PosS p)"))
(use "NatLeTrans" (pt "PosToNat (PosS p)"))
(simp "PosToNatLe")
(auto)
(use "NatLeTrans" (pt "PosToNat(eta p max PosS p)"))
(use "NatLeTrans" (pt "PosToNat (eta p) max PosToNat (PosS p) "))
(use "NatMaxUB2")
(use "NatMaxLUB")
(simp "PosToNatLe")
(use "PosMaxUB1")
(simp "PosToNatLe")
(use "PosMaxUB2")
(use "NatMaxUB2")
(simp "PosToNatToPosId")
(auto)
(use "NatLtLeTrans" (pt "M(PosS(PosS p))max PosToNat(eta p max PosS p)"))
(use "NatLtLeTrans" (pt "PosToNat(eta p max PosS p)"))
(use "Truth")
(use "NatMaxUB2")
(auto)
(use "RatLePlusCancelR" (pt "as(M(PosS(PosS p)))"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "~(as(M(PosS(PosS p))))+as(M(PosS(PosS p)))==0"))
(ng #t)
(simp "RatPlusComm")
(auto)
(use "RatLeUMinusToLeSwitch")
(ng #t)
(simp "<-" "RatPlusComm")
(use "RatLeTrans" (pt "abs(b1 + ~a1)"))
(auto)
(simprat "<-" "sub1Prop")
(simprat "<-" "sub2Prop")
(use "CauchyElim" (pt "(hc(as(M(PosS(om(cNatPos n))))))mod"))
(use "RealToCauchy")
(inst-with-to "UCFallElim0" (pt "UCFallConstr hc om") "UCFInst")
(use "UCFInst")
(auto)
(use "MonElim")
(use "RealToMon")
(inst-with-to "UCFallElim0" (pt "UCFallConstr hc om") "UCFInst")
(use "UCFInst")
(auto)
(ng #t)
(simp "NatPosExFree")
(simp "PosSSucc")
(simp "PosSSucc")
(simp "SuccPosS")
(simp "SuccPosS")
(simp "SuccPosS")
(simp "SuccPosS")
(simp "SuccPosS")
(simp "NatToPosToNatId")
(ng #t)
(use "PosLeTrans" (pt "PosS(PosS(PosS(eta p)))"))
(use "PosLeTrans" (pt "PosS(PosS(eta p))"))
(use "PosLeTrans" (pt "PosS(eta p)"))
(auto)
(use "MonElim")
(use "RealToMon")
(inst-with-to "UCFallElim0" (pt "UCFallConstr hc om") "UCFInst")
(use "UCFInst")
(auto)
(simp "NatPosExFree")
(simp "SuccPosS")
(simp "<-" "NatPosExFree")
(ng #t)
(simp "NatPosExFree")
(simp "<-" "PosToNatLe")
(use "NatLeTrans" (pt "PosToNat(eta p max PosS p)"))
(use "NatLeTrans" (pt "PosToNat(eta p) max PosToNat(PosS p)"))
(use "NatMaxUB1")
(use "NatMaxLUB")
(simp "PosToNatLe")
(use "PosMaxUB1")
(simp "PosToNatLe")
(use "PosMaxUB2")
(simp "PosToNatToPosId")
(use "NatLeTrans" (pt "M(PosS(PosS p))max(eta p max PosS p)"))
(use "NatMaxUB2")
(use "NatLeTrans" (pt "n"))
(auto)
(use "RatLePlusCancelR" (pt "b1"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "~b1+b1==0"))
(ng #t)
(simp "RatPlusComm")
(auto)
(save "EtaWitToStrIncUCFall")


(deanimate "RatLeAbsBoundPos")

(set-goal "all n,m (2**n<=2**m -> n<=m)")
(ind)
(ng #t)
(auto)
(assume "n" "Ih")
(cases)
(ng #t)
(use "Efq")
(assume "m")
(assume "cond")
(ng)
(auto)
(save "NatExpTwoLeRev")

(set-goal "all p,q (2**p<=2**q -> p<=q)")
(assume "p" "q")
(assume "cond")
(simp (pf "p=NatToPos(PosToNat p)"))
(simp (pf "q=NatToPos(PosToNat q)"))
(simp "NatToPosLe")
(use "NatExpTwoLeRev")
(auto)
(simp "NatToPosToNatId")
(auto)
(simp "NatToPosToNatId")
(auto)
(save "PosExpTwoLeRev")




(animate "RatLeAbsBoundPosSharp")

;; square function contex
(set-goal "Contex(sqrb)")
(use "ContexIntro")
(assume "a" "c" "d")
(assume "c<d" "c<=a" "a<=d")
(use "CauchyIntro")
(ng #t)
(strip)
;;(simprat (pf "a*a+ ~(a*a)==0"))
(auto)
(assume "a" "b" "c" "d" "p" "n")
(assume "c<=d" "c<=a" "a<=d" "c<=b" "b<=d" "0<=n" "modc")
(ng #t)
(use "RatLeTrans" (pt "abs( (a-b)*(a+b))"))
(simprat "RatBinomForm3")
(simp "RatTimesComm")
(ng #t)
(use "Truth")
(use "RatLeTrans" (pt "abs(a-b)*abs(a+b)"))
(simp "RatAbsTimes")
(auto)
(use "RatLeTrans" (pt "1/2**PosPred(([a0,a1,p0]p0+cNatPos(Succ(Succ(cRatAbsLeBoundSharp(abs(a0+a0)max abs(a1+a1)))))+3)c d p)*abs(a+b)"))
(use "RatLeMonTimes")
(auto)
(use "RatLeTrans" (pt "1/2**PosPred(([a0,a1,p0]p0+cNatPos(Succ(Succ(cRatAbsLeBoundSharp(abs(a0+a0)max abs(a1+a1)))))+3)c d p)*(2**cRatLeAbsBoundPosSharp (a+b))"))
(use "RatLeMonTimesTwo")
(auto)
(use "RatLeAbsBoundPosSharpExFree")
(use "RatLeTrans" (pt "1/2**PosPred(([a0,a1,p0]p0+cNatPos(Succ(Succ(cRatAbsLeBoundSharp(abs(a0+a0)max abs(a1+a1)))))+3)c d p)*2**PosS(PosS(cRatLeAbsBoundPosSharp(abs(c+c)max abs(d+d))))"))
(use "RatLeMonTimesTwo")
(auto)
(use "cRatLeAbsBoundPosSharpMon")
(use "RatAbsLeCases2")
(ng #t)
(use "RatLeUMinusToLeSwitch")
(ng #t)
(use "RatLeTrans" (pt "abs(c+c)max abs(d+d)"))
(use "RatLeTrans" (pt "abs(c+c)"))
(simp "RatAbsMax")
(ng #t)
(use "RatLeTrans" (pt "~c+ ~c"))
(use "RatLeMonPlus")
(ng #t)
(auto)
(use "RatMaxUB2")
(use "RatMaxUB1")
(auto)
(use "RatLeTrans" (pt "abs(d+d)"))
(simp "RatAbsMax")
(use "RatLeTrans" (pt "d+d"))
(use "RatLeMonPlus")
(auto)
(use "RatMaxUB1")
(use "RatLeTrans" (pt "abs(c+c)max abs(d+d)"))
(use "RatMaxUB2")
(auto)
(ng #t)
(simp "PosExpTwoPosPlus")
(use "PosExpLeMon")
(simp "PosPlusComm")
(auto)
(simp (pf "PosPred(p+cNatPos(Succ(Succ(cRatAbsLeBoundSharp(abs(c+c)max abs(d+d)))))+3)=PosPred (p+cNatPos(Succ(Succ(cRatAbsLeBoundSharp(abs(c+c)max abs(d+d)))))+2 +1)"))
(ng #t)
(simp (pf "p+cNatPos(Succ(Succ(cRatAbsLeBoundSharp(abs(c+c)max abs(d+d)))))+2=p+cNatPos(Succ(Succ(cRatAbsLeBoundSharp(abs(c+c)max abs(d+d)))))+1 +1"))
(ng #t)
(auto)
(assert "all p (p+2 = p+1+1)")
(cases)
(ng #t)
(auto)
(assert "all p (p+3 = p+2+1)")
(cases)
(auto)
(assume "PAssertion")
(simp "PAssertion")
(auto)
(save "SqContex")

(deanimate "RatLeAbsBoundPos")


(set-goal "all a IntN(2**cRealBound([n0]a)([p]Zero))<=a")
(assume "a")
(use "RatLeUMinusToLeSwitch")
(ng #t)
(use "RatLeTrans" (pt "abs(a)"))
(simp "RatAbsMax")
(use "RatMaxUB2")
(inst-with-to "RealBoundExFree" (pt "([n0]a)") (pt "([p]Zero)") "Boundx")
(use "Boundx" (pt "Zero"))
(use "RealConstrToCauchy")
(autoreal)
(save "cRealBoundRatLeft")

(set-goal "all a a<=(2**cRealBound([n0]a)([p]Zero))")
(assume "a")
(use "RatLeTrans" (pt "abs(a)"))
(auto)
(inst-with-to "RealBoundExFree" (pt "([n0]a)") (pt "([p]Zero)") "Boundx")
(use "Boundx" (pt "Zero"))
(use "RealConstrToCauchy")
(autoreal)
(save "cRealBoundRatRight")



;; class K for 0<=x -> x^2


(set-goal "ClassKappaConfiguration (ContexApplication sqrb)")
(assert "all x ( Real x -> ContexConstr ([a,n] a*a) ([c,d,p] Zero) ([c,d,p] p+cRatLeAbsBoundPosSharp(abs(c+c) max abs(d+d)) +3 ) x === x*x)")
(cases)
(assume "as" "M")
(assume "Rx")
(use "RealEqSToEq")
(use "ContexApplicationReal")
(use "SqContex")
(auto)
(autoreal)
(use "RealEqSIntro")
(ng #t)
(auto)
(assume "Assertion")
(use "ClassKappaConfigurationIntro")
(use "ContexCfmapCont")
(use "SqContex")
(cases)
(assume "as" "M" "0<<=x")
(inst-with-to "Assertion" (pt "RealConstr as M") "AssertionInst")
(simp "sqrb0CompRule")
(simpreal "AssertionInst") 
(use "SqrNNeg")
(autoreal)
(assume "x" "cond")
(simp "sqrb0CompRule")
(simpreal "Assertion")
(simpreal "cond")
(ng #t)
(use "RealEqRefl")
(autoreal)
(assume "x" "y" "0<=x" "0<=y" "x<=y")
(simp "sqrb0CompRule")
(cut "Real( ContexConstr([a,n]a*a)([c,d,p]Zero)([c,d,p]p+cRatLeAbsBoundPosSharp(abs(c+c)max abs(d+d))+3)y)")
(assume "cutInst")
(simpreal "Assertion")
(simpreal "Assertion")
(use "RealLeMonTimesTwo")
(use "RealLeToRealNNeg")
(auto)
(use "RealLeToRealNNeg")
(auto)
(realproof)
(realproof)
(use "ContexApplicationReal")
(use "SqContex")
(autoreal)
(assume "x" "y")
(assume "0<=x" "0<=y")
(assume "cond")
(assert "x*x<<=y*y")
(simpreal "<-" "Assertion")
(cut "Real(ContexConstr([a,n]a*a)([c,d,p]Zero)([c,d,p]p+cRatLeAbsBoundPosSharp(abs(c+c)max abs(d+d))+3)x) ")
(assume "CutInst")
(simpreal "<-" "Assertion")
(use "cond")
(realproof)
(use "ContexApplicationReal")
(use "SqContex")
(autoreal)
(assume "cond2")
(use "RealLeTrans" (pt "Rsqrt(x*x)"))
(simpreal "RealSqrtProp3")
(use "RealLeReflNC")
(use "RealEqSym")
(use "RealSqrtProp")
(auto)
(use "RealLeTrans" (pt "Rsqrt(y*y)"))
(use "RealSqrtInc")
(use "RealNNegToRealLe")
(use "RealNNegTimesNNeg")
(use "RealLeToRealNNeg")
(auto)
(use "RealLeToRealNNeg")
(auto)
(simpreal "RealSqrtProp3")
(use "RealLeReflNC")
(use "RealSqrtProp")
(auto)
(assume "x")
(assume "Rx")
(assume "cond")
(use "EtaWitToStrIncContex" (pt "[p] PosS(p)+PosS(p)"))
(use "SqContex")
(assume "a" "p")
(assume "cond2")
(ng "cond2")
(ng #t)
(use "RatLeTrans" (pt "(1#2)**(PosS(p))*(1#2)**(PosS(p))"))
(ng #t)
(simp "PosExpTwoPosPlus")
(use "PosLeMonPosExp")
(ng #t)
(use "Truth")
(use "RatLeMonTimesTwo")
(auto)
(save "SqrIsClassKappa")


(set-goal "all x (Real x -> (sqrb x)===x*x)")
(cases)
(assume "as" "M" "Ras")
(use "RealEqSToEq")
(simp "sqrb0CompRule")
(use "ContexApplicationReal")
(use "SqContex")
(autoreal)
(use "RealEqSIntro")
(assume "n")
(ng #t)
(use "Truth")
(save "sqrRewrite")


; (set-goal "all a,b,p (0<=a -> 0<=b -> RealLt a b p -> exl eta RealLt (sqr a) (sqr b) (eta p))")
; (assume "a" "b" "p" "0<=a" "0<=b")
; ()


(set-goal "all x (Real x -> exl m all n abs(x seq n)<=2**m)")
(cases)
(assume "as" "M")
(assume "Rx")
(intro 0 (pt "RealBd as M"))
(assume "n")
(use "RealBdProp")
(use "RealConstrToCauchy")
(auto)
(save "RealBdXProp")


(set-goal "all x,y,p(0<<=x ->Real y ->RealLt x y p -> ex n,p0 (all n0 ((n<= n0) -> (1#2)**p0<= x seq n0 + y seq n0)))")
(assume "x" "y" "p" "0<=x" "Ry" "x<y")
(inst-with-to "RealNNegCharOneExFreeConstrFree" (pt "x") "InstLe")
(inst-with-to "RealPosChar1RealConstrFree" (pt "y") "InstLt")
(assert "RealLt 0 y (PosS(PosS(PosS p)))")
(use "RealLeLtTrans" (pt "x"))
(autoreal)
(auto)
(assume "RLt0")
(assert "RealPos y (PosS(PosS(PosS(PosS p))))")
(use "RealLtToRealPos")
(auto)
(assume "RPosy")
(inst-with-to "InstLt" (pt "(PosS(PosS(PosS(PosS p))))") "InstLtSpec")
(ex-intro (pt "cRealNNegCharOne x mod (PosS(PosS(PosS(PosS(PosS(PosS p)))))) max y mod(PosS(PosS(PosS(PosS(PosS p)))))"))
(ex-intro "(PosS(PosS(PosS(PosS(PosS(PosS p))))))")
(assume "n" "IterCond")
(use "RatLeTrans" (pt "~((1#2)**PosS(PosS(PosS(PosS(PosS(PosS p)))))) + (1#2)**PosS(PosS(PosS(PosS(PosS p))))"))
(simprat (pf "(1#2)**PosS(PosS(PosS(PosS(PosS p))))==(1#2)**PosS(PosS(PosS(PosS(PosS(PosS p)))))+(1#2)**PosS(PosS(PosS(PosS(PosS(PosS p)))))"))
(simp "RatPlusAssoc")
(simprat (pf "~((1#2)**PosS(PosS(PosS(PosS(PosS(PosS p))))))+(1#2)**PosS(PosS(PosS(PosS(PosS(PosS p)))))==0"))
(auto)
(use "RatEqvSym")
(use "RatPlusHalfExpPosS")
(use "RatLeMonPlus")
(use "InstLe")
(use "RealLeToRealNNeg")
(auto)
(use "NatLeTrans" (pt "cRealNNegCharOne x mod(PosS(PosS(PosS(PosS(PosS(PosS p))))))max               y mod(PosS(PosS(PosS(PosS(PosS p)))))"))
(use "NatMaxUB1")
(auto)
(use "InstLtSpec")
(auto)
(use "NatLeTrans" (pt "cRealNNegCharOne x mod(PosS(PosS(PosS(PosS(PosS(PosS p))))))max y mod(PosS(PosS(PosS(PosS(PosS p)))))"))
(use "NatMaxUB2")
(auto)
(save "ClassKappaConfigurationPosAuxPropPos")


(set-goal "ClassKappaConfigurationPos (ContexApplication sqrb)")
(use "ClassKappaConfigurationPosIntro")
(use "SqrIsClassKappa")
(cases)
(assume "as" "M")
(cases)
(assume "bs" "N")
(assume "0<=x" "Rx")
(assume "x<y")
(by-assume "x<y" "p0" "x<yP")
(inst-with-to "ClassKappaConfigurationPosAuxPropPos" (pt "RealConstr as M") (pt "RealConstr bs N") "AuxPropInst")
(assert "ex n,p0 all n0(n<=n0 ->(1#2)**p0<=(RealConstr as M)seq n0+(RealConstr bs N)seq n0)")
(use "AuxPropInst" (pt "p0"))
(auto)
(assume "ExAuxPropInst")
(by-assume "ExAuxPropInst" "m" "ExAuxPropInst1")
(by-assume "ExAuxPropInst1" "p1" "ExAuxPropInst2")
(intro 0 (pt "PosS(PosS(PosS(PosS(p0+p1))))"))
(use "RealLtCompatRealConstrFree" (pt "(RealConstr as M)*(RealConstr as M)") (pt "(RealConstr bs N)*(RealConstr bs N)"))
(use "RealEqSym")
(use "sqrRewrite")
(autoreal)
(use "RealEqSym")
(use "sqrRewrite")
(autoreal)
(use "RealLtIntro")
(use "RealPosChar2RealConstrFree" (pt "(RealConstr bs N+ ~(RealConstr as M))mod(PosS p0) max m"))
(realproof)
(assume "n" "cond")
(inst-with-to "RealLtCompatRealConstrFree" "Inst")
(inst-with-to "RealPosChar1RealConstrFree" (pt "RealConstr bs N + ~(RealConstr as M)") "Inst2")
(assert "(1#2**PosS p0)<=(RealConstr bs N+ ~(RealConstr as M))seq n")
(use "Inst2")
(autoreal)
(use "x<yP")
(auto)
(use "NatLeTrans" (pt "(RealConstr bs N+ ~(RealConstr as M))mod(PosS p0)max m"))
(use "NatMaxUB1")
(auto)
(assume "Assertion")
(ng #t)
(simp (pf "PosS(p0+p1)=PosS(p0) + p1"))
(use "RatLeTrans" (pt "(1#2**(PosS p0))*(1#2**( p1))"))
(ng #t)
(simp "PosExpTwoPosPlus")
(auto)
(simprat "RatBinomForm3")
(simp "RatTimesComm")
(use "RatLeMonTimesTwo")
(auto)
(simp "RatPlusComm")
(use "ExAuxPropInst2")
(use "NatLeTrans" (pt "(RealConstr bs N+ ~(RealConstr as M))mod(PosS p0)max m"))
(use "NatMaxUB2")
(auto)
(assume "x" "y")
(assume "0<=x" "0<=y" "Rx" "ExInst")
(inst-with-to "RealLtZeroWeaken" (pt "y+ ~x") (pt "y+x") "InstP2")
(assert " exl p RealLt 0(y+ ~x)p")
(use "InstP2")
(autoreal)
(simpreal (pf "0===(ReaRat 0)+0"))
(use "RealLeMonPlus")
(auto)
(ng #t)
(use "RealEqRefl")
(autoreal)
(by-assume "ExInst" "p0" "ExInstProp")
(intro 0 (pt "PosS(PosS(PosS(PosS(p0))))"))
(use "RealLtCompatRealConstrFree" (pt "ReaRat 0") (pt "y*y+ ~(x*x)"))
(ng #t)
(use "RealEqRefl")
(autoreal)
(use "RealEqSym")
(use "RealBinomForm3")
(autoreal)
(use "RealLtIntro")
(use "RealPosCompatRealConstrFree" (pt "sqrb y + ~(sqrb x)"))
(cut "Real(sqrb x)")
(assume "Rsqrx")
(cut "Real(sqrb y)")
(assume "Rsqry")
(simpreal "<-" "RealPlusAssoc")
(use "RealPlusCompat")
(use "sqrRewrite")
(auto)
(simpreal (pf "~(x*x)+ ~(ReaRat 0)=== ~(x*x)"))
(use "RealUMinusCompat")
(use "sqrRewrite")
(auto)
(autoreal)
(ng #t)
(use "RealPlusZero")
(realproof)
(ng #t)
(realproof)
(realproof)
(realproof)
(use "ContexApplicationReal")
(use "SqContex")
(realproof)
(use "ContexApplicationReal")
(use "SqContex")
(realproof)
(use "RealLtElim")
(use "ExInstProp")
(assume "ExInstPNew")
(by-assume "ExInstPNew" "p0" "ExInstPNewProp")
(intro 0 (pt "PosS p0"))
(use "RealLtIntro")
(use "RealLtToRealPos")
(use "ExInstPNewProp")
(save "SqrIsClassKappaPos")





;; x^2+y^2 as Lyapunov function

(add-program-constant "Vsqr" (py "Cmapmv"))
(add-computation-rule "Vsqr xx" "(xx__Zero)*(xx__Zero)+(xx__(Succ Zero))*(xx__(Succ Zero))")

(set-totality-goal "Vsqr")
(use "AllTotalElim")
(assume "xx")
(use "ReaTotalVar")
(save-totality)


;; proof of Vsqr being CmapContmv 

(set-goal "CmapContmv Vsqr 2")
(assert "all xx(Zero<xx dim -> xx dim=PosToNat 2 -> RealVector xx -> Real(Vsqr xx))  ")
(cases)
(cases)
(assume "MVs")
(ng #t)
(use "Efq")
(assume "as")
(cases)
(assume "MVs")
(ng #t)
(cases (pt "Succ Zero=(ListLength pos=>nat)MVs"))
(assume "case1")
(ng #t)
(assume "T")
(use "Efq")
(assume "case2")
(ng #t)
(use "Efq")
(assume "as0")
(cases)
(cases)
(ng #t)
(use "Efq")
(assume "M")
(cases)
(ng #t)
(use "Efq")
(assume "M0")
(cases)
(assume "cond1" "cond2" "Rx")
(inst-with-to "RealVectorRealVecConstrRealComponentWise" (pt "(RealVecConstr(as::as0:)(M::M0:))seqs") (pt "(RealVecConstr(as::as0:)(M::M0:))mods") "InstInd")
(cut "all n(n<(RealVecConstr(RealVecSeqs(RealVecConstr(as::as0:)(M::M0:)))(RealVecMods(RealVecConstr(as::as0:)(M::M0:))))dim ->Real(RealConstr(RealVecSeqs(RealVecConstr(as::as0:)(M::M0:))__n)(RealVecMods(RealVecConstr(as::as0:)(M::M0:))__n)))")
(assume "InstIndx")
(use "RealEqSModEqReal" (pt "(RealConstr as M)*(RealConstr as M)+(RealConstr as0 M0)*(RealConstr as0 M0)"))
(use "RealPlusReal")
(use "RealTimesReal")
(inst-with-to "InstIndx" (pt "Zero") "Inst1")
(ng "Inst1")
(auto)
(inst-with-to "InstIndx" (pt "Zero") "Inst1")
(ng "Inst1")
(auto)
(use "RealTimesReal")
(inst-with-to "InstIndx" (pt "Succ Zero") "Inst1")
(ng "Inst1")
(auto)
(inst-with-to "InstIndx" (pt "Succ Zero") "Inst1")
(ng "Inst1")
(auto)
(use "RealEqSIntro")
(auto)
(assume "M1")
(assume "MVs")
(ng #t)
(use "Efq")
(assume "as1")
(assume "vVs" "MVs")
(ng #t)
(cases (pt "(Succ(Succ(Succ((ListLength nat=>rat)vVs)))=(ListLength pos=>nat)MVs)"))
(assume "case1")
(ng #t)
(assume "T")
(use "Efq")
(assume "case2")
(ng #t)
(use "Efq")
(assume "Assertion")
(use "CmapContmvIntro")
(auto)
(cases)
(cases)
(assume "MVs")
(assume "yy")
(ng #t)
(use "Efq")
(assume "as")
(cases)
(assume "MVs")
(assume "yy")
(ng #t)
(cases (pt "(Succ Zero=(ListLength pos=>nat)MVs)"))
(assume "case1")
(ng #t)
(assume "T")
(use "Efq")
(assume "case2")
(ng #t)
(use "Efq")
(assume "as0")
(cases)
(cases)
(assume "yy")
(ng #t)
(use "Efq")
(assume "M")
(cases)
(assume "yy")
(ng #t)
(use "Efq")
(assume "M0")
(cases)
(cases)
(cases)
(assume "MVs")
(ng #t)
(assume "T")
(assume "TT")
(assume "Rx=y")
(inst-with-to "RealVectorCompatibleElim2" (pt "RealVecConstr(as::as0:)(M::M0:)") (pt "RealVecConstr(Nil nat=>rat)MVs")  "CompatInst")
(ng "CompatInst")
(use "Efq")
(use "CompatInst")
(use "RealVectorEqComponentsElim0")
(auto)
(assume "as1")
(cases)
(assume "MVs")
(assume "T" "TT")
(assume "Rx=y")
(inst-with-to "RealVectorCompatibleElim2" (pt "RealVecConstr(as::as0:)(M::M0:)") (pt "RealVecConstr as1:MVs")  "CompatInst")
(ng "CompatInst")
(cut "Succ(Succ Zero)=[if (Succ Zero=(ListLength pos=>nat)MVs) (Succ Zero) Zero]")
(cases (pt "(Succ Zero=(ListLength pos=>nat)MVs)"))
(assume "case1")
(ng #t)
(use "Efq")
(assume "case2")
(ng #t)
(use "Efq")
(use "CompatInst")
(use "RealVectorEqComponentsElim0")
(auto)
(assume "as2")
(cases)
(cases)
(assume "T" "TT")
(assume "Rx=y")
(inst-with-to "RealVectorCompatibleElim2" (pt "RealVecConstr(as::as0:)(M::M0:)") (pt "RealVecConstr(as1::as2:)(Nil pos=>nat)")  "CompatInst")
(ng "CompatInst")
(use "Efq")
(use "CompatInst")
(use "RealVectorEqComponentsElim0")
(auto)
(assume "M1")
(cases)
(assume "T" "TT")
(assume "Rx=y")
(inst-with-to "RealVectorCompatibleElim2" (pt "RealVecConstr(as::as0:)(M::M0:)") (pt "RealVecConstr(as1::as2:)M1:")  "CompatInst")
(ng "CompatInst")
(use "Efq")
(use "CompatInst")
(use "RealVectorEqComponentsElim0")
(auto)
(assume "M2")
(cases)
(assume "T" "TT")
(assume "Rx=y")
(inst-with-to "RealVectorEqComponentsElim1" (pt "RealVecConstr(as::as0:)(M::M0:)") (pt "RealVecConstr(as1::as2:)(M1::M2:)") "CompatInstInd")
(cut "all n(n<(RealVecConstr(as::as0:)(M::M0:))dim ->RealVecConstr(as::as0:)(M::M0:)__n===RealVecConstr(as1::as2:)(M1::M2:)__n)")
(assume "CompatInstIndx")
(inst-with-to "RealVectorRealVecConstrRealComponentWise" (pt "(RealVecConstr(as::as0:)(M::M0:))seqs") (pt "(RealVecConstr(as::as0:)(M::M0:))mods") "InstIndx")
(cut "all n(n<(RealVecConstr(RealVecSeqs(RealVecConstr(as::as0:)(M::M0:))) (RealVecMods(RealVecConstr(as::as0:)(M::M0:))))dim -> Real(RealConstr(RealVecSeqs(RealVecConstr(as::as0:)(M::M0:))__n)(RealVecMods(RealVecConstr(as::as0:)(M::M0:))__n)))")
(assume "InstIndxcut")
(inst-with-to "RealVectorRealVecConstrRealComponentWise" (pt "(RealVecConstr(as1::as2:)(M1::M2:))seqs") (pt "(RealVecConstr(as1::as2:)(M1::M2:))mods") "InstIndy")
(cut "all n(n<(RealVecConstr(RealVecSeqs(RealVecConstr(as1::as2:)(M1::M2:)))(RealVecMods(RealVecConstr(as1::as2:)(M1::M2:))))dim ->Real(RealConstr(RealVecSeqs(RealVecConstr(as1::as2:)(M1::M2:))__n)(RealVecMods(RealVecConstr(as1::as2:)(M1::M2:))__n)))")
(assume "InstIndycut")
(simp "Vsqr0CompRule")
(simp "Vsqr0CompRule")
(ng #t)
(use "RealEqTrans" (pt "(RealConstr as M)*(RealConstr as M)+(RealConstr as0 M0)*(RealConstr as0 M0)"))
(ng #t)
(use "RealEqRefl")
(inst-with-to "Assertion" (pt "RealVecConstr(as::as0:)(M::M0:)") "Inst1")
(ng "Inst1")
(use "Inst1")
(auto)
(use "RealVectorEqElim0" (pt "RealVecConstr(as1::as2:)(M1::M2:)"))
(auto)
(use "RealEqTrans" (pt "(RealConstr as1 M1)*(RealConstr as1 M1)+(RealConstr as2 M2)*(RealConstr as2 M2)"))
(use "RealPlusCompat")
(use "RealTimesCompat")
(inst-with-to "CompatInstIndx" (pt "Zero") "Inst1")
(ng "Inst1")
(use "Inst1")
(auto)
(inst-with-to "CompatInstIndx" (pt "Zero") "Inst1")
(ng "Inst1")
(use "Inst1")
(auto)
(use "RealTimesCompat")
(inst-with-to "CompatInstIndx" (pt "Succ Zero") "Inst1")
(ng "Inst1")
(use "Inst1")
(auto)
(inst-with-to "CompatInstIndx" (pt "Succ Zero") "Inst1")
(ng "Inst1")
(use "Inst1")
(auto)
(ng #t)
(use "RealEqRefl")
(inst-with-to "Assertion" (pt "RealVecConstr(as1::as2:)(M1::M2:)") "Inst1")
(ng "Inst1")
(use "Inst1")
(auto)
(use "RealVectorEqElim1" (pt "RealVecConstr(as::as0:)(M::M0:)"))
(auto)
(use "InstIndy")
(use "RealVectorEqElim1" (pt "RealVecConstr(as::as0:)(M::M0:)"))
(ng #t)
(auto)
(use "InstIndx")
(use "RealVectorEqElim0" (pt "RealVecConstr(as1::as2:)(M1::M2:)"))
(auto)
(assume "M3")
(assume "MVs")
(assume "T")
(assume "TT")
(assume "Rx=y")
(inst-with-to "RealVectorCompatibleElim2" (pt "RealVecConstr(as::as0:)(M::M0:)") (pt "RealVecConstr(as1::as2:)(M1::M2::M3::MVs)") "CompatInst")
(use "Efq")
(use "CompatInst")
(use "RealVectorEqComponentsElim0")
(auto)
(assume "as3")
(assume "vVs" "MVs")
(assume "T" "TT")
(assume "Rx=y")
(inst-with-to "RealVectorCompatibleElim2" (pt "RealVecConstr(as::as0:)(M::M0:)") (pt "RealVecConstr(as1::as2::as3::vVs)MVs") "CompatInst")
(ng "CompatInst")
(cut "Succ(Succ Zero)=[if (Succ(Succ(Succ((ListLength nat=>rat)vVs)))=(ListLength pos=>nat)MVs)(Succ(Succ(Succ((ListLength nat=>rat)vVs))))Zero]")
(cases (pt "(Succ(Succ(Succ((ListLength nat=>rat)vVs)))=(ListLength pos=>nat)MVs)"))
(assume "case")
(ng #t)
(use "Efq")
(assume "case2")
(ng #t)
(use "Efq")
(use "CompatInst")
(use "RealVectorEqComponentsElim0")
(auto)
(assume "M1" "MVs" "yy")
(ng #t)
(use "Efq")
(assume "as1")
(assume "vVs" "MVs" "yy")
(ng #t)
(cases (pt "(Succ(Succ(Succ((ListLength nat=>rat)vVs)))=(ListLength pos=>nat)MVs)"))
(assume "case1")
(ng #t)
(assume "T")
(use "Efq")
(assume "case2")
(ng #t)
(use "Efq")
(save "SqCmapContmv")


;; euclidean norm 

(set-goal "all xxseq,FF,xx0 (ProperRHS FF (xx0 dim) ->SolutionSim xxseq FF xx0 -> all n (xxseq (Succ n))===FF(xxseq n))")
(assume "xxseq" "FF" "xx0")
(assume "PRHS")
(assume "SolSim")
(assume "n")
(use "RealVectorEqTrans" (pt "Simulation (Succ n) xx0 FF"))
(use "SolutionSimElim0")
(use "SolSim")
(simp "Simulation1CompRule")
(use "ProperRHSElim2" (pt "xx0 dim"))
(auto)
(use "ProperSimulationDim")
(auto)
(use "SolutionSimElim4" (pt "FF"))
(auto)
(use "RealVectorEqSym")
(use "SolutionSimElim0")
(auto)
(save "SolutionStepRewrite")





(deanimate "RatLeAbsBoundPosSharp")


(set-goal "ClassKappaInverse (ContexApplication sqrb) (UCFallApplication (UCFallConstr hsqrt hsqrtmod))")
(use "ClassKappaInverseIntro")
(use "SqrIsClassKappa")
(use "UCFallCfmapCont")
(use "UCFallsqrt")
(assume "x" "0lex")
(use "RealEqTrans" (pt "Rsqrt(x*x)"))
(simp "Rsqrt0CompRule")
(use "UCFallApplicationCompat")
(use "UCFallsqrt")
(use "sqrRewrite")
(autoreal)
(simpreal "RealSqrtProp3")
(use "RealSqrtProp")
(auto)
(assume "y" "0ley")
(simpreal "sqrRewrite")
(use "RealSqrtProp")
(auto)
(use "UCFallApplicationReal")
(use "UCFallsqrt")
(autoreal)
(assume "x" "0lex")
(use "RsqrtNNeg")
(auto)
(assume "x" "Rx" "ExEx")
(assert "all x( UCFall(UCFallConstr hsqrt hsqrtmod) ->Real x -> exl p RealLt 0 x p -> exl p RealLt 0(UCFallConstr hsqrt hsqrtmod x)p)")
(cases)
(assume "as" "M")
(assume "UCF")
(assume "Ras")
(assume "exHyp")
(use "EtaWitToStrIncUCFall" (pt "[p] PosS(PosS(p))"))
(use "UCFallsqrt")
(assume "a" "p")
(assume "cond")
(simp "UCFallApplication0CompRule")
(simp "RealLt0CompRule")
(simp "RealMinus0CompRule")
(simp "RealUMinus0CompRule")
(simp "RealPlus0CompRule")
(simp (pf "([p0]PosS(PosS p0))p=PosS(PosS p)"))
(use "RealPosChar2" (pt "Zero"))
(simp "<-" "RealPlus0CompRule")
(simp "<-" "RealUMinus0CompRule")
(simp "<-" "UCFallApplication0CompRule")
(use "RealPlusReal")
(use "UCFallApplicationReal")
(auto)
(autoreal)
(assume "n" "cond2")
(assert "0<a")
(use "RatLtLeTrans" (pt "(1#2**PosS p)"))
(auto)
(assume "case")
(simp "case")
(ng #t)
(use "RatLeTrans" (pt "(1#2**PosS p) min (1#1)"))
(ng #t)
(use "Truth")
(use "RatLeTrans" (pt "sqrtmap a (Succ((cNatPos(PosToNat(cNatPos(Succ(Succ n))))+cRatLeAbsBound((1+a)*(1#2)+ ~(a*RatUDiv((1+a)*(1#2)))))))"))
(use "SqrtSeqLeftB")
(auto)
(assume "cond")
(assert "exl p RealLt 0(UCFallConstr hsqrt hsqrtmod x)p")
(by-assume "ExEx" "p0" "ExHypProp" )
(use "cond")
(use "UCFallsqrt")
(auto)
(intro 0 (pt "p0"))
(auto)
(assume "cond2")
(by-assume "cond2" "p1" "cond2Prop")
(intro 0 (pt "p1"))
(auto)
(save "SqrtIsClassKappaInverse")



;;(add-global-assumption "TwoNormVectorNorm" "VectorNorm RealVectorTwoNorm")

(deanimate "RealBound")
(deanimate "RatLeAbsBound")



(set-goal "all xx0 (RealVector xx0 ->  xx0 dim=2 -> PDVNorm Vsqr(xx0 dim)(ContexApplication sqrb)(ContexApplication sqrb) RealVectorTwoNorm)")
(assume "xx0" "Rv" "dimcond")
(use "PDVNormIntro")
(use "TwoNormVectorNorm")
(cases)
(cases)
(assume "MVs")
(assume "Ras")
(assume "LyapunovConfig V")
(use "Efq")
(inst-with-to "LyapunovConfigElim1" (pt "Vsqr") (pt "xx0 dim") (pt "(RealVecConstr(Nil nat=>rat)MVs)") "LyapunovConfigInst")
(ng "LyapunovConfigInst")
(use "LyapunovConfigInst")
(ng "LyapunovConfigInst")
(use "LyapunovConfig V")
(assume "as")
(cases)
(assume "MVs")
(assume "Ras")
(simp "dimcond")
(assume "LyapunovConfig V")
(inst-with-to "LyapunovConfigElim2" (pt "Vsqr") (pt "PosToNat 2") (pt "RealVecConstr as:MVs") "LyapunovConfigInst")
(ng "LyapunovConfigInst")
(cut "[if (Succ Zero=(ListLength pos=>nat)MVs)(Succ Zero)Zero]=Succ(Succ Zero)")
(cases (pt "(Succ Zero=(ListLength pos=>nat)MVs)"))
(assume "case1")
(assume "Falsity")
(use "Efq")
(use "Falsity")
(assume "case2" "Falsity")
(ng "Falsity")
(use "Efq")
(use "Falsity")
(auto)
(assume "as0")
(cases)
(cases)
(assume "Rv0")
(use "Efq")
(use "CauchyVectorInvalid0" (pt "as::as0:" ))
(auto)
(use "RealVectorConstrElim0")
(use "Rv0")
(assume "M")
(cases)
(assume "Rv0")
(cut "Lh (as::as0:)=Lh (M:)")
(assume "cutInst")
(ng "cutInst")
(use "Efq")
(use "cutInst")
(use "RealVectorElim2")
(use "Rv0")
(assume "M0")
(cases)
(assume "Rv0")
(assume "Lyap")
(inst-with-to "CmapContmvElim0" (pt "Vsqr") (pt "PosToNat 2") "InstContV" )
(cut "all xx(Zero<xx dim ->xx dim=PosToNat 2 -> RealVector xx -> Real(Vsqr xx))")
(assume "RealCut")
(inst-with-to "RealCut" (pt "RealVecConstr(as::as0:)(M::M0:)") "RealCutInst")
(split)
(cut "Real(Vsqr(RealVecConstr(as::as0:)(M::M0:)))")
(assume "Rvv")
(simpreal "sqrRewrite")
(simpreal "EuclideanSqrProp")
(use "RealLeReflNC")
(use "RealEqSToEq")
(use "RealRealVectorTwoNormSqr")
(auto)
(use "RealEqSIntro")
(ng #t)
(auto)
(simp "RealVectorTwoNorm0CompRule")
(use "RealSqrtReal")
(use "RealRealVectorTwoNormSqr")
(use "Rv0")
(use "InstContV")
(use "SqCmapContmv")
(ng #t)
(use "Truth")
(ng #t)
(use "Truth")
(use "Rv0")
(use "RealLeReflNC")
(cut "Real(Vsqr(RealVecConstr(as::as0:)(M::M0:)))")
(assume "Rvv")
(simpreal "sqrRewrite")
(simpreal "EuclideanSqrProp")
(use "RealEqSToEq")
(use "Rvv")
(use "RealRealVectorTwoNormSqr")
(use "Rv0")
(use "RealEqSIntro")
(ng #t)
(auto)
(simp "RealVectorTwoNorm0CompRule")
(use "RealSqrtReal")
(use "RealRealVectorTwoNormSqr")
(auto)
(use "InstContV")
(use "SqCmapContmv")
(assume "M1" "MVs")
(assume "Rxx")
(cut "Lh (as::as0:)=Lh (M::M0::M1::MVs)")
(assume "Falsity")
(ng "Falsity")
(use "Efq")
(use "Falsity")
(use "RealVectorElim2")
(use "Rxx")
(assume "as1" "vVs" "MVs" "Rv0")
(assume "LyapunovConfigInst")
(inst-with-to "LyapunovConfigElim2" (pt "Vsqr") (pt "PosToNat 2") (pt "RealVecConstr(as::as0::as1::vVs)MVs") "LyapConf")
(ng "LyapConf")
(cut "[if (Succ(Succ(Succ((ListLength nat=>rat)vVs)))=(ListLength pos=>nat)MVs) (Succ(Succ(Succ((ListLength nat=>rat)vVs))))Zero]=Succ(Succ Zero)")
(cases (pt "(Succ(Succ(Succ((ListLength nat=>rat)vVs)))=(ListLength pos=>nat)MVs)"))
(assume "case1")
(assume "Falsity")
(ng "Falsity")
(use "Efq")
(use "Falsity")
(assume "case2")
(assume "Falsity")
(ng "Falsity")
(use "Efq")
(use "Falsity")
(use "LyapConf")
(simp (pf "(Succ(Succ Zero))=xx0 dim"))
(use "LyapunovConfigInst")
(simp "dimcond")
(auto)
(save "VsqrPDVNorm")

(set-goal "all xx0,xxseq(RealVector xx0 -> xx0 dim=2 -> SolutionSim xxseq fAB xx0 -> PDVDiff Vsqr xxseq fAB xx0)")
(assume "xx0" "xxseq" "Rv" "dimcond" "SolSim")
(use "PDVDiffIntro")
(simp "dimcond")
(use "SqCmapContmv")
(auto)
(assume "n")
(cut "all n (xxseq n) dim = PosToNat 2")
(assume "dimcond2")
(use "RealLeTrans" (pt "Vsqr(fAB(xxseq n))"))
(use "RealLeReflNC")
(use "CmapContmvElim1" (pt "PosToNat 2"))
(use "SqCmapContmv")
(simp "dimcond2")
(auto)
(use "SolutionStepRewrite" (pt "xx0"))
(simp "dimcond")
(use "ProperRHSfAB")
(auto)
(assert "all xx (xx dim =2 ->  RealVector xx ->  Vsqr(fAB(xx))<<=Vsqr(xx)) ")
(cases)
(cases)
(assume "MVs")
(ng #t)
(use "Efq")
(assume "as")
(cases)
(assume "MVs")
(ng #t)
(cases (pt "(Succ Zero=(ListLength pos=>nat)MVs)"))
(assume "case1")
(ng #t)
(use "Efq")
(assume "case2")
(ng #t)
(use "Efq")
(assume "as0")
(cases)
(cases)
(ng #t)
(use "Efq")
(assume "M")
(cases)
(ng #t)
(use "Efq")
(assume "M0")
(cases)
(assume "dimcond3")
(assume "Rv0")
(use "RealLeSToLe")
(use "CmapContmvElim0" (pt "PosToNat 2"))
(use "SqCmapContmv")
(auto)
(use "ProperRHSElim1" (pt "PosToNat 2"))
(use "ProperRHSfAB")
(auto)
(use "CmapContmvElim0" (pt "PosToNat 2"))
(use "SqCmapContmv")
(auto)
(use "RealLeSIntro")
(use "RealNNegSIntro")
(assume "n0")
(ng #t)
(cut "all a 0<(1+a*a)*(1+a*a)")
(assume "cutInst1")
(cut "all a 0<(1+a*a)")
(assume "cutInst2")
(simprat (pf "as0 n0*RatUDiv(1+as n0*as n0)*as0 n0*RatUDiv(1+as n0*as n0)==as0 n0*as0 n0*RatUDiv(1+as n0*as n0)*RatUDiv(1+as n0*as n0)"))
(simprat (pf "as n0*RatUDiv(1+as0 n0*as0 n0)*as n0*RatUDiv(1+as0 n0*as0 n0)==as n0*as n0*RatUDiv(1+as0 n0*as0 n0)*RatUDiv(1+as0 n0*as0 n0)"))
(use "RatLeTimesCancelR" (pt "(1+as0 n0*as0 n0)*(1+as0 n0*as0 n0)"))
(use "cutInst1")
(ng #t)
(use "RatLeTimesCancelR" (pt "(1+as n0*as n0)*(1+as n0*as n0)"))
(use "cutInst1")
(ng #t)
(inst-with-to "RatSubVar" (pt "(1+as n0*as n0)") "sub1")
(by-assume "sub1" "a1" "sub1Prop")
(inst-with-to "RatSubVar" (pt "(1+as0 n0*as0 n0)") "sub2")
(by-assume "sub2" "a2" "sub2Prop")
(simprat "sub1Prop")
(simprat "sub2Prop")
(inst-with-to "RatSubVar" (pt "(as n0*as n0)") "sub3")
(by-assume "sub3" "a3" "sub3Prop")
(inst-with-to "RatSubVar" (pt "(as0 n0*as0 n0)") "sub4")
(by-assume "sub4" "a4" "sub4Prop")
(simprat "sub3Prop")
(simprat "sub4Prop")
(ng #t)
(simprat "RatTimesPlusDistrLeft")
(simprat "RatTimesPlusDistrLeft")
(simprat (pf " ~(a3*RatUDiv a2*RatUDiv a2)*a2*a2== ~a3"))
(simprat "RatTimesPlusDistrLeft")
(simprat "RatTimesPlusDistrLeft")
(simprat "RatTimesPlusDistrLeft")
(simprat "RatTimesPlusDistrLeft")
(simprat "RatTimesPlusDistrLeft")
(simprat "RatTimesPlusDistrLeft")
(simprat "RatTimesPlusDistrLeft")
(simprat "RatTimesPlusDistrLeft")
(simprat "RatTimesPlusDistrLeft")
(simprat "RatTimesPlusDistrLeft")
(simprat (pf "~(a4*RatUDiv a1*RatUDiv a1)*a2*a2*a1*a1== ~(a4)*a2*a2"))
(simp "RatPlusComm")
(ng #t)
(simp "<-" "RatPlusAssoc")
(use "RatLeTrans" (pt "(0#1)+(0#1)"))
(auto)
(ng #t)
(use "RatLeRefl")
(simp "<-" "RatTimesAssoc")
(simp "<-" "RatTimesAssoc")
(simp "<-" "RatTimesAssoc")
(use "RatTimesZeroL")
(use "RatLeMonPlus")
(simp "RatPlusComm")
(ng #t)
(use "RatLeTrans" (pt "a3*a1*a1*(a2*a2 + ~(1))"))
(use "RatLeTimesMonR")
(simp "<-" "RatTimesAssoc")
(use "RatLeTimesMonR")
(simprat "<-" "sub3Prop")
(auto)
(simprat "<-" "sub2Prop")
(simprat "RatBinomForm1")
(ng #t)
(simp "RatPlusComm")
(ng #t)
(use "RatLeTrans" (pt "(0#1)+0"))
(auto)
(use "RatLeMonPlus")
(simp "<-" "RatTimesAssoc")
(use "RatLeTimesMonR")
(auto)
(simprat "<-" "RatExpTwoE")
(simp "RatTimesIdPos")
(auto)
(simprat "RatTimesPlusDistr")
(use "RatLeMonPlus")
(simp "RatTimesComm")
(use "RatEqvToLe")
(ng #t)
(use "RatTimesCompat")
(use "RatTimesCompat")
(simp "RatTimesComm")
(ng #t)
(auto)
(use "RatLeTrans" (pt "a4*a2*a2*(a1*a1 + ~1)"))
(use "RatLeTimesMonR")
(simp "<-" "RatTimesAssoc")
(use "RatLeTimesMonR")
(simprat "<-" "sub4Prop")
(auto)
(simprat "<-" "sub1Prop")
(simprat "RatBinomForm1")
(ng #t)
(simp "RatPlusComm")
(ng #t)
(use "RatLeTrans" (pt "(0#1)+0"))
(auto)
(use "RatLeMonPlus")
(simp "<-" "RatTimesAssoc")
(use "RatLeTimesMonR")
(auto)
(simprat "<-" "RatExpTwoE")
(simp "RatTimesIdPos")
(auto)
(simprat "RatTimesPlusDistr")
(ng #t)
(use "Truth")
(ng #t)
(simprat (pf "a4*RatUDiv a1*RatUDiv a1==(RatUDiv a1*RatUDiv a1)*a4"))
(simp "<-" "RatTimesAssoc")
(simp "RatTimesComm")
(ng #t)
(simprat (pf "a1*a1*RatUDiv a1*RatUDiv a1==1"))
(auto)
(simp "RatTimesComm")
(ng #t)
(simprat (pf "RatUDiv a1*a1==1"))
(ng #t)
(simprat (pf "a1*RatUDiv a1==1"))
(auto)
(use "RatTimesUDivR")
(simprat "<-" "sub1Prop")
(use "RatLtLeTrans" (pt "1+as n0*as n0"))
(use "cutInst2")
(auto)
(simp "RatTimesComm")
(use "RatTimesUDivR")
(simprat "<-" "sub1Prop")
(use "RatLtLeTrans" (pt "1+as n0*as n0"))
(use "cutInst2")
(auto)
(simp "<-" "RatTimesAssoc")
(simp "RatTimesComm")
(ng #t)
(use "Truth")
(ng #t)
(use "RatEqvTrans" (pt "a3*1"))
(simp "<-" "RatTimesAssoc")
(simp "<-" "RatTimesAssoc")
(simp "<-" "RatTimesAssoc")
(use "RatTimesCompat")
(auto)
(simp "RatTimesComm")
(ng #t)
(simprat (pf "RatUDiv a2*a2==1"))
(ng #t)
(use "RatTimesUDivR")
(simprat "<-" "sub2Prop")
(use "RatLtLeTrans" (pt "1+as0 n0*as0 n0"))
(auto)
(simp "RatTimesComm")
(use "RatTimesUDivR")
(simprat "<-" "sub2Prop")
(use "RatLtLeTrans" (pt "1+as0 n0*as0 n0"))
(auto)
(use "RatTimesCompat")
(simp "RatTimesComm")
(ng #t)
(use "Truth")
(use "RatUDivCompat")
(auto)
(use "RatTimesCompat")
(simp "RatTimesComm")
(auto)
(assume "a")
(use "RatLtLeTrans" (pt "(1#1)+0"))
(auto)
;;(use "RatLeMonPlus")
(auto)
(assume "a")
(simprat "RatBinomForm1")
(ng #t)
(use "RatLtLeTrans" (pt "(1#1)+(0#1)+(0#1)"))
(auto)
(use "RatLeMonPlus")
(use "RatLeMonPlus")
(auto)
(simp "<-" "RatTimesAssoc")
(use "RatLeTimesMonR")
(auto)
(simprat "<-" "RatExpTwoE")
(use "RatLeTimesMonR")
(auto)
(assume "M1")
(assume "MVs")
(assume "dimcond3")
(ng "dimcond3")
(use "Efq")
(use "dimcond3")
(assume "as1" "vVs" "MVs")
(assume "dimcond3")
(use "Efq")
(ng "dimcond3")
(cut "[if (Succ(Succ(Succ((ListLength nat=>rat)vVs)))=(ListLength pos=>nat)MVs)(Succ(Succ(Succ((ListLength nat=>rat)vVs))))Zero]=Succ(Succ Zero)")
(cases (pt "(Succ(Succ(Succ((ListLength nat=>rat)vVs)))=(ListLength pos=>nat)MVs)"))
(ng #t)
(assume "cutInst")
(use "Efq")
(assume "Assertion")
(ng #t)
(use "Efq")
(use "dimcond3")
(assume "condLes")
(use "condLes")
(simp "dimcond2")
(auto)
(use "SolutionSimElim2" (pt "xx0") (pt "fAB"))
(use "SolSim")
(assume "n0")
(simp "<-" "dimcond")
(simp "SolutionSimElim4" (pt "fAB"))
(auto)
(simp "dimcond")
(use "ProperRHSfAB")
(auto)
(save "VsqrtfABPDVDiff")


(set-goal "all xx0,xxseq(RealVector xx0 -> xx0 dim=2 -> SolutionSim xxseq fAB xx0 -> StableEqLeReaNorm xxseq fAB xx0 RealVectorTwoNorm)")
(assume "xx0" "xxseq" "Rx" "dimcond" "SolSim" )
(use "UniformLyapunovStableLeAllNorm" (pt "Vsqr") (pt "ContexApplication sqrb") (pt "ContexApplication sqrb") (pt "UCFallApplication (UCFallConstr hsqrt hsqrtmod)"))
(simp "dimcond")
(use "ProperRHSfAB")
(use "LyapunovConfigIntro")
(simp "dimcond")
(use "SqCmapContmv")
(simp "dimcond")
(auto)
(use "SqrIsClassKappa")
(use "SqrIsClassKappa")
(use "SqrtIsClassKappaInverse")
(use "VsqrPDVNorm")
(auto)
(use "VsqrtfABPDVDiff")
(auto)
(save "UniformlyStableLeEx1")


(set-goal "all xx0,xxseq(RealVector xx0 -> xx0 dim=2 -> SolutionSim xxseq fAB xx0 -> StableEqLtReaNorm xxseq fAB xx0 RealVectorTwoNorm)")
(assume "xx0")
(assume "xxseq")
(assume "Rv" "dimcond" "SolSim")
(use "UniformLyapunovStableLtAllNorm" (pt "Vsqr") (pt "ContexApplication sqrb") (pt "ContexApplication sqrb") (pt "UCFallApplication (UCFallConstr hsqrt hsqrtmod)"))
(simp "dimcond")
(use "ProperRHSfAB")
(use "LyapunovConfigIntro")
(simp "dimcond")
(use "SqCmapContmv")
(simp "dimcond")
(auto)
(use "SqrIsClassKappaPos")
(use "SqrIsClassKappaPos")
(use "SqrtIsClassKappaInverse")
(use "VsqrPDVNorm")
(auto)
(use "VsqrtfABPDVDiff")
(auto)
(save "UniformlyStableLtEx1")

(set-goal "all xx (xx dim = 2 -> xx eqd (ListReaToRealVector (xx__Zero::(xx__(Succ Zero)):)))")
(cases)
(cases)
(assume "MVs")
(ng #t)
(use "Efq")
(assume "as")
(cases)
(ng #t)
(assume "MVs")
(cases (pt "(Succ Zero=(ListLength pos=>nat)MVs)"))
(assume "case")
(ng #t)
(use "Efq")
(assume "case")
(ng #t)
(use "Efq")
(assume "as0")
(cases)
(cases)
(ng #t)
(use "Efq")
(assume "M")
(cases)
(ng #t)
(use "Efq")
(assume "M0")
(cases)
(ng #t)
(assume "T")
(use "InitEqD")
(assume "M1")
(assume "MVs")
(ng #t)
(use "Efq")
(assume "as1" "vVs" "MVs")
(ng #t)
(cases (pt "Succ(Succ(Succ((ListLength nat=>rat)vVs)))=(ListLength pos=>nat)MVs"))
(assume "case")
(ng #t)
(use "Efq")
(assume "case")
(ng #t)
(use "Efq")
(save "RealVecTwoDimSub")

(set-goal "all x (Real x -> Real(RealConstr (x seq) (x mod)))")
(cases)
(auto)
(save "RealXToRealConstr")

(set-goal "all xx,repsilon,p (Real repsilon -> RealLt 0 repsilon p -> RealVector xx -> xx dim =2 -> exr rdelta,q(Real rdelta & RealLt 0 rdelta q & (RealVectorTwoNorm xx<<=rdelta -> Vsqr xx<<=repsilon)))")
(assume "xx" "repsilon" "p")
(assume "Reps" "0<eps")
(assume "Rx" "dimcond")
(intro 0 (pt "Rsqrt repsilon"))
(inst-with-to "ClassKappaInverseElim5" (pt "(ContexApplication sqrb)") (pt "(UCFallApplication(UCFallConstr hsqrt hsqrtmod))") "Inst")
(assert "all x(Real x -> exr p RealLt 0 x p -> exr p RealLt 0(UCFallConstr hsqrt hsqrtmod x)p)")
(use "Inst")
(use "SqrtIsClassKappaInverse")
(assume "Inst2")
(inst-with-to "Inst2" (pt "repsilon") "Inst3")
(assert "exr p RealLt 0(UCFallConstr hsqrt hsqrtmod repsilon)p")
(use "Inst3")
(auto)
(intro 0 (pt "p"))
(use "0<eps")
(assume "PosInst")
(by-assume "PosInst" "q" "PosInstProp")
(intro 0 (pt "q"))
(split)
(use "RealSqrtReal")
(autoreal)
(split)
(simp "Rsqrt0CompRule")
(use "PosInstProp")
(simp "RealVectorTwoNorm0CompRule")
(assume "Cnd")
(cut "Real(xx__Zero)")
(assume "Rx0")
(cut "Real(xx__Succ Zero)")
(assume "Rx1")
(use "RealLeTrans" (pt "RealVectorTwoNormSqr xx"))
(simp "RealVecTwoDimSub")
(simp "Vsqr0CompRule")
(use "RealLeReflNC")
(use "RealEqSToEq")
(use "RealPlusReal")
(use "RealTimesReal")
(ng #t)
(use "RealXToRealConstr")
(auto)
(use "RealXToRealConstr")
(auto)
(use "RealTimesReal")
(ng #t)
(use "RealXToRealConstr")
(auto)
(use "RealXToRealConstr")
(auto)
(use "RealRealVectorTwoNormSqr")
(simp "<-" "RealVecTwoDimSub") 
(auto)
(use "RealEqSIntro")
(ng #t)
(auto)
(simpreal (pf "RealVectorTwoNormSqr xx===Rsqrt(RealVectorTwoNormSqr xx)*Rsqrt(RealVectorTwoNormSqr xx)"))
(simpreal (pf "repsilon===Rsqrt repsilon*Rsqrt repsilon"))
(use "RealLeMonTimesTwo")
(use "RealLeToRealNNeg")
(use "RsqrtNNeg")
(use "RealVectorTwoNormSqrNNeg")
(auto)
(use "RealLeToRealNNeg")
(use "RsqrtNNeg")
(use "RealVectorTwoNormSqrNNeg")
(auto)
(use "RealEqSym")
(use "RealSqrtProp")
(auto)
(use "RealLtToLe" (pt "p"))
(realproof)
(realproof)
(auto)
(use "RealEqSym")
(use "RealSqrtProp")
(auto)
(use "RealVectorTwoNormSqrNNeg")
(auto)
(use "RealVectorRealComponentWise")
(auto)
(simp "dimcond")
(auto)
(use "RealVectorRealComponentWise")
(auto)
(simp "dimcond")
(auto)
(save "VsqrModulusStab")


(set-goal "all xx0,xxseq(RealVector xx0 -> xx0 dim=2 -> SolutionSim xxseq fAB xx0 -> StableEqLeReaNorm xxseq fAB xx0 RealVectorTwoNorm)")
(assume "xx0" "xxseq" "Rx" "dimcond" "SolSim" )
(use "LyapunovStableLe" (pt "Vsqr") (pt "ContexApplication sqrb") )
(use "TwoNormVectorNorm")
(simp "dimcond")
(use "ProperRHSfAB")
(use "LyapunovConfigIntro")
(simp "dimcond")
(use "SqCmapContmv")
(simp "dimcond")
(auto)
(use "SqrIsClassKappaPos")
(use "PDVNormSimpleIntro")
(use "TwoNormVectorNorm")
(assume "xx" "Rxx" "LyapConfig") 
(use "PDVNormElim0" (pt "xx0 dim") (pt "ContexApplication sqrb"))
(use "VsqrPDVNorm")
(auto)
(assume "xx" "repsilon" "p")
(assume "cond1")
(assume "cond2")
(assume "cond3")
(assume "cond4")
(use "VsqrModulusStab" (pt "p"))
(auto)
(simp "cond4")
(auto)
(use "VsqrtfABPDVDiff")
(auto)
(save "StableLeEx1")

(set-goal "all xx0,xxseq(RealVector xx0 -> xx0 dim=2 -> SolutionSim xxseq fAB xx0 -> StableEqLtReaNorm xxseq fAB xx0 RealVectorTwoNorm)")
(assume "xx0" "xxseq" "Rx" "dimcond" "SolSim" )
(use "LyapunovStableLt" (pt "Vsqr") (pt "ContexApplication sqrb") )
(use "TwoNormVectorNorm")
(simp "dimcond")
(use "ProperRHSfAB")
(use "LyapunovConfigIntro")
(simp "dimcond")
(use "SqCmapContmv")
(simp "dimcond")
(auto)
(use "SqrIsClassKappaPos")
(use "PDVNormSimpleIntro")
(use "TwoNormVectorNorm")
(assume "xx" "Rxx" "LyapConfig") 
(use "PDVNormElim0" (pt "xx0 dim") (pt "ContexApplication sqrb"))
(use "VsqrPDVNorm")
(auto)
(assume "xx" "repsilon" "p")
(assume "cond1")
(assume "cond2")
(assume "cond3")
(assume "cond4")
(use "VsqrModulusStab" (pt "p"))
(auto)
(simp "cond4")
(auto)
(use "VsqrtfABPDVDiff")
(auto)
(save "StableLtEx1")

(set-goal "all xx0,xxseq(RealVector xx0 -> xx0 dim=2 -> SolutionSim xxseq fAB xx0 -> StableEqLtReaNorm xxseq fAB xx0 RealVectorTwoNorm)")
(assume "xx0" "xxseq" "Rx" "dimcond" "SolSim" )
(use "LyapunovStableLtClass" (pt "Vsqr") (pt "ContexApplication sqrb") )
(use "TwoNormVectorNorm")
(simp "dimcond")
(use "ProperRHSfAB")
(use "LyapunovConfigIntro")
(simp "dimcond")
(use "SqCmapContmv")
(simp "dimcond")
(auto)
(use "SqrIsClassKappaPos")
(use "PDVNormSimpleIntro")
(use "TwoNormVectorNorm")
(assume "xx" "Rxx" "LyapConfig") 
(use "PDVNormElim0" (pt "xx0 dim") (pt "ContexApplication sqrb"))
(use "VsqrPDVNorm")
(auto)
(assume "xx" "repsilon" "p")
(assume "cond1")
(assume "cond2")
(assume "cond3")
(assume "cond4")
(use "VsqrModulusStab" (pt "p"))
(auto)
(simp "cond4")
(auto)
(use "VsqrtfABPDVDiff")
(auto)
(save "StableLtEx1Class")

(display-global-assumptions)