;; Type contex: family of uniformly continuous functions R=>R

(display "loading ucf.scm")(newline)


(add-alg
 "contex"
 (list "ContexConstr" "(rat=>nat=>rat)=>(rat=>rat=>pos=>nat)=>(rat=>rat=>pos=>pos)=>contex"))
(add-totality "contex")

(add-var-name "fex" (py "contex"))

(add-var-name "alcd" (py "rat=>rat=>pos=>nat"))

(add-var-name "omcd" (py "rat=>rat=>pos=>pos"))


(add-program-constant "ContexApprox" (py "contex=>(rat=>nat=>rat)") t-deg-zero 'const 1)
(add-postfix-display-string "ContexApprox" "approxex")

(add-computation-rule "(ContexConstr h alcd omcd)approxex" "h" )


(set-goal "all fex TotalContex fex")
(cases)
(assume "h" "alcd" "omcd")
(use "TotalContexContexConstr")
(use "AllTotalElim")
(assume "a")
(use "AllTotalElim")
(assume "n")
(use "RatTotalVar")
(use "AllTotalElim")
(assume "a")
(use "AllTotalElim")
(assume "b")
(use "AllTotalElim")
(assume "p")
(use "NatTotalVar")
(use "AllTotalElim")
(assume "a")
(use "AllTotalElim")
(assume "b")
(use "AllTotalElim")
(assume "p")
(use "PosTotalVar")
(save "ContexTotalVar")


(set-totality-goal "ContexApprox")
(use "AllTotalElim")
(cases)
(assume "h" "alcd" "omcd")
(use "AllTotalElim")
(assume "a")
(use "AllTotalElim")
(assume "n")
(ng #t)
(use "RatTotalVar")
(save-totality)

(add-program-constant "ContexMod" (py "contex=>(rat=>rat=>pos=>nat)") t-deg-zero 'const 1)
(add-postfix-display-string "ContexMod" "modex")
(add-computation-rule "(ContexConstr h alcd omcd)modex" "alcd") 

(set-totality-goal "ContexMod")
(use "AllTotalElim")
(cases)
(assume "h" "alcd" "omcd")
(use "AllTotalElim")
(assume "a")
(use "AllTotalElim")
(assume "b")
(use "AllTotalElim")
(assume "p")
(ng #t)
(use "NatTotalVar")
(save-totality)


(add-ids
 (list (list "Contex" (make-arity (make-alg "contex"))))
 '("allnc h,alcd,omcd(
     all a,c,d(c<=d -> c<=a -> a<=d -> Cauchy(h a)(alcd c d)) --> 
     all a,b,c,d,p,n(c<=d -> c<=a -> a<=d -> c<=b -> b<=d ->
                  alcd c d p<=n -> 
                  abs(a-b)<=1/2**(PosPred(omcd c d p)) ->
                  abs(h a n-h b n)<=1/2**p) -->
     all p,q,c,d(p<=q -> alcd c d p<=alcd c d q) -->
     all p,q,c,d(p<=q -> omcd c d p<=omcd c d q) -->
     Contex(ContexConstr h alcd omcd))" "ContexIntro"))

(animate "RatLeAbsBoundPos")


(add-program-constant "ContexModC" (py "contex=>(rat=>rat=>pos=>pos)") t-deg-zero 'const 1)
(add-postfix-display-string "ContexModC" "modcex")
(add-computation-rule "(ContexConstr h alcd omcd)modcex" "omcd")

(set-totality-goal "ContexModC")
(use "AllTotalElim")
(cases)
(assume "h" "alcd" "omcd")
(use "AllTotalElim")
(assume "a")
(use "AllTotalElim")
(assume "b")
(use "AllTotalElim")
(assume "p")
(ng #t)
(use "PosTotalVar")
(save-totality)


(add-program-constant "ContexApplicationbounded" (py "contex=>rat=>rat=>rea=>rea"))
(add-computation-rule "ContexApplicationbounded fex c d x" "RealConstr ([n]fex approxex(x seq n)n) ([p] fex modex c d (PosS(PosS(p))) max x mod (PosPred(fex modcex c d (PosS p))) ) "
)

(set-totality-goal "ContexApplicationbounded")
(use "AllTotalElim")
(assume "fex")
(use "AllTotalElim")
(assume "c")
(use "AllTotalElim")
(assume "d")
(use "AllTotalElim")
(assume "x")
(ng #t)
(use "ReaTotalVar")
(save-totality)

(set-goal "all fex(Contex(fex) -> all a,c,d(c<=d -> c<=a -> a<=d -> Cauchy(fex approxex a)(fex modex c d)))")
(cases)
(assume "h" "alcd" "omcd")
(elim)
(auto)
(save "ContexElim0")

(set-goal "all fex(Contex(fex) -> all a,b,c,d,p,n(c<=d -> c<=a -> a<=d -> c<=b -> b<=d ->
                  fex modex c d p<=n -> 
                  abs(a-b)<=1/2**(PosPred(fex modcex c d p)) ->
                  abs(fex approxex a n-fex approxex b n)<=1/2**p))")
(cases)
(assume "h" "alcd" "omcd")
(elim)
(auto)
(save "ContexElim1")

(set-goal "all fex(Contex(fex) -> all p,q,c,d(p<=q -> fex modex c d p<=fex modex c d q))")
(cases)
(assume "h" "alcd" "omcd")
(elim)
(auto)
(save "ContexElim2")

(set-goal "all fex(Contex(fex) -> all p,q,c,d(p<=q -> fex modcex c d p<=fex modcex c d q))")
(cases)
(assume "h" "alcd" "omcd")
(elim)
(auto)
(save "ContexElim3")



(set-goal "all h,alcd,omcd,c,d(c<=d->Contex(ContexConstr h alcd omcd) -> Cont(ContConstr c d h (alcd c d) (omcd c d)))")
(assume "h" "alcd" "omcd" "c" "d")
(assume "c<d")
(assume "Contexf")
(use "ContIntro")
(inst-with-to "ContexElim0" (pt "ContexConstr h alcd omcd") "ModInst")
(ng "ModInst")
(auto)
(inst-with-to "ContexElim1" (pt "ContexConstr h alcd omcd") "ModInst")
(ng "ModInst")
(auto)
(inst-with-to "ContexElim2" (pt "ContexConstr h alcd omcd") "ModInst")
(auto)
(inst-with-to "ContexElim3" (pt "ContexConstr h alcd omcd") "ModInst")
(auto)
(save "ContexToCont")



(set-goal "all fex,x,c,d(c<=d -> Contex fex -> Real x -> all n c<=x seq n -> all n x seq n<=d -> Real (ContexApplicationbounded fex c d x))")
(cases)
(assume "h" "alcd" "omcd")
(assume "x")
(assume "c" "d")
(assume "c<d" "Contexf" "Rx" "dom1" "dom2")
(simp "ContexApplicationbounded0CompRule")
(ng #t)
(inst-with-to "ContAppRealOne" (pt "ContConstr c d h (alcd c d) (omcd c d)") (pt "x") "AppInst")
(ng "AppInst")
(use "AppInst")
(use "ContexToCont")
(auto)
(save "ContexAppBoundedReal")

(add-program-constant "ContexApplication" (py "contex=>rea=>rea"))

(add-computation-rule "ContexApplication fex x" "ContexApplicationbounded fex ~(cRealBoundX(x)) (cRealBoundX(x)) x")

(set-totality-goal "ContexApplication")
(use "AllTotalElim")
(assume "fex")
(use "AllTotalElim")
(assume "x")
(simp "ContexApplication0CompRule")
(use "ContexApplicationboundedTotal")
(use "ContexTotalVar")
(use "RatTotalVar")
(use "RatTotalVar")
(use "ReaTotalVar")
(save-totality)

(add-application (pt "ContexApplication"))

(set-goal "all fex,x(Contex fex -> Real x -> Real(fex x)) ")
(assume "fex" "x" "Contexf" "Rx") 
(simp "ContexApplication0CompRule")
(use "ContexAppBoundedReal")
(auto)
(use "RatLePlusCancelL" (pt "(cRealBoundX x)"))
(simprat (pf "cRealBoundX x+ ~(cRealBoundX x)==0+0"))
(inst-with-to "RatLeMonPlus" (pt "(0#1)") (pt "(cRealBoundX x)") (pt "(0#1)")  (pt "(cRealBoundX x)") "MonPlusInst")
(cut "0<=cRealBoundX x")
(assume "cutInst")
(use "MonPlusInst")
(auto)
(use "RealLeToRatLe")
(use "RealLeTrans" (pt "abs(x)"))
(use "RealAbsNNeg")
(auto)
(use "RealLeSToLe")
(realproof)
(use "RealRat")
(use "RealLeSIntro")
(use "RealNNegSIntro")
(assume "n")
(simprat "<-" "RealsSeqPlusElim")
(use "RatLePlusCancelR" (pt "~((~abs x)seq n)"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "(~abs x)seq n+ ~((~abs x)seq n)==0"))
(simprat (pf "~((~abs x)seq n)==abs(x seq n)"))
(use "RealBoundXExFree")
(auto)
(assert "all x,n(~((~abs x)seq n)==abs(x seq n))")
(cases)
(assume "as" "M" "n0")
(ng #t)
(auto)
(assume "n")
(use "RatLeUMinusToLeSwitch")
(simprat (pf "~ ~(cRealBoundX x)==cRealBoundX x"))
(use "RatLeTrans" (pt "abs(x seq n)"))
(use "RatAbsInvLeqAbs")
(use "RealBoundXExFree")
(auto)
(assume "n")
(use "RatLeTrans" (pt "abs(x seq n)"))
(auto)
(use "RealBoundXExFree")
(auto)
(save "ContexApplicationReal")

(set-goal "all fex,x,y(Contex fex -> x===y -> (fex x)===(fex y)) ")
(assume "fex" "x" "y")
(assume "Cf" "x=y")
(use "RealEqChar2")
(use "ContexApplicationReal")
(auto)
(realproof)
(use "ContexApplicationReal")
(auto)
(realproof)
(assume "p")
(inst-with-to "RealBoundX" (pt "x") "cRx")
(inst-with-to "RealBoundX" (pt "y") "cRy")
(assert "exl a all n abs(x seq n)<=a")
(use "cRx")
(autoreal)
(assume "cRx1")
(by-assume "cRx1" "a1" "cRxProp")
(assert "exl a all n abs(y seq n)<=a")
(use "cRy")
(autoreal)
(assume "cRy1")
(by-assume "cRy1" "a2" "cRyProp")
(drop "cRx" "cRy")
(intro 0 (pt "fex modex(~a1 min~a2)(a1 max a2)p max cRealEqCharOne x mod y mod(PosPred(fex modcex(~a1 min~a2)(a1 max a2)p))"))
(assume "n" "p<=n")
(ng #t)
(use "ContexElim1" (pt "~a1 min ~a2") (pt "a1 max a2") )
(use "Cf")
(use "RatLeTrans" (pt "~a1"))
(use "RatMinLB1")
(use "RatLeTrans" (pt "abs(a1)"))
(use "RatAbsInvLeqAbs")
(simp "RatAbsId")
(use "RatMaxUB1")
(use "RatLeTrans" (pt "abs(x seq Zero)"))
(auto)
(use "RatLeTrans" (pt "~a1"))
(use "RatMinLB1")
(use "RatAbsLeCases")
(auto)  
(use "RatLeTrans" (pt "a1"))
(use "RatAbsLeCases")
(auto)
(use "RatMaxUB1")
(use "RatLeTrans" (pt "~a2"))
(use "RatMinLB2")
(use "RatAbsLeCases")
(auto)
(use "RatLeTrans" (pt "a2"))
(use "RatLeTrans" (pt "abs(y seq n)"))
(auto)
(use "RatMaxUB2")
(use "NatLeTrans" (pt "fex modex(~a1 min~a2)(a1 max a2)p max cRealEqCharOne x mod y mod (PosPred(fex modcex(~a1 min~a2)(a1 max a2)p))"))
(use "NatMaxUB1")
(auto)
(use "RealEqCharOneExFreeConstrFree")
(use "x=y")
(use "NatLeTrans" (pt "fex modex(~a1 min~a2)(a1 max a2)p max cRealEqCharOne x mod y mod (PosPred(fex modcex(~a1 min~a2)(a1 max a2)p))"))
(use "NatMaxUB2")
(auto)
(save "ContexApplicationCompat")



;; Completion Monad
;; We will take care of maps of type (Q=>R) together with modulus (P=>P) and build UCFs R=>R.

(add-var-name "hc" (py "rat=>rea"))


(add-alg
 "ucfall"
 (list "UCFallConstr" "(rat=>rea)=>(pos=>pos)=>ucfall"))


(add-totality "ucfall")

(add-program-constant "UCFallmap" (py "ucfall=>(rat=>rea)") t-deg-zero 'const 1)
(add-postfix-display-string "UCFallmap" "hcmap")
(add-computation-rules "UCFallmap(UCFallConstr hc om)" "hc")

(add-var-name "Fcf" (py "ucfall"))

(set-totality-goal "UCFallmap")
(assume "ucfall^")
(assume "Tcf")
(elim "Tcf")
(auto)
(save-totality)


(add-program-constant "UCFallmod" (py "ucfall=>(pos=>pos)") t-deg-zero 'const 1)
(add-postfix-display-string "UCFallmod" "hcmod")
(add-computation-rules "UCFallmod(UCFallConstr hc om)" "om")

(set-totality-goal "UCFallmod")
(assume "Fcf^")
(assume "Tcf")
(elim "Tcf")
(auto)
(save-totality)

(set-goal "all Fcf( TotalUcfall Fcf)")
(cases)
(assume "hc" "om")
(use "TotalUcfallUCFallConstr")
(use "AllTotalElim")
(assume "a")
(use "ReaTotalVar")
(use "AllTotalElim")
(assume "p")
(use "PosTotalVar")
(save "UcfallTotalVar")


(add-ids
 (list (list "UCFall" (make-arity (make-alg "ucfall"))))
 '("all hc,om(
    all a (Real(hc a)) ->
    all a,b,p( abs(a + ~b) <= (1#2**(om p)) -> abs( (hc a) + ~ (hc b)) <<= (1#2**p)) ->
     all p,q(p<=q -> om p<=om q) -> all p (p<=om p) ->
     UCFall(UCFallConstr hc om))" "UCFallIntro"))




(set-goal "all Fcf ( UCFall(Fcf) -> all a (Real(Fcf hcmap a)))")
(cases)
(assume "hc" "om")
(elim)
(auto)
(save "UCFallElim0")

(set-goal "all Fcf(UCFall(Fcf) -> all a,b,p( abs(a + ~b) <= (1#2**(Fcf hcmod p)) -> abs( (Fcf hcmap a) + ~ (Fcf hcmap b)) <<= (1#2**p)))")
(cases)
(assume "hc" "om")
(elim)
(auto)
(save "UCFallElim1")

(set-goal "all Fcf(UCFall(Fcf) -> all p,q(p<=q -> Fcf hcmod  p<=Fcf hcmod  q))")
(cases)
(assume "hc" "om")
(elim)
(auto)
(save "UCFallElim2")

(set-goal "all Fcf(UCFall(Fcf) -> all p(p<=Fcf hcmod p))")
(cases)
(assume "hc" "om")
(elim)
(auto)
(save "UCFallElim3")



(add-program-constant "UCFallApplication" (py "ucfall=>rea=>rea"))

(add-computation-rule "UCFallApplication Fcf x" 
"RealConstr( [n] (Fcf hcmap(x seq(x mod(Fcf hcmod(cNatPos n)+1) ))) seq ((Fcf hcmap(x seq(x mod(Fcf hcmod(cNatPos n)+1))))mod(cNatPos (Succ(Succ n))))) ([p] Succ((PosToNat(p))))")

(set-totality-goal "UCFallApplication")
(use "AllTotalElim")
(assume "Fcf")
(use "AllTotalElim")
(assume "x")
(use "ReaTotalVar")
(save-totality)


(add-application (pt "UCFallApplication"))



(set-goal "all Fcf,x (UCFall Fcf -> Real x -> Real(Fcf x))")
(cases)
(assume "hc" "om")
(cases)
(assume "as" "M")
(elim)
(assume "hc1" "om1" "cond1" "cond2" "cond3" "cond4")
(assume "Ras")
(ng #t)
(use "RealIntro")
(use "CauchyIntro")
(assume "p" "n" "m")
(assume "cond5" "cond6")
(ng)
(inst-with-to "RealApproxExFree" (pt "(hc1(as(M(PosS(om1(cNatPos n))))))") (pt "cNatPos(Succ(Succ n))") "RealApproxInst")
(inst-with-to "RealApproxExFree" (pt "(hc1(as(M(PosS(om1(cNatPos m))))))") (pt "cNatPos(Succ(Succ n))") "RealApproxInst2")
(inst-with-to "RatSubVar" (pt "(hc1(as(M(PosS(om1(cNatPos n))))))seq((hc1(as(M(PosS(om1(cNatPos n))))))mod(cNatPos(Succ(Succ n))))") "sub1")
(by-assume "sub1" "a0" "sub1Prop")
(simprat "sub1Prop")
(inst-with-to "RatSubVar" (pt "(hc1(as(M(PosS(om1(cNatPos m))))))seq((hc1(as(M(PosS(om1(cNatPos m))))))mod(cNatPos(Succ(Succ m))))") "sub2")
(by-assume "sub2" "b0" "sub2Prop")
(simprat "sub2Prop")
(use "RatLeTrans" (pt "(1#2**PosS(PosS p))+ (1#2**(PosS p)) +(1#2**PosS(PosS p))"))
(use "RatLeTrans" (pt "(1#2**cNatPos (Succ (Succ n))) +  (1#2**(PosS p)) + (1#2**(cNatPos (Succ (Succ m))))"))
(use "RealLeToRatLe")
(inst-with-to "RealSubVar" (pt "(hc1(as(M(PosS(om1(cNatPos n))))))") "sub3")
(cut "ex y hc1(as(M(PosS(om1(cNatPos n)))))===y")
(assume "sub3Prop")
(by-assume "sub3Prop" "x0" "sub3Propx")
(inst-with-to "RealSubVar" (pt "(hc1(as(M(PosS(om1(cNatPos m))))))") "sub4")
(cut "ex y hc1(as(M(PosS(om1(cNatPos m)))))===y")
(assume "sub4Prop")
(by-assume "sub4Prop" "y0" "sub4Propx")
(use "RealLeTrans" (pt "abs(a0+ ~x0) + abs(x0 + ~y0) + abs(y0 + ~b0)"))
(use "RealLeAbsRatInvTriangle2")
(autoreal)
(use "RealLeTrans" (pt "ReaRat(1#2**cNatPos(Succ(Succ n)))+ReaRat(1#2**PosS p)+ReaRat(1#2**cNatPos(Succ(Succ m)))"))
(use "RealLeMonPlus")
(use "RealLeMonPlus")
(simp "ReaRat0CompRule")
(simpreal "<-" "sub3Propx")
(cut "(hc1(as(M(PosS(om1(cNatPos n))))))seq((hc1(as(M(PosS(om1(cNatPos n))))))mod(cNatPos(Succ(Succ n))))===a0")
(assume "sub1PropCut")
(simpreal "<-" "sub1PropCut")
(use "RealApproxInst")
(use "cond1")
(use "RatEqvToRealEq")
(auto)
(simp "ReaRat0CompRule")
(simpreal "<-" "sub3Propx")
(simpreal "<-" "sub4Propx")
(use "cond2")
(use "CauchyElim" (pt "M"))
(use "RealConstrToCauchy")
(autoreal)
(ng #t)
(use "MonElim")
(use "RealConstrToMon" (pt "as"))
(autoreal)
(ng #t)
(use "PosLeTrans" (pt "om1(cNatPos n)"))
(use "cond3")
(simp (pf "(PosS p)=NatToPos(PosToNat((PosS p)))"))
(simp "NatPosExFree")
(simp "NatToPosLe")
(simp "PosSSucc")
(auto)
(use "NatLtLeTrans" (pt "Succ(PosToNat(p))"))
(auto)
(simp "NatToPosToNatId")
(auto)
(use "MonElim")
(use "RealConstrToMon" (pt "as"))
(autoreal)
(use "PosLeTrans" (pt "om1(cNatPos m)"))
(use "cond3")
(simp (pf "(PosS p)=NatToPos(PosToNat((PosS p)))"))
(simp "NatPosExFree")
(simp "NatToPosLe")
(simp "PosSSucc")
(auto)
(use "NatLtLeTrans" (pt "Succ(PosToNat(p))"))
(auto)
(simp "NatToPosToNatId")
(auto)
(simp "ReaRat0CompRule")
(simpreal "<-" "RealAbsUMinus")
(use "RealLeTrans" (pt "abs(b0 + ~y0)"))
(use "RealLeReflNC")
(use "RealAbsCompat")
(simpreal "RealUMinusPlus")
(simpreal "RealPlusComm")
(use "RealPlusCompat")
(use "RatEqvToRealEq")
(auto)
(use "RealEqRefl")
(autoreal)
(cut "(hc1(as(M(PosS(om1(cNatPos m))))))seq((hc1(as(M(PosS(om1(cNatPos m))))))mod(cNatPos(Succ(Succ m))))===b0")
(assume "sub2Propx")
(simpreal "<-" "sub2Propx")
(simpreal "<-" "sub4Propx")
(use "RealApproxExFree")
(autoreal)
(use "RatEqvToRealEq")
(auto)
(autoreal)
(simp "ReaRat0CompRule")
(simp "ReaRat0CompRule")
(simp "ReaRat0CompRule")
(use "RatLeToRealLe")
(ng #t)
(use "Truth")
(use "sub4")
(use "cond1")
(use "sub3")
(use "cond1")
(use "RatLeMonPlus")
(use "RatLeMonPlus")
(ng #t)
(use "PosExpLeMon")
(ng #t)
(simp (pf "(PosS p)=NatToPos(PosToNat((PosS p)))"))
(simp "NatPosExFree")
(use "PosLeLtTrans" (pt "NatToPos n"))
(simp "NatToPosLe")
(simp "PosSSucc")
(use "cond5")
(use "NatLtLeTrans" (pt "Succ(PosToNat(p))"))
(auto)
(simp "NatToPosLt")
(auto)
(use "NatLtLeTrans" (pt "Succ(PosToNat(p))"))
(auto)
(simp "NatToPosToNatId")
(auto)
(ng #t)
(use "PosExpLeMon")
(ng #t)
(simp (pf "(PosS p)=NatToPos(PosToNat((PosS p)))"))
(simp "NatPosExFree")
(use "PosLeLtTrans" (pt "NatToPos m"))
(simp "NatToPosLe")
(simp "PosSSucc")
(use "cond6")
(use "NatLtLeTrans" (pt "Succ(PosToNat(p))"))
(auto)
(simp "NatToPosLt")
(auto)
(use "NatLtLeTrans" (pt "Succ(PosToNat(p))"))
(auto)
(simp "NatToPosToNatId")
(auto)
(simp "<-" "RatPlusAssoc")
(simp "RatPlusComm")
(simp "<-" "RatPlusAssoc")
(simprat "RatPlusHalfExpPosS")
(simprat "RatPlusHalfExpPosS")
(auto)
(use "MonIntro")
(ng #t)
(assume "p" "q" "p<=q")
(simp "PosToNatLe")
(auto)
(save "UCFallApplicationReal")


(set-goal "all Fcf,x,y (UCFall Fcf -> x===y -> (Fcf x)===(Fcf y))")
(assume "Fcf" "x" "y")
(assume "Cf" "x=y")
(use "RealEqChar2")
(use "UCFallApplicationReal")
(auto)
(realproof)
(use "UCFallApplicationReal")
(auto)
(autoreal)
(ng #t)
(assume "p")
(intro 0 (pt "Succ(Succ(Succ(PosToNat p)))"))
(assume "n" "cond")
(inst-with-to "UCFallElim1" (pt "Fcf")  "RealInst")
(cut "all a,b,p(abs(a+ ~b)<=(1#2**Fcf hcmod p) ->abs(Fcf hcmap a+ ~(Fcf hcmap b))<<=(1#2**p))")
(assume "cutInst")
(ng #t)
(use "RatLeTrans" (pt "(1#2**(PosS(PosS p)))+(1#2**(PosS p))+(1#2**(PosS(PosS p)))"))
(inst-with-to "RatSubVar" (pt "(Fcf hcmap(x seq(x mod(PosS(Fcf hcmod(cNatPos n))))))seq((Fcf hcmap(x seq(x mod(PosS(Fcf hcmod(cNatPos n))))))mod (cNatPos(Succ(Succ n))))") "sub1")
(by-assume "sub1" "a1" "sub1Prop")
(simprat "sub1Prop")
(inst-with-to "RatSubVar" (pt "(Fcf hcmap(y seq(y mod(PosS(Fcf hcmod(cNatPos n))))))seq((Fcf hcmap(y seq(y mod(PosS(Fcf hcmod(cNatPos n))))))mod(cNatPos(Succ(Succ n))))") "sub2")
(by-assume "sub2" "a2" "sub2Prop")
(simprat "sub2Prop")
(inst-with-to "RatSubVar" (pt "(Fcf hcmap(x seq(x mod(PosS(Fcf hcmod(cNatPos n))))))seq((Fcf hcmap(x seq(x mod(PosS(Fcf hcmod(cNatPos n))))))mod (cNatPos(Succ(Succ n))) max(Fcf hcmap(y seq(y mod(PosS(Fcf hcmod(cNatPos n))))))mod(cNatPos(Succ(Succ n))))") "sub3")
(inst-with-to "RatSubVar" (pt "(Fcf hcmap(y seq(y mod(PosS(Fcf hcmod(cNatPos n))))))seq((Fcf hcmap(x seq(x mod(PosS(Fcf hcmod(cNatPos n))))))mod (cNatPos(Succ(Succ n))) max(Fcf hcmap(y seq(y mod(PosS(Fcf hcmod(cNatPos n))))))mod(cNatPos(Succ(Succ n))))") "sub4")
(by-assume "sub3" "a3" "sub3Prop")
(by-assume "sub4" "a4" "sub4Prop")
(use "RatLeTrans" (pt "abs(a1+ ~a3)+abs(a3+ ~a4)+abs(a4+ ~a2)"))
(use "RatInvTriangle2")
(use "RatLeMonPlus")
(use "RatLeMonPlus")
(simprat "<-" "sub1Prop")
(simprat "<-" "sub3Prop")
(use "CauchyElim" (pt "(Fcf hcmap(x seq(x mod(PosS(Fcf hcmod(cNatPos n))))))mod"))
(use "RealToCauchy")
(use "UCFallElim0")
(auto)
(use "MonElim")
(use "RealToMon" )
(use "UCFallElim0")
(auto)
(simp "NatPosExFree")
(simp "SuccPosS")
(simp "SuccPosS")
(simp "<-" "NatPosExFree")
(ng #t)
(simp "<-" "PosToNatLe")
(use "NatLeTrans" (pt "Succ(Succ(Succ(PosToNat p)))"))
(use "NatLeTrans" (pt "Succ(Succ(PosToNat p))"))
(use "NatLeTrans" (pt "Succ(PosToNat p)"))
(auto)
(simp "NatPosExFree")
(simp "PosToNatToPosId")
(auto)
(use "NatLtLeTrans" (pt "Succ(Succ(Succ(PosToNat p)))"))
(auto)
(use "NatLtLeTrans" (pt "Succ(Succ(Succ(PosToNat p)))"))
(auto)
(use "NatLeTrans" (pt "(Fcf hcmap(x seq(x mod(PosS(Fcf hcmod(cNatPos n))))))mod(cNatPos(Succ(Succ n)))"));;by monelim
(use "MonElim")
(use "RealToMon")
(use "UCFallElim0")
(auto)
(simp "NatPosExFree")
(simp "SuccPosS")
(simp "SuccPosS")
(simp "<-" "NatPosExFree")
(ng #t)
(simp "<-" "PosToNatLe")
(use "NatLeTrans" (pt "Succ(Succ(Succ(PosToNat p)))"))
(use "NatLeTrans" (pt "Succ(Succ(PosToNat p))"))
(use "NatLeTrans" (pt "Succ(PosToNat p)"))
(auto)
(simp "NatPosExFree")
(simp "PosToNatToPosId")
(auto)
(use "NatLtLeTrans" (pt "Succ(Succ(Succ(PosToNat p)))"))
(auto)
(use "NatLtLeTrans" (pt "Succ(Succ(Succ(PosToNat p)))"))
(auto)
(use "NatMaxUB1")
(simprat "<-" "RatPlusHalfExpPosS")
(use "RatLePlusCancelR" (pt "~(abs(a3 + ~a4))"))
(simprat (pf "abs(a3+ ~a4)+ ~abs(a3+ ~a4)==0"))
(use "RatLePlusCancelL" (pt "~(1#2**PosS(PosS p))"))
(simp "RatPlusAssoc")
(simp "RatPlusAssoc")
(simprat (pf "~(1#2**PosS(PosS p))+(1#2**PosS(PosS p))==0"))
(simprat (pf "~(1#2**PosS(PosS p))+0== ~(1#2**PosS(PosS p))"))
(simprat (pf "0+(1#2**PosS(PosS p))==(1#2**PosS(PosS p))"))
(simprat "<-" "sub3Prop")
(simprat "<-" "sub4Prop")
(use "RatLeTrans" (pt "((1#2**PosS(PosS p))+ ~abs(Fcf hcmap(x seq(x mod(PosS(Fcf hcmod(cNatPos n)))))+ ~(Fcf hcmap(y seq(y mod(PosS(Fcf hcmod(cNatPos n))))))))seq ((Fcf hcmap(x seq(x mod(PosS(Fcf hcmod(cNatPos n))))))mod(cNatPos(Succ(Succ n)))max(Fcf hcmap(y seq(y mod(PosS(Fcf hcmod(cNatPos n))))))mod (cNatPos(Succ(Succ n))))"))
(use "RealNNegCharOneExFreeConstrFree")
(use "RealLeToRealNNeg")
(cut "all a Real(Fcf hcmap a)")
(assume "cutInstR")
(use "RealLePlusCancelR" (pt " abs(Fcf hcmap(x seq(x mod(PosS(Fcf hcmod(cNatPos n)))))+ ~(Fcf hcmap(y seq(y mod(PosS(Fcf hcmod(cNatPos n)))))))")) 
(realproof)
(use "RealAbsReal")
(use "RealPlusReal")
(auto)
(use "RealUMinusReal")
(auto)
(use "RealPlusReal")
(realproof)
(use "RealUMinusReal")
(use "RealAbsReal")
(use "RealPlusReal")
(auto)
(use "RealUMinusReal")
(auto)
(use "RealLeTrans" (pt "ReaRat(1#2**PosS(PosS p))"))
(ng #t)
(simpreal (pf "0+abs(Fcf hcmap(x seq(x mod(PosS(Fcf hcmod(cNatPos n)))))+ ~(Fcf hcmap(y seq(y mod(PosS(Fcf hcmod(cNatPos n)))))))===abs(Fcf hcmap(x seq(x mod(PosS(Fcf hcmod(cNatPos n)))))+ ~(Fcf hcmap(y seq(y mod(PosS(Fcf hcmod(cNatPos n)))))))"))
(use "cutInst")
(use "RatLeTrans" (pt "1#2**Fcf hcmod ((cNatPos n))"))
(use "RealEqElim2")
(auto)
(ng #t)
(use "PosLeMonPosExp")
(simp "PosToNatLe")
(use "UCFallElim2")
(auto)
(simp "NatPosExFree")
(simp "<-" "PosToNatLe")
(simp "PosSSucc")
(simp "PosSSucc")
(simp "PosToNatToPosId")
(auto)
(use "NatLeTrans" (pt "Succ(Succ(Succ(PosToNat p)))"))
(auto)
(use "NatLtLeTrans" (pt "Succ(Succ(Succ(PosToNat p)))"))
(auto)
(cut "Real(abs(Fcf hcmap(x seq(x mod(PosS(Fcf hcmod(cNatPos n)))))+ ~(Fcf hcmap(y seq(y mod(PosS(Fcf hcmod(cNatPos n))))))))")
(assume "cutInstR2")
(simpreal "RealPlusComm")
(use "RealPlusZero")
(auto)
(realproof)
(use "RealAbsReal")
(use "RealPlusReal")
(auto)
(use "RealUMinusReal")
(auto)
(ng #t)
(simpreal "<-" "RealPlusAssoc")
(simpreal (pf "(~abs(Fcf hcmap(x seq(x mod(PosS(Fcf hcmod(cNatPos n)))))+ ~(Fcf hcmap(y seq(y mod(PosS(Fcf hcmod(cNatPos n)))))))+ abs(Fcf hcmap(x seq(x mod(PosS(Fcf hcmod(cNatPos n)))))+ ~(Fcf hcmap(y seq(y mod(PosS(Fcf hcmod(cNatPos n))))))))===0"))
(ng #t)
(use "RatLeToRealLe")
(auto)
(simpreal "RealPlusComm")
(use "RealPlusMinusZero")
(use "RealAbsReal")
(use "RealPlusReal")
(auto)
(use "RealUMinusReal")
(auto)
(use "RealAbsReal")
(use "RealPlusReal")
(auto)
(use "RealUMinusReal")
(auto)
(use "RealUMinusReal")
(use "RealAbsReal")
(use "RealPlusReal")
(auto)
(use "RealUMinusReal")
(auto)
(use "RealAbsReal")
(use "RealPlusReal")
(auto)
(use "RealUMinusReal")
(auto)
(use "RealUMinusReal")
(use "RealAbsReal")
(use "RealPlusReal")
(auto)
(use "RealUMinusReal")
(auto)
(autoreal)
(use "UCFallElim0")
(auto)
(ng #t)
(ng #t)
(assert "all a,x,p ((a+x)mod p =x mod (PosS p))")
(assume "c")
(cases)
(assume "as" "M" "p1")
(ng #t)
(use "Truth")
(assume "assertion")
(simp "assertion")
(ng #t)
(assert "all x,y,p( (~(abs(x+ ~(y)))) mod p = x mod (PosS p) max y mod (PosS p))")
(cases)
(assume "as" "M")
(cases)
(assume "bs" "N")
(assume "p1")
(ng #t)
(use "Truth")
(assume "assertion2")
(simp "assertion2")
(ng #t)
(use "NatMaxLUB")
(use "NatLeTrans" (pt "(Fcf hcmap(x seq(x mod(PosS(Fcf hcmod(cNatPos n))))))mod (cNatPos(Succ(Succ n)))")) 
(use "MonElim")
(use "RealToMon")
(use "UCFallElim0")
(auto)
(simp "NatPosExFree")
(simp "SuccPosS")
(simp "SuccPosS")
(simp "<-" "NatPosExFree")
(ng #t)
(simp "NatPosExFree")
(simp "<-" "PosToNatLt")
(use "NatLtLeTrans" (pt "Succ(Succ(Succ(PosToNat p)))"))
(simp "PosSSucc")
(simp "PosSSucc")
(ng #t)
(use "Truth")
(simp "PosToNatToPosId")
(auto)
(use "NatLtLeTrans" (pt "Succ(Succ(Succ(PosToNat p)))"))
(auto)
(use "NatLtLeTrans" (pt "Succ(Succ(Succ(PosToNat p)))"))
(auto)
(use "NatMaxUB1")
(use "NatLeTrans" (pt "(Fcf hcmap(y seq(y mod(PosS(Fcf hcmod(cNatPos n))))))mod (cNatPos(Succ(Succ n)))"))
(use "MonElim")
(use "RealToMon")
(use "UCFallElim0")
(auto)
(simp "NatPosExFree")
(simp "SuccPosS")
(simp "SuccPosS")
(simp "<-" "NatPosExFree")
(ng #t)
(simp "NatPosExFree")
(simp "<-" "PosToNatLt")
(use "NatLtLeTrans" (pt "Succ(Succ(Succ(PosToNat p)))"))
(simp "PosSSucc")
(simp "PosSSucc")
(ng #t)
(use "Truth")
(simp "PosToNatToPosId")
(auto)
(use "NatLtLeTrans" (pt "Succ(Succ(Succ(PosToNat p)))"))
(auto)
(use "NatLtLeTrans" (pt "Succ(Succ(Succ(PosToNat p)))"))
(auto)
(use "NatMaxUB2")
(ng #t)
(assert "all a,x,y,n ( (a + ~abs(x+y))seq n ==a + ~abs(x seq n + y seq n)) ")
(assume "c")
(cases)
(assume "as" "M")
(cases)
(assume "bs" "N")
(assume "n0")
(ng #t)
(use "Truth")
(assume "assertion3")
(simprat "assertion3")
(ng #t)
(use "RatEqvToLe")
(use "RatAbsCompat")
(ng #t)
(assert "all x,n ( (~x) seq n== ~ (x seq n))")
(cases)
(assume "as" "M")
(assume "n0")
(ng #t)
(use "Truth")
(assume "assertion4")
(simprat "<-" "assertion4")
(auto)
;; part 2 done
(simprat "<-" "sub4Prop")
(simprat "<-" "sub2Prop")
(use "CauchyElim" (pt "(Fcf hcmap(y seq(y mod(PosS(Fcf hcmod(cNatPos n))))))mod"))
(use "RealToCauchy")
(use "UCFallElim0")
(auto)
(use "NatLeTrans" (pt "(Fcf hcmap(y seq(y mod(PosS(Fcf hcmod(cNatPos n))))))mod(cNatPos(Succ(Succ n)))"))
(use "MonElim")
(use "RealToMon")
(use "UCFallElim0")
(auto)
(simp "NatPosExFree")
(simp "SuccPosS")
(simp "SuccPosS")
(simp "<-" "NatPosExFree")
(ng #t)
(simp "<-" "PosToNatLe")
(use "NatLeTrans" (pt "Succ(Succ(Succ(PosToNat p)))"))
(use "NatLeTrans" (pt "(Succ(Succ(PosToNat p)))"))
(use "NatLeTrans" (pt "Succ(PosToNat p)"))
(auto)
(simp "NatPosExFree")
(simp "PosToNatToPosId")
(auto)
(use "NatLtLeTrans" (pt "Succ(Succ(Succ(PosToNat p)))"))
(auto)
(use "NatLtLeTrans" (pt "Succ(Succ(Succ(PosToNat p)))")) 
(auto)
(use "NatMaxUB2")
(use "MonElim")
(use "RealToMon")
(use "UCFallElim0")
(auto)
(simp "NatPosExFree")
(simp "SuccPosS")
(simp "SuccPosS")
(simp "<-" "NatPosExFree")
(ng #t)
(simp "<-" "PosToNatLe")
(use "NatLeTrans" (pt "Succ(Succ(Succ(PosToNat p)))"))
(use "NatLeTrans" (pt "(Succ(Succ(PosToNat p)))"))
(use "NatLeTrans" (pt "Succ(PosToNat p)"))
(auto)
(simp "NatPosExFree")
(simp "PosToNatToPosId")
(auto)
(use "NatLtLeTrans" (pt "Succ(Succ(Succ(PosToNat p)))"))
(auto)
(use "NatLtLeTrans" (pt "Succ(Succ(Succ(PosToNat p)))")) 
(auto)
(simp "RatPlusComm")
(simp "RatPlusAssoc")
(simprat "RatPlusHalfExpPosS")
(simprat "RatPlusHalfExpPosS")
(use "Truth")
(use "UCFallElim1")
(auto)
(save "UCFallApplicationCompat")


;; General continuous map R=>R

(add-var-name "Cfmap" (py "rea=>rea"))


(add-ids
 (list (list "CfmapCont" (make-arity (py "rea=>rea"))))
 '("all Cfmap(
    all x ( Real x -> Real(Cfmap x)) ->
    all x,y(  x===y -> Cfmap x === Cfmap y) ->(CfmapCont Cfmap))" "CfmapContIntro"))


(set-goal "all Cfmap (CfmapCont Cfmap -> all x ( Real x -> Real(Cfmap x)))")
(assume "Cfmap")
(elim)
(auto)
(save "CfmapContElim0Real")


(set-goal "all Cfmap (CfmapCont Cfmap -> all x,y(  x===y -> Cfmap x === Cfmap y) )")
(assume "Cfmap")
(elim)
(auto)
(save "CfmapContElim1Compat")


(set-goal "all ucfall (UCFall(ucfall) -> CfmapCont(UCFallApplication ucfall))")
(assume "Fcf")
(assume "UCF")
(use "CfmapContIntro")
(assume "x" "Rx")
(use "UCFallApplicationReal")
(auto)
(assume "x" "y" "x===y")
(use "UCFallApplicationCompat")
(auto)
(save "UCFallCfmapCont")





(set-goal "all fex (Contex fex -> CfmapCont (ContexApplication fex))")
(assume "fex")
(assume "Cf")
(use "CfmapContIntro")
(assume "x" "Rx")
(use "ContexApplicationReal")
(auto)
(assume "x" "y")
(assume "x===y")
(use "ContexApplicationCompat")
(auto)
(save "ContexCfmapCont")

(add-program-constant "ContexId" (py "contex"))

(add-computation-rule "ContexId" "ContexConstr ([a,n] a) ([c,d,p] Zero) ([c,d,p] p+1)")

(set-totality-goal "ContexId")
(ng #t)
(use "ContexTotalVar")
(save-totality)

(set-goal "Contex(ContexId)")
(use "ContexIntro")
(assume "a" "c" "d" "cond1" "cond2" "cond3")
(ng #t)
(use "CauchyIntro")
(assume "p" "n" "m")
(assume "cond4" "cond5")
(ng #t)
(use "Truth")
(assume "a" "b" "c" "d" "p" "n")
(assume "cond1" "cond2" "cond3" "cond4" "cond5")
(assume "cond6" "cond7")
(ng #t)
(use "cond7")
(ng #t)
(auto)
(save "ContexContexId")

(set-goal "all x(Real x -> x===ContexId x)")
(assume "x" "Rx")
(use "RealEqSToEq")
(auto)
(use "ContexApplicationReal")
(use "ContexContexId")
(auto)
(use "RealEqSIntro")
(ng #t)
(auto)
(save "ContexIdSub")


