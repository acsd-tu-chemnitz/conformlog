;; Begin Continuous Functions
(display "loading cont.scm")(newline)


(add-alg
 "cont"
 (list "ContConstr" "rat=>rat=>(rat=>nat=>rat)=>(pos=>nat)=>(pos=>pos)=>cont"))
(add-totality "cont")

(add-var-name "h" (py "rat=>nat=>rat"))
(add-var-name "al" (py "pos=>nat"))

(add-var-name "om" (py "pos=>pos"))

(add-program-constant "ContDoml" (py "cont=>rat") t-deg-zero)
(add-postfix-display-string "ContDoml" "doml")

(add-computation-rules
 "(ContConstr a0 b0 h al om)doml" "a0")

(add-var-name "f" (make-alg "cont"))
(add-var-name "g" (make-alg "cont")) 

(set-goal (rename-variables (term-to-totality-formula (pt "ContDoml"))))
    (assume "f^" "Tf")
    (elim "Tf")
    (assume "a^" "Ta" "b^" "Tb" "h^" "Th" "M^" "TM" "om^" "Tom")
    (ng #t)
    (use "Ta")
;; Proof finished.
(save "ContDomlTotal")

(add-program-constant "ContDomr" (py "cont=>rat") t-deg-zero)
(add-postfix-display-string "ContDomr" "domr")
 
(add-computation-rules
 "(ContConstr a0 b0 h al om)domr" "b0")

;; ContDomrTotal
(set-goal (rename-variables (term-to-totality-formula (pt "ContDomr"))))
    (assume "f^" "Tf")
    (elim "Tf")
    (assume "a^" "Ta" "b^" "Tb" "h^" "Th" "M^" "TM" "om^" "Tom")
    (ng #t)
    (use "Tb")
;; Proof finished.
(save "ContDomrTotal")

(add-program-constant "ContApprox" (py "cont=>rat=>nat=>rat") t-deg-zero 'const 1)
(add-postfix-display-string "ContApprox" "approx")

(add-computation-rules
 "(ContConstr a0 b0 h al om)approx" "h")
;; ContApproxTotal
(set-goal (rename-variables (term-to-totality-formula (pt "ContApprox"))))
    (assume "f^" "Tf")
    (elim "Tf")
    (assume "a^" "Ta" "b^" "Tb" "h^" "Th" "M^" "TM" "om^" "Tom")
    (ng #t)
    (use "Th")
;; Proof finished.
(save "ContApproxTotal")

(add-program-constant "ContuMod" (py "cont=>pos=>nat") t-deg-zero 'const 1)
(add-postfix-display-string "ContuMod" "uMod")

(add-computation-rules
 "(ContConstr a0 b0 h al om)uMod" "al")

;; ContuModTotal
(set-goal (rename-variables (term-to-totality-formula (pt "ContuMod"))))
 (assume "f^" "Tf")
 (elim "Tf")
 (assume "a^" "Ta" "b^" "Tb" "h^" "Th" "M^" "TM" "om^" "Tom")
 (ng #t)
 (use "TM")
;; Proof finished.
(save "ContuModTotal")

(add-program-constant "ContuModCont" (py "cont=>pos=>pos") t-deg-zero 'const 1)
(add-postfix-display-string "ContuModCont" "uModCont")

(add-computation-rules
 "(ContConstr a0 b0 h al om)uModCont" "om")

;; ContuModContTotal
(set-goal (rename-variables (term-to-totality-formula (pt "ContuModCont"))))
 (assume "f^" "Tf")
 (elim "Tf")
 (assume "a^" "Ta" "b^" "Tb" "h^" "Th" "M^" "TM" "om^" "Tom")
 (ng #t)
 (use "Tom")
;; Proof finished.
(save "ContuModContTotal")



(set-goal "all f TotalCont f")
 (cases)
 (assume "a" "b" "h" "M" "om")
 (use "TotalContContConstr")
 (use "RatTotalVar")
 (use "RatTotalVar")
 (use "AllTotalElim")
 (assume "a0")
 (use "AllTotalElim")
 (assume "n")
 (use "RatTotalVar")
 (use "AllTotalElim")
 (assume "p")
 (use "NatTotalVar")
 (use "AllTotalElim")
 (assume "p")
 (use "PosTotalVar")

(save "ContTotalVar")

(add-var-name "eta" (py "pos=>pos"))

(set-goal "all M,p(exl l M p<=l)")
(assume "M" "p")
(intro 0 (pt "M p"))
(ng #t)
(auto)
(save "MonAuxThm")


;; Now the (formally inductive) definition of Cont

(add-ids
 (list (list "Cont" (make-arity (make-alg "cont"))))
 '("allnc a0,b0,h,al,om(
     all a(a0<=a -> a<=b0 -> Cauchy(h a)al) --> 
     all a,b,p,n(a0<=a -> a<=b0 -> a0<=b -> b<=b0 ->
                  al p<=n -> 
                  abs(a-b)<=1/2**(PosPred(om p)) ->
                  abs(h a n-h b n)<=1/2**p) -->
     all p,q(p<=q -> al p<=al q) -->
     all p,q(p<=q -> om p<=om q) -->
     Cont(ContConstr a0 b0 h al om))" "ContIntro"))





;; Now the properties of Cont.

;; ContElim1
(set-goal "all f(Cont f -> all a(f doml<=a -> a<=f domr -> Cauchy(f approx a)(f uMod)))")
 (ind)
 (assume "a0" "b0" "h" "al" "om")
 (elim)
 (search)
;; Proof finished.
(save "ContElim1")

;; ContElim2
(set-goal "all f(
 Cont f -> 
 all a,b,p,n(
  f doml<=a -> 
  a<=f domr -> 
  f doml<=b -> 
  b<=f domr -> 
  f uMod p<=n -> 
  abs(a-b)<=1/2**(PosPred(f uModCont p)) -> abs(f approx a n-f approx b n)<=1/2**p))")
    (ind)
    (assume "a0" "b0" "h" "al" "om")
    (elim)
    (search)
;; Proof finished.
(save "ContElim2")

;; ContElim3
(set-goal "all f(Cont f -> all p,q(p<=q -> f uMod p<=f uMod q))")
(ind)
(assume "a0" "b0" "h" "al" "om")
(elim)
(search)
;; Proof finished.
(save "ContElim3")

;; ContElim4
(set-goal "all f(Cont f -> all p,q(p<=q -> f uModCont p<=f uModCont q))")
(ind)
(assume "a0" "b0" "h" "al" "om")
(elim)
(search)
;; Proof finished.
(save "ContElim4")

(add-program-constant "AppContOne" (py "cont=>rea=>rea") t-deg-zero)

(add-computation-rule
 "AppContOne f x"
 "RealConstr([n]f approx(x seq n)n)
            ([p]f uMod(PosS(PosS p))max x mod(PosPred(f uModCont(PosS p))))")


 


(set-goal (rename-variables (term-to-totality-formula (pt "AppContOne"))))
(assume "f^" "Tf")
(elim "Tf")
(assume "a^" "Ta" "b^" "Tb" "h^" "Th" "al^" "Tal" "om^" "Tom" "x^" "Tx")
(elim "Tx")
(assume "as^" "Tas" "M^" "TM")
(ng #t)
(use "TotalReaRealConstr")
(ng #t)
(assume "n^" "Tn")
(use "Th")
(use "Tas")
(use "Tn")
(use "Tn")
(assume "p^" "Tp")
(ng #t)
(use "NatMaxTotal")
(use "Tal")
(use "PosSTotal")
(use "PosSTotal")
(use "Tp")
(use "TM")
(use "PosPredTotal")
(use "Tom")
(use "PosSTotal")
(use "Tp")
;; Proof finished.
(save "AppContOneTotal")

(add-application (pt "AppContOne"))



 (add-computation-rule
    "AppContOne f x"
    "RealConstr([n]f approx(x seq n)n)
               ([p]f uMod(PosS(PosS p))max x mod(PosPred(f uModCont(PosS p))))")


(set-goal "all f,x(Cont f -> Real x -> all n f doml<=x seq n -> all n x seq n<=f domr -> Real(f x))")
(assume "f" "x")
(elim)
(assume "a" "b" "h" "al" "om")
(assume "conv" "conti" "monu" "monom")
(elim)
(cases)
(assume "as" "M")
(assume "CauchyX")
(assume "MonX")
(assume "lft<=x")
(assume "x<=rht")
(use "RealIntro")
(use "CauchyIntro")
(assume "p" "n" "m")
(ng #t)
(assume "mod1" "mod2")
(inst-with-to "MonAuxThm" (pt "al") (pt "PosS(PosS p)") "LInst" )
(by-assume "LInst" "l" "LInstProp")
(use "RatLeTrans" (pt "abs(h(as n)n+ ~(h(as n)l)) + abs(h(as n)l+ ~(h(as m)l))+ abs(h(as m)l+ ~(h(as m)m))"))
(use "RatInvTriangle2")
(use "RatLeTrans" (pt "(1#2**(PosS(PosS(p))))+abs(h(as n)l+ ~(h(as m)l))+abs(h(as m)l+ ~(h(as m)m))"))
(ng #t)
(use "CauchyElim" (pt "al") )
(auto)
(use "NatLeTrans" (pt  "al(PosS(PosS p))max M(PosPred(om(PosS p)))"))
(use "NatMaxUB1")
(auto)
(use "RatLeTrans" (pt "(1#2**PosS(PosS p))+ (1#2**(PosS p)) +(1#2**PosS(PosS p))"))
(use "RatLePlusCancelL" (pt "~(1#2**PosS(PosS p))"))
(simp "RatPlusAssoc")
(simp "RatPlusAssoc")
(simp "RatPlusAssoc")
(simp "RatPlusAssoc")
(simprat (pf "~(1#2**PosS(PosS p))+(1#2**PosS(PosS p))==0"))
(simprat (pf "0+abs(h(as n)l+ ~(h(as m)l))+abs(h(as m)l+ ~(h(as m)m))==abs(h(as n)l+ ~(h(as m)l))+abs(h(as m)l+ ~(h(as m)m))"))
(simprat (pf "0+(1#2**(PosS p))+(1#2**PosS(PosS p))==(1#2**(PosS p))+(1#2**PosS(PosS p))"))
(use "RatLeMonPlus")
(use "conti")
(auto)
(use "NatLeTrans" (pt "al(PosS(PosS p))"))
(use "monu")
(auto)
(use "CauchyElim" (pt "M") )
(ng "CauchyX")
(use "CauchyX")
(use "NatLeTrans" (pt "al(PosS(PosS p))max M(PosPred(om(PosS p)))"))
(use "NatMaxUB2")
(auto)
(use "NatLeTrans" (pt "al(PosS(PosS p))max M(PosPred(om(PosS p)))"))
(use "NatMaxUB2")
(auto)
(use "CauchyElim" (pt "al"))
(use "conv")
(auto)
(use "NatLeTrans" (pt  "al(PosS(PosS p))max M(PosPred(om(PosS p)))"))
(use "NatMaxUB1")
(auto)
(simp "RatPlusComm")
(simp "RatPlusAssoc")
(simprat (pf "(1#2**PosS(PosS p))+(1#2**PosS(PosS p))==(1#2**PosS p)"))
(simprat "RatPlusHalfExpPosS")
(auto)
(simprat "RatPlusHalfExpPosS")
(auto)
(use "MonIntro")
(ng #t)
(assume "p" "q")
(assume "p<=q")
(use "NatMaxLUB")
(use "NatLeTrans" (pt "al(PosS(PosS q))"))
(use "monu")
(auto)
(use "NatMaxUB1")
(use "NatLeTrans" (pt "M(PosPred(om(PosS q)))"))
(use "MonElim" (pt "as"))
(use "MonX")
(use "PosLeMonPred")
(use "monom")
(auto)
(use "NatMaxUB2")
(save "ContAppRealOne")


(set-goal "all f,as,M( f (RealConstr as M) eqd RealConstr([n]f approx(as n)n)
([p]f uMod(PosS(PosS p))max M(PosPred(f uModCont(PosS p)))))")
(ng #t)
(assume "f" "as" "M")
(use "InitEqD")
(save "AppContOneConstrFree")




(set-goal "all f,c(Cont f -> f doml<=c -> c<=f domr -> Real(f c))")
(assume "f" "c")
(elim)
(assume "a" "b" "h" "al" "om")
(assume "conv")
(assume "conti")
(assume "monc")
(assume "monu")
(assume "lft<=c")
(assume "c<=rht")
(use "RealIntro")
(ng #t)
(use "CauchyDiffModAuxCauchy" (pt "al"))
(use "conv")
(auto)
(assume "p")
(ng #t)
(use "monc")
(use "PosLeTrans" (pt "PosS p"))
(auto)
(use "MonIntro")
(ng #t)
(assume "p" "q")
(assume "p<=q")
(use "monc")
(ng #t)
(auto)
(save "ContRealRat")







; (set-goal "all a,b Cont (ContConstr (a) (b) ([a0,n] c) ([p] Zero) ([p] p))")
; (strip)
; (use "ContIntro")
; (assume "a0")
; (assume "Pa" "Pb")
; (use "CauchyIntro")
; (strip)
; (ng #t)
; (use "RatLeTrans" (pt "0#1"))
; (ng #t)
; (use "RatLeAbs")
; (use "RatLeRefl")
; (ng #t)
; (use "Truth")
; (ng #t)
; (use "RatLeRefl")
; (use "Truth")
; (ng #t)
; (use "Truth")
; (assume "a0" "b0" "p" "n")
; (strip)
; (ng #t)
; (use "RatLeTrans" (pt "0#1"))
; (use "RatLeAbs")
; (use "RatLeRefl")
; (use "Truth")
; (use "RatLeRefl")
; (use "Truth")
; (use "Truth")
; (ng #t)
; (auto)
; (save "ContConst")

(add-program-constant "ContConstSimp" (py "rat=>rat=>rat=>cont"))
(add-computation-rule "ContConstSimp a b c" "ContConstr a b ([a0,n] c) ([p] Zero) ([p] p)")

(set-goal "all a,b,c Cont (ContConstSimp a b c)")
(ng #t)
(strip)
(use "ContIntro")
(assume "a0")
(assume "Pa" "Pb")
(use "CauchyIntro")
(auto)
(save "ContConst")







(add-program-constant "ContIdSimp" (py "rat=>rat=>cont"))
(add-computation-rule "ContIdSimp a b" "ContConstr (a) (b) ([a0,n] a0) ([k] Zero) ([p] p+1)")



(set-goal "all a,b Cont (ContIdSimp a b)")
(strip)
(use "ContIntro")
(assume "a1")
(assume "Ta" "Tb")
(use "CauchyIntro")
(strip)
(ng)
(use "Truth")
(assume "a0" "b0" "p" "n")
(strip)
(ng #t)
(use 6)
(auto)
(save "ContId")


(set-totality-goal "ContIdSimp")
(use "AllTotalElim")
(assume "a")
(use "AllTotalElim")
(assume "b")
(use "ContTotalVar")
(save-totality)

(add-program-constant "ContPlus" (py "cont=>cont=>cont"))


(add-computation-rule "ContPlus f g" "ContConstr (f doml max g doml) (f domr min g domr)
    ([a,n] (f approx a n) + (g approx a n))
    ([p] (f uMod ((PosS(p)))) max (g uMod ((PosS(p)))))
    ([p] (f uModCont (PosS p)) max (g uModCont (PosS p)) )
    ")

(set-totality-goal "ContPlus")
(use "AllTotalElim")
(assume "f")
(use "AllTotalElim")
(assume "g")
(use "TotalContContConstr")
(use "RatTotalVar")
(use "RatTotalVar")
(use "AllTotalElim")
(assume "a")
(use "AllTotalElim")
(assume "n")
(use "RatTotalVar")
(use "AllTotalElim")
(assume "p")
(use "NatTotalVar")
(use "AllTotalElim")
(assume "p")
(use "PosTotalVar")
(save-totality)

(set-goal "all f,a ( Cont f -> f doml <=a -> a<= f domr  -> Real(RealConstr([n]f approx a n)f uMod))")
(assume "f" "a")
(assume "Cf")
(assume "lb" "ub")
(use "RealIntro")
(use "ContElim1")
(auto)
(use "MonIntro")
(ng #t)
(use "ContElim3")
(auto)
(save "ContElim1ToReal")





(set-goal "all f,g ( Cont f -> Cont g -> Cont (ContPlus f g))")
(assume "f" "g")
(assume "Cf" "Cg")
(use "ContIntro")
(assume "a")
(strip)
(use "RealConstrToCauchy")
(inst-with-to "RealPlusReal" (pt "RealConstr([n]f approx a n) (f uMod)") (pt "RealConstr([n]g approx a n)( g uMod)") "RealInst")
(use "RealInst")
(use "ContElim1ToReal")
(auto)
(use "RatLeTrans" (pt "f doml max g doml"))
(use "RatMaxUB1")
(auto)
(use "RatLeTrans" (pt "f domr min g domr"))
(auto)
(use "RatMinLB1")
(use "ContElim1ToReal")
(auto)
(use "RatLeTrans" (pt "f doml max g doml"))
(use "RatMaxUB2")
(auto)
(use "RatLeTrans" (pt "f domr min g domr"))
(auto)
(use "RatMinLB2")
(assume "a" "b" "p" "n")
(assume "ldomc1" "ldomc2" "ldomc3" "ldomc4" "modcond")
(assume "cond1")
(ng #t)
(use "RatLeTrans" (pt "abs(f approx a n - f approx b n) + abs(g approx a n - g approx b n)"))
(use "RatLeTrans" (pt "abs(f approx a n + ~(f approx b n) + (g approx a n + ~(g approx b n)))"))
(use "RatLeRefl")
(use "RatAbsCompat")
(ng #t)
(simp "<-" "RatPlusAssoc")
(simp "<-" "RatPlusAssoc")
(use "RatPlusCompat")
(auto)
(ng #t)
(simp "RatPlusComm")
(auto)
(simp "RatMinus0CompRule")
(simp "RatMinus0CompRule")
(use "RatLeAbsPlus")
(use "RatLeTrans" (pt "(1#2)**(PosS p) + (1#2)**(PosS p)"))
(use "RatLeMonPlus")
(use "ContElim2")
(auto)
(use "RatLeTrans" (pt "f doml max g doml"))
(use "RatMaxUB1")
(auto)
(use "RatLeTrans" (pt "f domr min g domr"))
(auto)
(use "RatMinLB1")
(auto)
(use "RatLeTrans" (pt "f doml max g doml"))
(use "RatMaxUB1")
(auto)
(use "RatLeTrans" (pt "f domr min g domr"))
(auto)
(use "RatMinLB1")
(auto)
(ng "modcond")
(use "NatLeTrans" (pt "f uMod(PosS p)max g uMod(PosS p)"))
(use "NatMaxUB1")
(auto)
(use "RatLeTrans" (pt "1/2**PosPred(([p0]f uModCont(PosS p0)max g uModCont(PosS p0))p)"))
(auto)
(ng #t)
(use "PosLeMonPosExp")
(simp "PosToNatLe")
(use "PosLeMonPred")
(use "PosMaxUB1")
(use "ContElim2")
(auto)
(use "RatLeTrans" (pt "f doml max g doml"))
(use "RatMaxUB2")
(auto)
(use "RatLeTrans" (pt "f domr min g domr"))
(auto)
(use "RatMinLB2")
(auto)
(use "RatLeTrans" (pt "f doml max g doml"))
(use "RatMaxUB2")
(auto)
(use "RatLeTrans" (pt "f domr min g domr"))
(auto)
(use "RatMinLB2")
(auto)
(use "NatLeTrans" (pt "f uMod(PosS p)max g uMod(PosS p)"))
(use "NatMaxUB2")
(auto)
(use "RatLeTrans" (pt "1/2**PosPred(([p0]f uModCont(PosS p0)max g uModCont(PosS p0))p)"))
(auto)
(ng #t)
(use "PosLeMonPosExp")
(simp "PosToNatLe")
(use "PosLeMonPred")
(use "PosMaxUB2")
(use "RatLeRefl")
(use "RatPlusHalfExpPosS")
(assume "p" "q")
(assume "p<=q")
(ng #t)
(use "NatMaxLUB")
(use "NatLeTrans" (pt "f uMod(PosS q)"))
(use "ContElim3")
(auto)
(use "NatMaxUB1")
(use "NatLeTrans" (pt "g uMod(PosS q)"))
(use "ContElim3")
(auto)
(use "NatMaxUB2")
(assume "p" "q")
(assume "p<=q")
(ng #t)
(use "PosMaxLUB")
(use "PosLeTrans" (pt "f uModCont(PosS q)"))
(use "ContElim4")
(auto)
(use "PosMaxUB1")
(use "PosLeTrans" (pt "g uModCont(PosS q)"))
(use "ContElim4")
(auto)
(use "PosMaxUB2")
(save "ContPlusCont")


(add-program-constant "ContUMinus" (py "cont=>cont"))


(add-computation-rule "ContUMinus f" "ContConstr (f doml) (f domr)
    ([a,n] ~(f approx a n) )
    (f uMod)
    (f uModCont)
    ")

(set-totality-goal "ContUMinus")
(use "AllTotalElim")
(assume "f")
(use "ContTotalVar")
(save-totality)

(set-goal "all f (Cont f -> Cont(ContUMinus f))")
(assume "f")
(assume "Cf")
(use "ContIntro")
(assume "a" "cond1" "cond2")
(use "RealConstrToCauchy")
(use "RealEqSToRealElim" (pt "~(RealConstr(([a0,n](f approx a0 n))a)f uMod)"))
(use "RealEqSIntro")
(auto)
(use "RealUMinusReal")
(use "ContElim1ToReal")
(auto)
(assume "a" "b" "p" "n" "cond1" "cond2" "cond3" "cond4" "cond5")
(assume "modcond")
(ng #t)
(simp "RatPlusComm")
(use "ContElim2")
(auto)
(simp "RatMinus0CompRule")
(simprat "RatAbsPlusMinusComm")
(auto)
(use "ContElim3")
(auto)
(use "ContElim4")
(auto)
(save "ContUMinusCont")



;; (rpc "ContTimes")
;;
(add-program-constant "ContTimes" (py "cont=>cont=>pos=>pos=>cont"))

(add-computation-rules "ContTimes f g q0 q1" "ContConstr (f doml max g doml) (f domr min g domr)
([a,n] (f approx a n)*(g approx a n)) ([p] f uMod(PosS(p + q1)) max  g uMod(PosS(p + q0)))
([p] f uModCont ((PosS p) + q1) max g uModCont ((PosS p) + q0))
")

(set-totality-goal "ContTimes")
(use "AllTotalElim")
(assume "f")
(use "AllTotalElim")
(assume "g")
(use "AllTotalElim")
(assume "q0")
(use "AllTotalElim")
(assume "q1")
(use "ContTotalVar")
(save-totality)

(set-goal "all p,q(p eqd q -> p = q)")
(assume "p" "q")
(assume "cond")
(simp "cond")
(auto)
(save "EqDToPosEq")


(set-goal "all a,b,c (a max c<= b -> a<=b )")
(assume "a" "b" "c")
(assume "cond")
(use "RatLeTrans" (pt "a max c"))
(use "RatMaxUB1")
(auto)
(save "RatLeTransMax")

(set-goal "all a,b,c ( a<= b min c -> a<=b )")
(assume "a" "b" "c")
(assume "cond")
(use "RatLeTrans" (pt "b min c"))
(auto)
(use "RatMinLB1")
(save "RatLeTransMin")

(set-goal "all f,g,q0,q1(Cont f -> Cont g -> all a( (f doml max g doml)<= a -> a<=(f domr min g domr) ->  cNatPos(RealBd (f approx a) f uMod)<= q0 &  cNatPos(RealBd (g approx a) g uMod) <= q1 )-> Cont(ContTimes f g q0 q1) )")
(assume "f" "g" "q0" "q1")
(assume "Cf" "Cg" "normBd")
(use "ContIntro")
(assume "a" "cond1" "cond2")
(use "CauchyDiffModAuxCauchy" (pt "[p]f uMod(PosS(p+cNatPos(RealBd(g approx a)g uMod)))max g uMod(PosS(p+ cNatPos(RealBd(f approx a)f uMod)))"))
(use "RealConstrToCauchy")
(use "RealEqSToRealElim" (pt "(RealConstr([n] f approx a n )(f uMod)) * (RealConstr([n] g approx a n)(g uMod))"))
(use "RealEqSIntro")
(auto)
(use "RealTimesReal")
(use "ContElim1ToReal")
(auto)
(use "RatLeTransMax" (pt "g doml"))
(auto)
(use "RatLeTransMin" (pt "g domr"))
(auto)
(use "ContElim1ToReal")
(auto)
(use "RatLeTransMax" (pt "f doml"))
(simprat "RatMaxComm")
(auto)
(use "RatLeTransMin" (pt "f domr"))
(simprat "RatMinComm")
(auto)
(assume "p")
(use "NatLeTrans" (pt "f uMod(PosS(p+cNatPos(RealBd(g approx a)g uMod)))max
       g uMod(PosS(p+cNatPos(RealBd(f approx a)f uMod)))"))
(auto)
(use "NatLeTrans" (pt "(f uMod(PosS(p+q1))max g uMod(PosS(p+q0)))"))
(use "NatMaxLUB")
(use "NatLeTrans" (pt "f uMod(PosS(p+q1))"))
(use "ContElim3")
(auto)
(use "NatMaxUB1")
(use "NatLeTrans" (pt "g uMod(PosS(p+q0))"))
(use "ContElim3")
(auto)
(use "NatMaxUB2")
(auto)
(assume "a" "b" "p" "n" "cond1" "cond2" "cond3" "cond4" "cond5")
(assume "modcond")
(use "RatLeTrans" (pt "abs(f approx a n*(g approx a n+ ~(g approx b n))) + abs( (g approx b n)* (f approx a n + ~(f approx b n)))"))
(ng #t)
(use "RatLeTrans" (pt "abs(f approx a n*(g approx a n+ ~(g approx b n)) + (g approx b n*(f approx a n+ ~(f approx b n))))"))
(use "RatLeRefl")
(use "RatAbsCompat")
(simprat "RatTimesPlusDistr")
(simprat "RatTimesPlusDistr")
(simp "<-" "RatPlusAssoc")
(use "RatPlusCompat")
(auto)
(ng #t)
(simprat (pf "~(f approx b n*g approx b n)== 0+ ~(f approx b n*g approx b n)"))
(use "RatPlusCompat")
(simp "RatTimesComm")
(simp "RatPlusComm")
(use "RatEqvSym")
(auto)
(simp "RatTimesComm")
(auto)
(ng "modcond")
(simprat (pf "1/2**p == 1/2**(PosS p)+1/2**(PosS p)"))
(use "RatLeMonPlus")
(use "RatLeTrans" (pt "abs(2**q0*(1/2**(PosS p + q0)))"))
(simp "RatAbsTimes")
(simp "RatAbsTimes")
(use "RatLeMonTimesTwo")
(auto)
(ng #t)
(use "RatLeTrans" (pt "2**(cNatPos(RealBd(f approx a)f uMod))#1"))
(use "RealBdPropCNat")
(use "ContElim1ToReal")
(auto)
(use "RatLeTransMax" (pt "g doml"))
(auto)
(use "RatLeTransMin" (pt "g domr"))
(auto)
(use "PosLeMonPosExp")
(simp "PosToNatLe")
(use "normBd")
(auto)
(use "ContElim2")
(auto)
(use "RatLeTransMax" (pt "f doml"))
(simprat "RatMaxComm")
(auto)
(use "RatLeTransMin" (pt "f domr"))
(simprat "RatMinComm")
(auto)
(use "RatLeTransMax" (pt "f doml"))
(simprat "RatMaxComm")
(auto)
(use "RatLeTransMin" (pt "f domr"))
(simprat "RatMinComm")
(auto)
(use "NatLeTrans" (pt "([p0]f uMod(PosS(p0+q1))max g uMod(PosS(p0+q0)))p"))
(ng #t)
(use "NatMaxUB2")
(auto)
(use "RatLeTrans" (pt "(1#2**PosPred(f uModCont(PosS(p+q1))max g uModCont(PosS(p+q0))))"))
(auto)
(ng #t)
(use "PosLeMonPosExp")
(simp "PosToNatLe")
(use "PosLeMonPred")
(use "PosMaxUB2")
(ng #t)
(simp "PosExpTwoPosPlus")
(use "PosLeMonPosExp")
(simp "PosToNatLe")
(ng #t)
(simp "PosPlusComm")
(auto)
(use "RatLeTrans" (pt "2**q1*((1#2)**PosS(p+q1))"))
(simp "RatAbsTimes")
(use "RatLeMonTimesTwo")
(auto)
(use "RatLeTrans" (pt "2**cNatPos(RealBd(g approx b)g uMod)#1"))
(use "RealBdPropCNat")
(use "ContElim1ToReal")
(auto)
(use "RatLeTransMax" (pt "f doml"))
(simprat "RatMaxComm")
(auto)
(use "RatLeTransMin" (pt "f domr"))
(simprat "RatMinComm")
(auto)
(ng #t)
(use "PosExpLeMon")
(use "normBd")
(auto)
(use "ContElim2")
(auto)
(use "RatLeTransMax" (pt "g doml"))
(auto)
(use "RatLeTransMin" (pt "g domr"))
(auto)
(use "RatLeTransMax" (pt "g doml"))
(auto)
(use "RatLeTransMin" (pt "g domr"))
(auto)
(use "NatLeTrans" (pt "([p0]f uMod(PosS(p0+q1))max g uMod(PosS(p0+q0)))p"))
(ng #t)
(use "NatMaxUB1")
(auto)
(use "RatLeTrans" (pt "(1#2**PosPred(f uModCont(PosS(p+q1))max g uModCont(PosS(p+q0))))"))
(auto)
(ng #t)
(use "PosExpLeMon")
(use "PosLeMonPred")
(use "PosMaxUB1")
(ng #t)
(simp "PosExpTwoPosPlus")
(use "PosExpLeMon")
(ng #t)
(simp "PosPlusComm")
(auto)
(use "RatEqvSym")
(use "RatPlusHalfExpPosS")
(assume "p" "q" "p<=q")
(ng #t)
(use "NatMaxLUB")
(use "NatLeTrans" (pt "f uMod(PosS(q+q1))"))
(use "ContElim3")
(auto)
(use "NatMaxUB1")
(use "NatLeTrans" (pt "g uMod(PosS(q+q0))"))
(use "ContElim3")
(auto)
(use "NatMaxUB2")
(assume "p" "q" "p<=q")
(ng #t)
(use "PosMaxLUB")
(use "PosLeTrans" (pt "f uModCont(PosS(q+q1))"))
(use "ContElim4")
(auto)
(use "PosMaxUB1")
(use "PosLeTrans" (pt "g uModCont(PosS(q+q0))"))
(use "ContElim4")
(auto)
(use "PosMaxUB2")
(save "ContTimesCont")


;; Composition (o f g)
(rpc "o")
(add-program-constant "o" (py "cont=>cont=>cont"))

(add-computation-rule "o g f" "ContConstr (f doml) (f domr) 
    ([a,n] g approx(f approx a n) n) 
    ([p] (g uMod (PosS(PosS(p)))) max (f uMod (PosPred(g uModCont (PosS(p))))))
    ([p] PosS(f uModCont(PosPred(g uModCont p))))
    ")


(set-goal "all M,N(Mon M -> Mon N -> Mon ([p] M p max N p))")
(assume "M" "N")
(elim)
(assume "M0")
(assume "MonM")
(elim)
(assume "N0")
(assume "MonN")
(use "MonIntro")
(assume "p" "q" "p<=q")
(ng #t)
(use "NatMaxLUB")
(use "NatLeTrans" (pt "M0 q"))
(use "MonM")
(auto)
(use "NatMaxUB1")
(use "NatLeTrans" (pt "N0 q"))
(auto)
(use "NatMaxUB2")
(save "MonMaxMon")



(set-goal "all f,g (all a,n( g doml <= f approx a n) -> all a,n( f approx a n <= g domr) -> Cont f -> Cont g -> Cont (o g f))")
(assume "f" "g" )
(assume "domfl" "domfr")
(assume "Cf" "Cg")
(use "ContIntro")
(assume "a1")
(assume "a0<=a1" "a1<=b0")
(use "RealConstrToCauchy")
(use "RealEqSToRealElim" (pt "g(RealConstr([n]f approx a1 n)f uMod)"))
(use "RealEqSIntro")
(auto)
(use "ContAppRealOne")
(use "Cg")
(ng #t)
(use "RealIntro")
(use "ContElim1")
(use "Cf")
(auto)
(use "MonIntro")
(ng #t)
(use "ContElim3")
(use "Cf")
(auto)
(assume "a" "b" "p" "n")
(ng #t)
(assume "domu1" "domu2" "domu3" "domu4")
(assume "m<=n")
(assume "cond")
(use "ContElim2")
(auto)
(use "NatLeTrans" (pt "g uMod(PosS(PosS p))max f uMod(PosPred(g uModCont(PosS p)))"))
(use "NatLeTrans" (pt "g uMod(PosS(PosS p))"))
(use "ContElim3")
(auto)
(use "PosLeTrans" (pt "PosS p"))
(auto)
(use "NatMaxUB1")
(auto)
(use "ContElim2")
(auto)
(use "NatLeTrans" (pt "g uMod(PosS(PosS p))max f uMod(PosPred(g uModCont(PosS p)))"))
(use "NatLeTrans" (pt "f uMod(PosPred(g uModCont (PosS p)))"))
(use "ContElim3")
(auto)
(use "PosLeMonPred")
(use "ContElim4")
(auto)
(use "NatMaxUB2")
(auto)
(use "RatLeTrans" (pt "(1#2**f uModCont(PosPred(g uModCont p)))"))
(auto)
(ng #t)
(use "PosExpLeMon")
(auto)
(use "MonElim")
(inst-with-to "MonMaxMon" (pt "[p]g uMod(PosS(PosS p))") (pt "[p] f uMod(PosPred(g uModCont(PosS p)))") "MonInst")
(ng "MonInst")
(use "MonInst")
(use "MonIntro")
(ng #t)
(assume "p" "q")
(assume "p<=q")
(use "ContElim3")
(auto)
(use "MonIntro")
(assume "p" "q" "p<=q")
(use "ContElim3")
(auto)
(ng #t)
(use "PosLeMonPred")
(use "ContElim4")
(auto)
(ng #t)
(assume "p" "q" "p<=q")
(use "ContElim4")
(auto)
(use "PosLeMonPred")
(use "ContElim4")
(auto)
(save "ContCompose")


(set-goal "all f,g,x( Real x -> all n f doml<= x seq n -> all n x seq n <= f domr -> all a,n( g doml <= f approx a n) -> all a,n( f approx a n <= g domr) -> Cont f -> Cont g ->(o g f) x === g(f x))")
(assume "f" "g" "x")
(strip)
(simp "o0CompRule")
(use "RealEqSToEq")
(use "ContAppRealOne")
(use "ContCompose")
(auto)
(use "ContAppRealOne")
(auto)
(use "ContAppRealOne")
(auto)
(use "RealEqSIntro")
(auto)
(save "ContComposeEqRCompose")


;;(rpc "ContMax")
(add-program-constant "ContMax" (py "cont=>cont=>cont"))

(add-computation-rule "ContMax f g" "ContConstr (f doml max g doml) (f domr min g domr) 
    ([a,n] (f approx a n) max (g approx a n)) 
    ([p] (f uMod ((PosS(p)))) max (g uMod ((PosS(p)))))
    ([p] (f uModCont p) max (g uModCont p) )
    ")
(set-totality-goal "ContMax")
(use "AllTotalElim")
(assume "f")
(use "AllTotalElim")
(assume "f0")
(ng #t)
(use "TotalContContConstr")
(use "RatTotalVar")
(use "RatTotalVar")
(use "AllTotalElim")
(assume "a")
(use "AllTotalElim")
(assume "n")
(use "RatTotalVar")
(use "AllTotalElim")
(assume "p")
(use "NatTotalVar")
(use "AllTotalElim")
(assume "p")
(use "PosTotalVar")
(save-totality)


(set-goal "all f,g(Cont f -> Cont g ->  Cont(ContMax f g))")
(assume "f" "g")
(assume "Cf" "Cg")
(use "ContIntro")
(assume "a")
(strip)
(ng #t)
(use "RealConstrToCauchy")
(inst-with-to "RealMaxReal" (pt "RealConstr([n]f approx a n) (f uMod)") (pt "RealConstr([n]g approx a n)( g uMod)") "RealInst")
(ng "RealInst")
(use "RealEqSToRealElim" (pt "RealConstr([n]f approx a n max g approx a n)([p]g uMod(PosS p)max f uMod(PosS p))"))
(use "RealEqSIntro")
(assume "n")
(ng #t)
(auto)
(assume "p")
(ng #t)
(use "NatMaxComm")
(use "RealInst")
(use "RealIntro")
(ng #t)
(use "ContElim1")
(auto)
(use "RatLeTrans" (pt "f doml max g doml"))
(use "RatMaxUB1")
(auto)
(use "RatLeTrans" (pt "f domr min g domr"))
(auto)
(use "RatMinLB1")
(use "MonIntro")
(assume "p" "q")
(ng #t)
(assume "pleq")
(use "ContElim3")
(auto)
(use "RealIntro")
(ng #t)
(use "ContElim1")
(auto)
(use "RatLeTrans" (pt "f doml max g doml"))
(use "RatMaxUB2")
(auto)
(use "RatLeTrans" (pt "f domr min g domr"))
(auto)
(use "RatMinLB2")
(use "MonIntro")
(assume "p" "q")
(assume "pleq")
(ng #t)
(use "ContElim3")
(auto)
(assume "a" "b" "p" "n")
(assume "ldomc1" "ldomc2" "ldomc3" "ldomc4" "modcond")
(assume "cond1")
(ng #t)
(use "RatLeTrans" (pt "abs(f approx a n - f approx b n) max abs(g approx a n - g approx b n)"))
(use "RatMaxTriangleRev")
(use "RatMaxLUB")
(use "ContElim2")
(auto)
(use "RatLeTrans" (pt "f doml max g doml"))
(use "RatMaxUB1")
(auto)
(use "RatLeTrans" (pt "f domr min g domr"))
(auto)
(use "RatMinLB1")
(use "RatLeTrans" (pt "f doml max g doml"))
(use "RatMaxUB1")
(auto)
(use "RatLeTrans" (pt "f domr min g domr"))
(auto)
(use "RatMinLB1")
(ng "modcond")
(use "NatLeTrans" (pt "f uMod(PosS p)max g uMod(PosS p)"))
(use "NatLeTrans" (pt "f uMod(PosS p)"))
(use "ContElim3")
(auto)
(use "NatMaxUB1")
(auto)
(use "RatLeTrans" (pt "1/2**PosPred(([p0]f uModCont p0 max g uModCont p0)p)"))
(auto)
(ng #t)
(use "PosLeMonPosExp")
(simp "PosToNatLe")
(ng #t)
(use "PosLeMonPred")
(use "PosMaxUB1")
(use "ContElim2")
(auto)
(use "RatLeTrans" (pt "f doml max g doml"))
(use "RatMaxUB2")
(auto)
(use "RatLeTrans" (pt "f domr min g domr"))
(auto)
(use "RatMinLB2")
(use "RatLeTrans" (pt "f doml max g doml"))
(use "RatMaxUB2")
(auto)
(use "RatLeTrans" (pt "f domr min g domr"))
(auto)
(use "RatMinLB2")
(use "NatLeTrans" (pt "f uMod(PosS p)max g uMod(PosS p)"))
(use "NatLeTrans" (pt "g uMod(PosS p)"))
(use "ContElim3")
(auto)
(use "NatMaxUB2")
(auto)
(use "RatLeTrans" (pt "1/2**PosPred(([p0]f uModCont p0 max g uModCont p0)p)"))
(auto)
(ng #t)
(use "PosLeMonPosExp")
(simp "PosToNatLe")
(use "PosLeMonPred")
(use "PosMaxUB2")
(assume "p" "q" "pleq")
(ng #t)
(use "NatMaxLUB")
(use "NatLeTrans" (pt "f uMod(PosS q)"))
(use "ContElim3")
(auto)
(use "NatMaxUB1")
(use "NatLeTrans" (pt "g uMod(PosS q)"))
(use "ContElim3")
(auto)
(use "NatMaxUB2")
(ng #t)
(assume "p" "q")
(assume "pleq")
(use "PosMaxLUB")
(use "PosLeTrans" (pt "f uModCont q"))
(use "ContElim4")
(auto)
(use "PosMaxUB1")
(use "PosLeTrans" (pt "g uModCont q"))
(use "ContElim4")
(auto)
(use "PosMaxUB2")
(save "ContMaxCont")





; (add-program-constant "ContMin" (py "cont=>cont=>cont"))

; (add-computation-rule "ContMin f g" "ContConstr (f doml max g doml) (f domr min g domr) 
;     ([a,n] (f approx a n) min (g approx a n)) 
;     ([p] (f uMod ((PosS(p)))) max (g uMod ((PosS(p)))))
;     ([p] (f uModCont p) max (g uModCont p) )
;     ")









;; End Continuous Functions

;; Begin Continuous Functions of two variables


(add-alg "contft" (list "ContFt" "rat=>rat=>rat=>rat=>(rat=>rat=>nat=>rat)=>(pos=>nat)=>(pos=>pos)=>contft"))
(add-totality "contft")


(add-var-name "hft" (py "rat=>rat=>nat=>rat"))
(add-var-name "alt" (py "pos=>nat"))
(add-var-name "modt" (py "pos=>pos"))
(add-var-name "ft" (make-alg "contft"))

(add-program-constant "ContFtDoml" (py "contft=>rat") t-deg-zero)
(add-postfix-display-string "ContFtDoml" "ftdoml")
(add-computation-rules "(ContFt a0 b0 c0 d0 hft alt modt)ftdoml" "a0")


(set-goal (rename-variables (term-to-totality-formula (pt "ContFtDoml"))))
(assume "ft^" "Tft")
(elim "Tft")
(assume "a^" "Ta" "b^" "Tb" "c^" "Tc" "d^" "Td" "hft^" "Thtwo" "M^" "TM" "om^" "Tom")
(ng #t)
(use "Ta")
(save "ContFtDomlTotal")


(add-program-constant "ContFtDomr" (py "contft=>rat") t-deg-zero)
(add-postfix-display-string "ContFtDomr" "ftdomr")
(add-computation-rules "(ContFt a0 b0 c0 d0 hft alt modt)ftdomr" "b0")


(set-goal (rename-variables (term-to-totality-formula (pt "ContFtDomr"))))
(assume "ft^" "Tft")
(elim "Tft")
(assume "a^" "Ta" "b^" "Tb" "c^" "Tc" "d^" "Td" "hft^" "Thtwo" "M^" "TM" "om^" "Tom")
(ng #t)
(use "Tb")
(save "ContFtDomrTotal")

(add-program-constant "ContFtDomll" (py "contft=>rat") t-deg-zero)
(add-postfix-display-string "ContFtDomll" "ftdomll")
(add-computation-rules "(ContFt a0 b0 c0 d0 hft alt modt)ftdomll" "c0")


(set-goal (rename-variables (term-to-totality-formula (pt "ContFtDomll"))))
(assume "ft^" "Tft")
(elim "Tft")
(assume "a^" "Ta" "b^" "Tb" "c^" "Tc" "d^" "Td" "hft^" "Thtwo" "M^" "TM" "om^" "Tom")
(ng #t)
(use "Tc")
(save "ContFtDomllTotal")

(add-program-constant "ContFtDomrr" (py "contft=>rat") t-deg-zero)
(add-postfix-display-string "ContFtDomrr" "ftdomrr")
(add-computation-rules "(ContFt a0 b0 c0 d0 hft alt modt)ftdomrr" "d0")


(set-goal (rename-variables (term-to-totality-formula (pt "ContFtDomrr"))))
(assume "ft^" "Tft")
(elim "Tft")
(assume "a^" "Ta" "b^" "Tb" "c^" "Tc" "d^" "Td" "hft^" "Thtwo" "M^" "TM" "om^" "Tom")
(ng #t)
(use "Td")
(save "ContFtDomrrTotal")

(add-program-constant "ContFtapprox" (py "contft=>rat=>rat=>nat=>rat") t-deg-zero 'const 1)
(add-postfix-display-string "ContFtapprox" "ftapprox")
(add-computation-rules "(ContFt a0 b0 c0 d0 hft alt modt)ftapprox" "hft")

(set-goal (rename-variables (term-to-totality-formula (pt "ContFtapprox"))))
(assume "ft^" "Tft")
(elim "Tft")
(assume "a^" "Ta" "b^" "Tb" "c^" "Tc" "d^" "Td" "hft^" "Thtwo" "M^" "TM" "om^" "Tom")
(ng #t)
(use "Thtwo")
(save "ContFtapproxTotal")


(add-program-constant "ContFtmod" (py "contft=>pos=>nat") t-deg-zero 'const 1)
(add-postfix-display-string "ContFtmod" "ftmod")
(add-computation-rules "(ContFt a0 b0 c0 d0 hft alt modt)ftmod" "alt")

(set-goal (rename-variables (term-to-totality-formula (pt "ContFtmod"))))
(assume "ft^" "Tft")
(elim "Tft")
(assume "a^" "Ta" "b^" "Tb" "c^" "Tc" "d^" "Td" "hft^" "Thtwo" "M^" "TM" "om^" "Tom")
(ng #t)
(use "TM")
(save "ContFtmodTotal")


(add-program-constant "ContFtmodcont" (py "contft=>pos=>pos") t-deg-zero 'const 1)
(add-postfix-display-string "ContFtmodcont" "ftmodcont")
(add-computation-rules "(ContFt a0 b0 c0 d0 hft alt modt)ftmodcont" "modt")


(set-goal (rename-variables (term-to-totality-formula (pt "ContFtmodcont"))))
(assume "ft^" "Tft")
(elim "Tft")
(assume "a^" "Ta" "b^" "Tb" "c^" "Tc" "d^" "Td" "hft^" "Thtwo" "M^" "TM" "om^" "Tom")
(ng #t)
(use "Tom")
(save "ContFtmodcontTotal")





;; End Continuous Functions of two variables


;;(set-goal "all x,y,f(f doml <+=x-> f doml<+=y)")

;;(remove-idpc-name "ContEq")

(add-ids
(list (list "ContEq" (make-arity (py "cont") (py "cont") )))
'("allnc f,g( Cont f --> Cont g -->f doml == g doml --> f domr == g domr -->all x ( Real x --> f doml<+=x -> x<+=f domr -> (f x)===(g x) ) --> ContEq f g)" "ContEqIntro" ))

(set-goal "ContEq f g -> Cont f & Cont g & f doml == g doml & f domr == g domr")
(assume "f" "g")
(elim)
(auto)
(save "ContEqElim0")

(set-goal "ContEq f g -> all x ( Real x --> f doml<+=x -> x<+=f domr -> (f x)===(g x) )")
(assume "f" "g")
(elim)
(auto)
(save "ContEqElim1")

(set-goal "all f,g(ContEq f g -> ContEq g f)")
(assume "f" "g")
(elim)
(assume "f1" "g1" "cf1" "cf2" "dom1" "dom2" "cond1")
(use "ContEqIntro")
(auto)
(use "RatEqvSym")
(auto)
(use "RatEqvSym")
(auto)
(assume "x" "Rx" "Le1" "Le2")
(use "RealEqSym")
(use "cond1")
(auto)
(use "RealLeSTrans" (pt "ReaRat g1 doml"))
(use "RealLeSRefl")
(use "RealEqSIntro")
(assume "n")
(auto)
(use "RealLeSTrans" (pt "ReaRat g1 domr"))
(auto)
(use "RealLeSRefl")
(use "RealEqSIntro")
(assume "n")
(auto)
(ng #t)
(use "RatEqvSym")
(auto)
(save "ContEqSym")


(add-var-name "deltaf" (py "pos=>pos"))

;; (remove-idpc-name "Derivative")

(add-ids
 (list (list "Derivative" (make-arity (py "cont") (py "cont") (py "pos=>pos") )))
 '("allnc f,g,deltaf( Cont f --> Cont g -->f doml == g doml --> f domr == g domr --> all x,y,p ( Real x --> Real y --> f doml<+= x --> x <+=f domr --> f doml<+= y --> y <+=f domr --> abs(x - y) <<=  (1/2)**(deltaf p) --> abs( (f y) - (f x) - (g x)*(y - x)) <<= abs(y-x)*(1/2)**p) --> all p,q(p<=q -> deltaf p<=deltaf q) --> all p(p<=deltaf p) --> Derivative f g deltaf)" "DerivativeIntro" ))

(set-goal "all f,g,deltaf(Derivative f g deltaf -> Cont f)")
(assume "f" "g" "deltaf")
(elim)
(auto)
(save "DerivativeElim1")


(set-goal "all f,g,deltaf(Derivative f g deltaf -> Cont g)")
(assume "f" "g" "deltaf")
(elim)
(auto)
(save "DerivativeElim2")

(set-goal "all f,g,deltaf(Derivative f g deltaf -> f doml == g doml & f domr == g domr )")
(assume "f" "g" "deltaf")
(elim)
(auto)
(save "DerivativeElim3")

(set-goal "all f,g,deltaf(Derivative f g deltaf -> all x,y,p ( Real x --> Real y --> f doml<+= x --> x <+=f domr --> f doml<+= y --> y <+=f domr --> abs(x - y) <<=  (1/2)**(deltaf p) --> abs( (f y) - (f x) - (g x)*(y - x)) <<= abs(y-x)*(1/2)**p) )")
(assume "f" "g" "deltaf")
(elim)
(auto)
(save "DerivativeElim4")

(set-goal "all f,g,deltaf(Derivative f g deltaf -> all p,q(p<=q -> deltaf p<=deltaf q) & all p(p<=deltaf p) )")
(assume "f" "g" "deltaf")
(elim)
(auto)
(save "DerivativeElim5")



(set-goal "all f,g,g1,deltaf(ContEq f g -> Derivative f g1 deltaf -> Derivative g g1 deltaf)")
(assume "f" "g" "g1" "deltaf")
(assume "f=g")
(assume "f'")
(cut "f doml=+=g doml")
(assume "Assertion1")
(cut "g domr=+=f domr")
(assume "Assertion2")
(use "DerivativeIntro")
(use "ContEqElim0" (pt "f"))
(use "ContEqSym")
(auto)
(use "DerivativeElim2" (pt "f") (pt "deltaf"))
(auto)
(simprat (pf "g doml==f doml"))
(use "DerivativeElim3" (pt "deltaf"))
(auto)
(use "ContEqElim0")
(use "ContEqSym")
(auto)
(simprat (pf "g domr==f domr"))
(use "DerivativeElim3" (pt "deltaf"))
(auto)
(use "ContEqElim0")
(use "ContEqSym")
(auto)
(assume "x" "y" "p"  "Rx" "Ry" "cond1" "cond2" "cond3" "cond4" "cond5")
(simp "RealMinus0CompRule")
(simp "RealMinus0CompRule")
(simp "RealMinus0CompRule")
(cut "Real (g1 x)")
(assume "cut1")
(cut "Real(g y)")
(assume "cut2")
(cut "Real(g x)")
(assume "cut3")
(simpreal (pf "g y===f y"))
(cut "Real(f y)")
(assume "cut4")
(simpreal (pf "g x===f x"))
(use "DerivativeElim4"  (pt "deltaf") (pt "p1"))
(auto)
(use "RealLeSTrans" (pt "ReaRat g doml"))
(use "RealLeSRefl")
(auto)
(use "RealLeSTrans" (pt "ReaRat g domr"))
(auto)
(use "RealLeSRefl")
(auto)
(use "RealLeSTrans" (pt "ReaRat g doml"))
(use "RealLeSRefl")
(auto)
(use "RealLeSTrans" (pt "ReaRat g domr"))
(auto)
(use "RealLeSRefl")
(auto)
(use "RealEqSym")
(use "ContEqElim1")
(auto)
(use "RealLeSTrans" (pt "ReaRat g doml"))
(use "RealLeSRefl")
(auto)
(use "RealLeSTrans" (pt "ReaRat g domr"))
(auto)
(use "RealLeSRefl")
(auto)
(use "RealEqElim1" (pt "g y"))
(use "ContEqElim1")
(use "ContEqSym")
(auto)
(use "ContEqElim1")
(use "ContEqSym")
(auto)
(use "RealEqElim1" (pt "f x"))
(use "ContEqElim1")
(auto)
(use "RealLeSTrans" (pt "ReaRat g doml"))
(use "RealLeSRefl")
(auto)
(use "RealLeSTrans" (pt "ReaRat g domr"))
(auto)
(use "RealLeSRefl")
(auto)
(use "RealEqElim1" (pt "f y"))
(use "ContEqElim1")
(auto)
(use "RealLeSTrans" (pt "ReaRat g doml"))
(use "RealLeSRefl")
(auto)
(use "RealLeSTrans" (pt "ReaRat g domr"))
(auto)
(use "RealLeSRefl")
(auto)
(use "ContAppRealOne")
(use "DerivativeElim2" (pt "f") (pt "deltaf"))
(auto)
(assume "n")
(simprat (pf "g1 doml==(g doml) seq n"))
(use "RealLeSElim1")
(auto)
(ng #t)
(simprat (pf "g doml==f doml"))
(use "RatEqvSym")
(use "DerivativeElim3" (pt "deltaf"))
(auto)
(use "RatEqvSym")
(use "ContEqElim0")
(auto)
(assume "n")
(simprat (pf "g1 domr==(g domr) seq n"))
(use "RealLeSElim1")
(auto)
(ng #t)
(simprat (pf "g domr==f domr"))
(use "RatEqvSym")
(use "DerivativeElim3" (pt "deltaf"))
(auto)
(use "ContEqElim0")
(use "ContEqSym")
(auto)
;;(use "RealEqSIntro")
(assume "p" "q" "cond1")
(use "DerivativeElim5" (pt "f") (pt "g1"))
(auto)
(assume "p")
(use "DerivativeElim5" (pt "f") (pt "g1"))
(auto)
(use "RealEqSIntro")
(ng #t)
(assume "n")
(use "ContEqElim0")
(use "ContEqSym")
(auto)
(use "RealEqSIntro")
(ng #t)
(assume "n")
(use "ContEqElim0")
(auto)
(save "ContEqDerivativeSub")



(set-goal "all a,b,c(0<a -> b<c -> b*a<c*a)")
(assume "a" "b" "c")
(assume "0<a" "b<c")
(use "RatLtTimesCancelR" (pt "1/a"))
(use "RatLtToLe")
(use "RatPosUDivTrans")
(auto)
(ng #t)
(simp "<-" "RatTimesAssoc")
(simprat (pf "a*RatUDiv a==1"))
(simp "<-" "RatTimesAssoc")
(simprat (pf "a*RatUDiv a==1"))
(auto)
(simp "RatTimesComm")
(use "RatUDivIdEqOne")
(use "RatLtLeTrans" (pt "a"))
(auto)
(simp "RatTimesComm")
(use "RatUDivIdEqOne")
(use "RatLtLeTrans" (pt "a"))
(auto)
(save "RatLtMonTimes")


(set-goal "all x,p(Real x -> abs(x + ~ (x seq (x mod p)))<<=(1#2)**p)")
(assume "x" "p" "Rx")
(use "RealLeTrans" (pt "abs(x + ~(ReaRat (x seq(x mod p))))"))
(ng #t)
(use "RealLeRefl")
(autoreal)
(simpreal "RealAbsUMinusPlusComm")
(simp "ReaRat0CompRule")
(use "RealApproxExFree")
(auto)
(simp "ReaRat0CompRule")
(autoreal)
(save "RealApproxExFreeR")



(set-goal "all x,a,b,p0,deltaf,f,g( Derivative f g deltaf -> Real x -> a<b ->a<+=x -> x<+=b ->  ex y,p1 ( Real y & abs(x-y)<<=(1/2)**deltaf p0 & a<+=y & y<+=b & RealPos abs(x-y) p1))")
(cases)
(assume "as" "M")
(assume "a" "b" "p" "deltaf" "f" "g")
(assume "Df")
(assume "Rx" "a<b" "a<=x" "x<=b")
;;(inst-with-to "RatLeftPosBound" (pt "(b+ ~a)/2") "Inst")
(inst-with-to "RatLeftPosBound" (pt "(b+ ~a)") "Inst")
(assert " exl q ((1#2**q)<=(b+ ~a) & (p<=q))")
(cut "exl q (1#2**q)<=b+ ~a")
(assume "cutIn")
(by-assume "cutIn" "q0" "cutInPro")
(intro 0 (pt "q0 max p"))
(split)
(use "RatLeTrans" (pt "(1#2**q0)"))
(ng #t)
(use "PosExpTwoPosLe")
(use "PosMaxUB1")
(auto)
(use "PosMaxUB2")
(use "Inst")
(use "RatLtPlusCancelR" (pt "a"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "~a+a==0"))
(ng #t)
(use "a<b")
(ng #t)
(use "Truth")
;;(use "Truth")
(assume "ExInst")
(by-assume "ExInst" "q" "ExInstProp")
(cases (pt "as (M(PosS(PosS(deltaf q)))) + (1#2**PosS(deltaf q)) <=b"))
(assume "case")
(ex-intro  (pt "RealConstr([n] as (M(PosS(PosS(deltaf q)))))([p] Zero) + (1#2**PosS(deltaf q))"))
(ex-intro (pt "PosS(PosS(PosS(deltaf q)))"))
(split)
(autoreal)
(split)
(simp "RealMinus0CompRule")
(simpreal "RealUMinusPlus")
(inst-with-to "RealLeAbsPlus" (pt "RealConstr as M+ (~(as(M(PosS(PosS(deltaf q))))))") (pt "(ReaRat ~(1#2**PosS(deltaf q)))") "rInst")
(use "RealLeTrans" (pt "abs(RealConstr as M+ ~(as(M(PosS(PosS(deltaf q)))))+ ReaRat~(1#2**PosS(deltaf q)))"))
(use "RealLeReflNC")
(use "RealEqSToEq")
(realproof)
(simp "ReaRat0CompRule")
(realproof)
(use "RealEqSIntro")
(auto)
(use "RealLeTrans" (pt "abs(RealConstr as M+ ~(as(M(PosS(PosS(deltaf q))))))+abs(ReaRat~(1#2**PosS(deltaf q)))"))
(use "RealLeAbsPlus")
(realproof)
(simp "ReaRat0CompRule")
(realproof)
(use "RealLeTrans" (pt "ReaRat (1#2**PosS(deltaf q))+ ReaRat (1#2**PosS(deltaf q))"))
(use "RealLeMonPlus")
(simp "ReaRat0CompRule")
(inst-with-to "RealApproxExFreeR" (pt "RealConstr as M") (pt "PosS(PosS(deltaf q))") "ApproxInst")
(use "RealLeTrans" (pt "ReaRat ((1#2)**PosS(PosS(deltaf q)))"))
(simp "ReaRat0CompRule")
(use "ApproxInst")
(auto)
(ng #t)
(use "RatLeToRealLe")
(ng #t)
(use "PosExpTwoPosLe")
(auto)
(simp "ReaRat0CompRule")
(use "RatLeToRealLe")
(ng #t)
(use "Truth")
(simp "ReaRat0CompRule")
(use "RatLeToRealLe")
(use "RatLeTrans" (pt "(1#2**PosS(deltaf q))+(1#2**PosS(deltaf q))"))
(auto)
(use "RatLeTrans" (pt "(1#2**deltaf q)"))
(use "RatLeRefl")
(use "RatPlusHalfExpPosS")
(ng #t)
(use "PosExpTwoPosLe")
(use "DerivativeElim5" (pt "f") (pt "g"))
(auto)
(realproof)
(realproof)
(split)
(use "RealLeSIntro1")
(assume "n")
(ng #t)
(use "RatLeTrans" (pt "as(M(PosS(PosS(deltaf q)))) + 0"))
(ng #t)
(simp (pf "a = a seq (M(PosS(PosS(deltaf q))))"))
(simp (pf "as(M(PosS(PosS(deltaf q)))) = (RealConstr as M) seq (M(PosS(PosS(deltaf q))))"))
(use "RealLeSElim1")
(auto)
(split)
(use "RealLeSIntro1")
(ng #t)
(assume "n")
(use "case")
(use "RealPosChar2RealConstrFree" (pt "M(PosS(PosS(deltaf q)))"))
(simp "RealMinus0CompRule")
(autoreal)
(assume "n" "cond")
(ng #t)
(use "RatLeTrans" (pt "(1#2**PosS(deltaf q)) + as(M(PosS(PosS(deltaf q)))) + ~(as n)"))
(use "RatLePlusCancelL" (pt "~(1#2**PosS(deltaf q))"))
(simp "RatPlusAssoc")
(simp "RatPlusAssoc")
(simprat (pf "~(1#2**PosS(deltaf q))+(1#2**PosS(deltaf q))==0"))
(simprat (pf "~(1#2**PosS(deltaf q))+(1#2**PosS(PosS(deltaf q)))== ~(1#2**PosS(PosS(deltaf q)))"))
(use "RatLeUMinusToLeSwitch")
(ng #t)
(simp "RatPlusComm")
(use "RatLeTrans" (pt "abs(as n+ ~(as(M(PosS(PosS(deltaf q))))))"))
(auto)
(use "CauchyElim" (pt "M"))
(use "RealConstrToCauchy")
(auto)
(use "RatEqvPlusCancelL" (pt "(1#2**PosS(deltaf q))"))
(simp "RatPlusAssoc")
(simprat (pf "(1#2**PosS(deltaf q))+ ~(1#2**PosS(deltaf q))==0"))
(use "RatEqvTrans" (pt "(1#2**PosS(PosS(deltaf q)))"))
(auto)
(use "RatPlusHalfExpPosSSplit")
(auto)
(simp "RatAbsMax")
(use "RatLeTrans" (pt " ~(as n+ ~(as(M(PosS(PosS(deltaf q)))))+(IntN 1#2**PosS(deltaf q)))"))
(ng #t)
(simp "RatPlusComm")
(use "RatLePlusCancelL" (pt "as n"))
(ng #t)
(simprat (pf "as n+ ~(as n)==0"))
(ng #t)
(simp "RatPlusComm")
(auto)
(use "RatMaxUB2")
(assume "False1")
(ex-intro  (pt "RealConstr([n] as (M(PosS(PosS(deltaf q)))))([p] Zero) + ~(1#2**PosS(deltaf q))"))
(ex-intro (pt "PosS(PosS(PosS(deltaf q)))"))
(split)
(autoreal)
(split)
(simp "RealMinus0CompRule")
(simpreal "RealUMinusPlus")
(simpreal "RealPlusAssoc")
(use "RealLeTrans" (pt "abs(RealConstr as M+ ~(as(M(PosS(PosS(deltaf q)))))+ ReaRat(~ ~(1#2**PosS(deltaf q))))"))
(use "RealLeReflNC")
(use "RealEqSToEq")
(realproof)
(simp "ReaRat0CompRule")
(realproof)
(use "RealEqSIntro")
(auto)
(use "RealLeTrans" (pt "abs(RealConstr as M+ ~(as(M(PosS(PosS(deltaf q)))))) + abs(ReaRat ~ ~(1#2**PosS(deltaf q)))" ))
(use "RealLeAbsPlus")
(realproof)
(simp "ReaRat0CompRule")
(realproof)
(use "RealLeTrans" (pt "ReaRat (1#2**PosS(deltaf q))+ ReaRat (1#2**PosS(deltaf q))"))
(use "RealLeMonPlus")
(use "RealLeTrans" (pt "ReaRat (1#2**PosS(PosS(deltaf q)))"))
(simp "ReaRat0CompRule")
(inst-with-to "RealApproxExFreeR" (pt "RealConstr as M") (pt "PosS(PosS(deltaf q))") "ApproxInst")
(use "ApproxInst")
(auto)
(ng #t)
(use "RatLeToRealLe")
(ng #t)
(use "PosExpTwoPosLe")
(auto)
(ng #t)
(use "RatLeToRealLe")
(auto)
(use "RatLeToRealLe")
(use "RatLeTrans" (pt "(1#2**PosS(deltaf q))+(1#2**PosS(deltaf q))"))
(auto)
(use "RatLeTrans" (pt "(1#2**deltaf q)"))
(use "RatLeRefl")
(use "RatPlusHalfExpPosS")
(ng #t)
(use "PosExpTwoPosLe")
(use "DerivativeElim5" (pt "f") (pt "g"))
(auto)
(realproof)
(realproof)
(realproof)
(realproof)
(realproof)
(split)
(ng #t)
(use "RealLeSIntro1")
(assume "n")
(ng #t)
(assert "b<as(M(PosS(PosS(deltaf q))))+(1#2**PosS(deltaf q))")
(use "RatNotLeToLt")
(auto)
(assume "bCond")
(use "RatLeTrans" (pt "b + ~(1#2**PosS(deltaf q)) + ~(1#2**PosS(deltaf q))"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "~(1#2**PosS(deltaf q))+ ~(1#2**PosS(deltaf q))== ~(1#2**(deltaf q))"))
(use "RatLePlusCancelR" (pt "1#2**deltaf q"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "~(1#2**deltaf q)+(1#2**deltaf q)==0"))
(use "RatLePlusCancelL" (pt "~a"))
(ng #t)
(simprat (pf "~a+a==0"))
(ng #t)
(simp "RatPlusComm")
(use "RatLeTrans" (pt "(1#2**q)"))
(ng #t)
(use "PosExpTwoPosLe")
(use "DerivativeElim5" (pt "f") (pt "g"))
(use "Df")
(use "ExInstProp")
(auto)
(simprat (pf "~(1#2**PosS(deltaf q))+ ~(1#2**PosS(deltaf q))== ~((1#2**PosS(deltaf q)) + (1#2**PosS(deltaf q)))"))
(simp "RatEqvUMinusInj")
(use "RatPlusHalfExpPosS")
(auto)
(use "RatLeMonPlus")
(use "RatLePlusCancelR" (pt "(1#2**PosS(deltaf q))"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "~(1#2**PosS(deltaf q))+(1#2**PosS(deltaf q))==0"))
(use "RatLtToLe")
(auto)
(split)
(ng #t)
(use "RealLeSIntro1")
(assume "n")
(ng #t)
(use "RatLeTrans" (pt "as(M(PosS(PosS(deltaf q)))) + 0"))
(use "RatLeMonPlus")
(auto)
(ng #t)
(simp (pf "as(M(PosS(PosS(deltaf q)))) = (RealConstr as M) seq (M(PosS(PosS(deltaf q))))"))
(simp (pf "b = b seq (M(PosS(PosS(deltaf q))))"))
(use "RealLeSElim1")
(auto)
(use "RealPosChar2RealConstrFree" (pt "M(PosS(PosS(deltaf q)))"))
(simp "RealMinus0CompRule")
(autoreal)
(assume "n" "cond")
(ng #t)
(use "RatLeTrans" (pt "(as n+ ~(as(M(PosS(PosS(deltaf q)))))+(1#2**PosS(deltaf q)))"))
(use "RatLePlusCancelR" (pt "~((1#2**PosS(deltaf q)))"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "(1#2**PosS(deltaf q))+ ~(1#2**PosS(deltaf q))==0"))
(simprat (pf "(1#2**PosS(PosS(deltaf q)))+ ~(1#2**PosS(deltaf q))== ~(1#2**PosS(PosS(deltaf q)))"))
(use "RatLeUMinusToLeSwitch")
(ng #t)
(simp "RatPlusComm")
(use "RatLeTrans" (pt "abs(as(M(PosS(PosS(deltaf q))))+ ~(as n))"))
(auto)
(use "CauchyElim" (pt "M"))
(use "RealConstrToCauchy")
(auto)
(use "RatEqvPlusCancelR" (pt "(1#2**PosS(deltaf q))"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "~(1#2**PosS(deltaf q))+(1#2**PosS(deltaf q))==0"))
(use "RatEqvPlusCancelL" (pt "(1#2**PosS(PosS(deltaf q)))") )
(simp "RatPlusAssoc")
(simp "RatPlusAssoc")
(simprat (pf "(1#2**PosS(PosS(deltaf q)))+ ~(1#2**PosS(PosS(deltaf q)))==0"))
(use "RatPlusHalfExpPosS")
(auto)
(save "DerivativeExStep")

;;(remove-theorem "DerivativeExStep")

(set-goal  "all f,g,g1,deltaf(Derivative f g deltaf -> Derivative f g1 deltaf -> f doml < f domr -> ContEq g g1)")
(assume "f" "g" "g1" "deltaf")
(assume "fg'" "fg1'" "PropInterval")
(use "ContEqIntro")
(use "DerivativeElim2" (pt "f") (pt "deltaf"))
(auto)
(use "DerivativeElim2" (pt "f") (pt "deltaf"))
(auto)
(simprat (pf "g doml==f doml"))
(simprat (pf "g1 doml==f doml"))
(auto)
(use "RatEqvSym")
(use "DerivativeElim3" (pt "deltaf"))
(auto)
(use "RatEqvSym")
(use "DerivativeElim3" (pt "deltaf"))
(auto)
(simprat (pf "g domr==f domr"))
(simprat (pf "g1 domr==f domr"))
(auto)
(use "RatEqvSym")
(use "DerivativeElim3" (pt "deltaf"))
(auto)
(use "RatEqvSym")
(use "DerivativeElim3" (pt "deltaf"))
(auto)
(assume "x" "Rx" "cond1" "cond2")
(cut "Real(g x)")
(assume "Rgx")
(cut  "Real(g1 x)")
(assume "Rg1x")
(use "RealEqChar2RLe")
; proof of reapp
(auto)
(assume "p")
(inst-with-to "DerivativeExStep" (pt "x") (pt "g doml") (pt "g domr") (pt "PosS p") (pt "deltaf") (pt "f") (pt "g") "Step")
(assert "ex y,p0(Real y & abs(x-y)<<=(1/2)**deltaf (PosS p) & g doml<+=y & y<+=g domr & RealPos abs(x-y)p0)")
(use "Step")
(auto)
(simprat (pf "g doml == f doml"))
(simprat (pf "g domr == f domr"))
(auto)
(use "RatEqvSym")
(use "DerivativeElim3" (pt "deltaf"))
(auto)
(use "RatEqvSym")
(use "DerivativeElim3" (pt "deltaf"))
(auto)
(assume "StepInst")
(drop "Step")
(by-assume "StepInst" "y" "StepInstP1")
(by-assume "StepInstP1" "p0" "StepInstP2")
(assert "Real y")
(auto)
(assume "Ry")
(use "RealLeTimesCancelR" (pt "abs(x-y)") (pt "p0"))
(realproof)
(simp "RealMinus0CompRule")
(realproof)
(realproof)
(auto)
(simp "RealMinus0CompRule")
(simpreal (pf "abs(x + ~y)===abs(y + ~x)"))
(simpreal "<-" "RealAbsTimes")
(simpreal "RealTimesComm")
(simpreal "RealTimesPlusDistr")
(cut "Real(f x)")
(assume "Rfx")
(cut "Real(f y)")
(assume "Rfy")
(use "RealLeTrans" (pt "abs(~(f y) + (f x) + (y+ ~x)*g x+ (f y) + ~(f x) + (y+ ~x)* ~(g1 x))"))
(use "RealLeReflNC")
(use "RealAbsCompat")
(use "RealEqPlusCancelR" (pt "~((y+ ~x)* ~(g1 x))"))
(autoreal)
(simpreal "<-" "RealPlusAssoc")
(simpreal "<-" "RealPlusAssoc")
(simpreal (pf "(y+ ~x)* ~(g1 x)+ ~((y+ ~x)* ~(g1 x))===0"))
(simpreal "RealPlusZero")
(simpreal "RealPlusZero")
(simpreal "<-" "RealPlusAssoc")
(simpreal "<-" "RealPlusAssoc")
(use "RealEqSym")
(simpreal "RealPlusComm")
(use "RealEqTrans" (pt "(y+ ~x)*g x + 0"))
(simpreal "<-" "RealPlusAssoc")
(use "RealPlusCompat")
(use "RealTimesCompat")
(use "RealEqRefl")
(autoreal)
(use "RealEqRefl")
(autoreal)
(use "RealEqPlusCancelL" (pt "~(f y)"))
(autoreal)
(simpreal  "RealPlusAssoc")
(simpreal "RealPlusAssoc")
(simpreal "RealPlusAssoc")
(simpreal (pf "~(f y)+f y===0"))
(simpreal "RealPlusZero")
(simpreal "RealPlusComm")
(simpreal (pf "0+ ~(f x)+ ~(f y)=== ~(f x)+ ~(f y)"))
(simpreal "RealPlusAssoc")
(simpreal (pf "f x+ ~(f x)===0"))
(simpreal "RealPlusComm")
(simpreal "RealPlusZero")
(use "RealEqRefl")
(autoreal)
(use "RealPlusMinusZero")
(autoreal)
(use "RealPlusCompat")
(simpreal "RealPlusComm")
(simpreal "RealPlusZero")
(use "RealEqRefl")
(autoreal)
(use "RealEqRefl")
(autoreal)
(simpreal "RealPlusComm")
(use "RealPlusMinusZero")
(autoreal)
(simpreal "RealPlusZero")
(use "RealEqRefl")
(autoreal)
(use "RealPlusMinusZero")
(autoreal)
(use "RealLeTrans" (pt "abs(~(f y)+f x+(y+ ~x)*g x) + abs(f y+ ~(f x)+(y+ ~x)* ~(g1 x))"))
(inst-with-to "RealLeAbsPlus" (pt "(~(f y)+f x+(y+ ~x)*g x)") (pt "f y+ ~(f x)+(y+ ~x)* ~(g1 x)") "RInst")
(simpreal (pf "~(f y)+f x+(y+ ~x)*g x+f y+ ~(f x)+(y+ ~x)* ~(g1 x)=== ~(f y)+f x+(y+ ~x)*g x+(f y+ ~(f x)+(y+ ~x)* ~(g1 x))"))
(use "RInst")
(autoreal)
(simpreal "RealPlusAssoc")
(simpreal "RealPlusAssoc")
(use "RealEqRefl")
(autoreal)
(use "RealLeTrans" (pt "(1#2**(PosS p))*abs(y+ ~x) + (1#2**(PosS p))*abs(y+ ~x)"))
(use "RealLeMonPlus")
(simpreal (pf "(1#2**PosS p)*abs(y+ ~x)===abs(y+ ~x)*((1#2**PosS p))"))
(simpreal (pf "abs(~(f y)+f x+(y+ ~x)*g x)===abs((f y) - (f x) - (g x)*(y- x) )"))
(use "DerivativeElim4" (pt "deltaf"))
(auto)
(use "RealLeSIntro1")
(assume "n")
(use "RatLeTrans" (pt "g doml seq n"))
(ng #t)
(use "RatLeRefl")
(use "DerivativeElim3" (pt "deltaf"))
(auto)
(use "RealLeSElim1")
(auto)
(use "RealLeSIntro1")
(assume "n")
(use "RatLeTrans" (pt "g domr seq n"))
(use "RealLeSElim1")
(auto)
(ng #t)
(use "RatLeRefl")
(use "RatEqvSym")
(use "DerivativeElim3" (pt "deltaf"))
(auto)
(use "RealLeSIntro1")
(assume "n")
(use "RatLeTrans" (pt "g doml seq n"))
(ng #t)
(use "RatLeRefl")
(use "DerivativeElim3" (pt "deltaf"))
(auto)
(use "RealLeSElim1")
(auto)
(use "RealLeSIntro1")
(assume "n")
(use "RatLeTrans" (pt "g domr seq n"))
(use "RealLeSElim1")
(auto)
(ng #t)
(use "RatLeRefl")
(use "RatEqvSym")
(use "DerivativeElim3" (pt "deltaf"))
(auto)
(simp "RealMinus0CompRule")
(simp "RealMinus0CompRule")
(simp "RealMinus0CompRule")
(simpreal (pf "~(f y)+f x+(y+ ~x)*g x=== ~(f y)+(f x+(y+ ~x)*g x)"))
(simpreal (pf "~(f y)+(f x+(y+ ~x)*g x) === (f x+(y+ ~x)*g x) + ~(f y) "))
(simpreal "RealAbsUMinusPlusComm")
(use "RealAbsCompat")
(simpreal "RealUMinusPlus")
(simpreal "RealPlusAssoc")
(use "RealPlusCompat")
(use "RealEqRefl")
(autoreal)
(use "RealUMinusCompat")
(use "RealTimesComm")
(autoreal)
(simpreal "RealPlusComm")
(use "RealEqRefl")
(autoreal)
(simpreal "RealPlusAssoc")
(use "RealEqRefl")
(autoreal)
(use "RealTimesComm")
(autoreal)
(simpreal (pf "(y+ ~x)* ~(g1 x)=== ~(y + ~x)*(g1 x)"))
(use "RealLeTrans" (pt "abs(y + ~x)*(1#2**PosS p)"))
(use "RealLeTrans" (pt "abs(f y- (f x) - (g1 x)*(y-x))"))
(simp "RealMinus0CompRule")
(simp "RealMinus0CompRule")
(simp "RealMinus0CompRule")
(use "RealLeReflNC")
(use "RealAbsCompat")
(use "RealPlusCompat")
(use "RealEqRefl")
(autoreal)
(simpreal (pf " (g1 x)*(y + ~x)===(y + ~x)*(g1 x)"))
(use "RealTimesUMinusId")
(autoreal)
(use "RealTimesComm")
(autoreal)
(use "RealLeTrans" (pt "abs(y-x)*(1#2**PosS p)"))
(use "DerivativeElim4" (pt "deltaf"))
(auto)
(use "RealLeSIntro1")
(assume "n")
(use "RatLeTrans" (pt "g doml seq n"))
(ng #t)
(use "RatLeRefl")
(use "DerivativeElim3" (pt "deltaf"))
(auto)
(use "RealLeSElim1")
(auto)
(use "RealLeSIntro1")
(assume "n")
(use "RatLeTrans" (pt "g domr seq n"))
(use "RealLeSElim1")
(auto)
(ng #t)
(use "RatLeRefl")
(use "RatEqvSym")
(use "DerivativeElim3" (pt "deltaf"))
(auto)
(use "RealLeSIntro1")
(assume "n")
(use "RatLeTrans" (pt "g doml seq n"))
(ng #t)
(use "RatLeRefl")
(use "DerivativeElim3" (pt "deltaf"))
(auto)
(use "RealLeSElim1")
(auto)
(use "RealLeSIntro1")
(assume "n")
(use "RatLeTrans" (pt "g domr seq n"))
(use "RealLeSElim1")
(auto)
(ng #t)
(use "RatLeRefl")
(use "RatEqvSym")
(use "DerivativeElim3" (pt "deltaf"))
(auto)
(simp "RealMinus0CompRule")
(use "RealLeRefl")
(autoreal)
(use "RealLeReflNC")
(use "RealTimesComm")
(autoreal)
(simpreal "RealTimesUMinusId")
(simpreal "RealTimesComm")
(simpreal "RealTimesUMinusId")
(use "RealUMinusCompat")
(use "RealTimesComm")
(autoreal)
(simpreal "<-" "RealTimesPlusDistrLeft")
(use "RealLeMonTimesTwo")
(use "RealLeToRealNNeg")
(use "RatLeToRealLe")
(auto)
(use "RealLeToRealNNeg")
(use "RealAbsNNeg")
(autoreal)
(use "RatLeToRealLe")
(use "RatLeTrans" (pt "(1#2**PosS p) + (1#2**PosS p)"))
(use "RatLeRefl")
(auto)
(use "RatLeRefl")
(use "RatPlusHalfExpPosS")
(use "RealLeRefl")
(realproof)
(realproof)
(realproof)
(realproof)
(use "ContAppRealOne")
(use "DerivativeElim1" (pt "g") (pt "deltaf"))
(auto)
(assume "n")
(simprat (pf "f doml == g doml seq n"))
(use "RealLeSElim1")
(auto)
(ng #t)
(use "DerivativeElim3" (pt "deltaf"))
(auto)
(assume "n")
(use "RatLeTrans" (pt "g domr seq n"))
(use "RealLeSElim1")
(auto)
(ng #t)
(use "RatLeRefl")
(use "RatEqvSym")
(use "DerivativeElim3" (pt "deltaf"))
(auto)
(use "ContAppRealOne")
(use "DerivativeElim1" (pt "g") (pt "deltaf"))
(auto)
(assume "n")
(simprat (pf "f doml == g doml seq n"))
(use "RealLeSElim1")
(auto)
(ng #t)
(use "DerivativeElim3" (pt "deltaf"))
(auto)
(assume "n")
(use "RatLeTrans" (pt "g domr seq n"))
(use "RealLeSElim1")
(auto)
(ng #t)
(use "RatLeRefl")
(use "RatEqvSym")
(use "DerivativeElim3" (pt "deltaf"))
(auto)
(autoreal)
(use "RealAbsUMinusPlusComm")
(realproof)
(realproof)
(use "ContAppRealOne")
(use "DerivativeElim2" (pt "f") (pt "deltaf"))
(auto)
(assume "n")
(use "RatLeTrans" (pt "g1 doml seq n"))
(auto)
(use "RealLeSElim1")
(use "RealLeSTrans" (pt "ReaRat f doml"))
(ng #t)
(use "RealLeSIntro1")
(assume "n0")
(ng #t)
(use "RatLeRefl")
(use "RatEqvSym")
(use "DerivativeElim3" (pt "deltaf"))
(auto)
(use "RealLeSTrans" (pt "ReaRat g doml"))
(use "RealLeSIntro1")
(ng #t)
(assume "n0")
(use "RatLeRefl")
(use "DerivativeElim3" (pt "deltaf"))
(auto)
(assume "n")
(use "RatLeTrans" (pt "g domr seq n"))
(use "RealLeSElim1")
(auto)
(use "RatLeTrans" (pt "f domr"))
(ng #t)
(use "RatLeRefl")
(use "RatEqvSym")
(use "DerivativeElim3" (pt "deltaf"))
(auto)
(use "RatLeRefl")
(use "DerivativeElim3" (pt "deltaf"))
(auto)
(use "ContAppRealOne")
(use "DerivativeElim2" (pt "f") (pt "deltaf"))
(auto)
(assume "n")
(use "RatLeTrans" (pt "g doml seq n"))
(auto)
(use "RealLeSElim1")
(auto)
(assume "n")
(use "RatLeTrans" (pt "g domr seq n"))
(use "RealLeSElim1")
(auto)
(save "DerivativeUnique")

(set-goal "all f,a,b(Cont f -> f doml<=a -> b<= f domr-> Cont(ContConstr a b (f approx) (f uMod) (f uModCont)))")
(cases)
(assume "a0" "b0" "h" "M" "om" "a1" "b1")
(assume "contc" "cond1" "cond2")
(use "ContIntro")
(assume "a" "a1<=a" "a<=b1")
(use "ContElim1")
(auto)
(use "RatLeTrans" (pt "a1"))
(auto)
(use "RatLeTrans" (pt "b1"))
(auto)
(assume "a" "b" "p" "n")
(assume "cond3" "cond4" "cond5" "cond6" "cond7" "cond8")
(use "ContElim2")
(auto)
(use "RatLeTrans" (pt "a1"))
(auto)
(use "RatLeTrans" (pt "b1"))
(auto)
(use "RatLeTrans" (pt "a1"))
(auto)
(use "RatLeTrans" (pt "b1"))
(auto)
(use "ContElim3")
(auto)
(use "ContElim4")
(auto)
(save "ContToContSmallerInterval")

(set-goal "all f,x,a,b(Cont f -> Real x -> f doml<=a -> b<= f domr -> a<+=x -> x<+=b -> (ContConstr a b (f approx) (f uMod) (f uModCont)) x===(f x))")
(assume "f" "x" "a" "b")
(assume "Cf" "Rx" "cond1" "cond2" "cond3" "cond4")
(use "RealEqSToEq")
(use "ContAppRealOne")
(use "ContToContSmallerInterval")
(auto)
(assume "n")
(use "RatLeTrans" (pt "a seq n"))
(auto)
(use "RealLeSElim1")
(auto)
(assume "n")
(use "RatLeTrans" (pt "b seq n"))
(use "RealLeSElim1")
(auto)
(use "ContAppRealOne")
(auto)
(assume "n")
(use "RatLeTrans" (pt "a seq n"))
(auto)
(use "RealLeSElim1")
(auto)
(assume "n")
(use "RatLeTrans" (pt "b seq n"))
(use "RealLeSElim1")
(auto)
(use "RealEqSIntro")
(assume "n")
(ng #t)
(auto)
(save "ContAppToContAppSmallerInterval")


(set-goal "all f,g,deltaf,a,b(Derivative f g deltaf -> f doml <=a -> b<= f domr -> Derivative (ContConstr a b (f approx) (f uMod) (f uModCont)) (ContConstr a b (g approx) (g uMod) (g uModCont))  deltaf)")
(cases)
(assume "a0" "b0" "h" "M" "om")
(cases)
(assume "c0" "d0" "h1" "M1" "om1")
(assume "deltaf" "a" "b")
(assume "f'")
(assume "cond1" "cond2")
(cut "Cont(ContConstr a0 b0 h M om)")
(cut "Cont(ContConstr c0 d0 h1 M1 om1)")
(assume "Cf")
(assume "Cf'")
(use "DerivativeIntro")
(use "ContToContSmallerInterval")
(auto)
(use "ContToContSmallerInterval")
(auto)
(simprat (pf "(ContConstr c0 d0 h1 M1 om1)doml==(ContConstr a0 b0 h M om)doml"))
(auto)
(use "RatEqvSym")
(use "DerivativeElim3" (pt "deltaf"))
(auto)
(simprat (pf "(ContConstr c0 d0 h1 M1 om1)domr==(ContConstr a0 b0 h M om)domr"))
(auto)
(use "RatEqvSym")
(use "DerivativeElim3" (pt "deltaf"))
(auto)
(assume "x" "y" "p")
(assume "Rx" "Ry")
(assume "cond3" "cond4" "cond5")
(assume "cond6" "cond7" )
(simp "RealMinus0CompRule")
(simp "RealMinus0CompRule")
(simp "RealMinus0CompRule")
(use "RealLeTrans" (pt "abs(((ContConstr a0 b0 h M om) y) + ~((ContConstr a0 b0 h M om) x) + ~(((ContConstr c0 d0 h1 M1 om1) x)*(y-x)))"))
(use "RealLeReflNC")
(use "RealAbsCompat")
(use "RealPlusCompat")
(use "RealPlusCompat")
(use "ContAppToContAppSmallerInterval")
(auto)
(use "RealUMinusCompat")
(use "ContAppToContAppSmallerInterval")
(auto)
(use "RealUMinusCompat")
(use "RealTimesCompat")
(use "ContAppToContAppSmallerInterval")
(auto)
(simprat (pf "(ContConstr c0 d0 h1 M1 om1)doml==(ContConstr a0 b0 h M om)doml"))
(auto)
(use "RatEqvSym")
(use "DerivativeElim3" (pt "deltaf"))
(auto)
(simprat (pf "(ContConstr c0 d0 h1 M1 om1)domr==(ContConstr a0 b0 h M om)domr"))
(auto)
(use "RatEqvSym")
(use "DerivativeElim3" (pt "deltaf"))
(auto)
(simp "RealMinus0CompRule")
(use "RealEqRefl")
(autoreal)
(inst-with-to "DerivativeElim4" (pt "ContConstr a0 b0 h M om ") (pt "ContConstr c0 d0 h1 M1 om1 ") (pt "deltaf") "RInst")
(use "RInst")
(auto)
(use "RealLeSTrans" (pt "ReaRat a"))
(use "RealLeSIntro1")
(assume "n")
(auto)
(use "RealLeSTrans" (pt "ReaRat b"))
(auto)
(use "RealLeSIntro1")
(assume "n")
(auto)
(use "RealLeSTrans" (pt "ReaRat a"))
(use "RealLeSIntro1")
(assume "n")
(auto)
(use "RealLeSTrans" (pt "ReaRat b"))
(auto)
(use "RealLeSIntro1")
(assume "n")
(auto)
(use "DerivativeElim5" (pt "ContConstr a0 b0 h M om") (pt "ContConstr c0 d0 h1 M1 om1"))
(auto)
(use "DerivativeElim5" (pt "ContConstr a0 b0 h M om") (pt "ContConstr c0 d0 h1 M1 om1"))
(auto)
(use "DerivativeElim2" (pt "ContConstr a0 b0 h M om") (pt "deltaf"))
(auto)
(use "DerivativeElim1" (pt "(ContConstr c0 d0 h1 M1 om1)") (pt "deltaf"))
(auto)
(save "DerivativeToDerivativeSmallerInterval")



(add-ids
 (list (list "ZeroApart" (make-arity (py "rea"))))
 '("all x (Real x -> all p (RealLt 0 x p) ori all p (RealLt x 0 p) -> ZeroApart x)"
   "ZeroApartIntro"))
(add-ids
 (list (list "ZeroApartAbs" (make-arity (py "rea"))))
 '("all x (Real x -> all p RealLt 0 (abs x) p  -> ZeroApartAbs x)"
   "ZeroApartAbxIntro"))


(set-goal "all a abs a==a max ~a")
(cases)
(cases)
(assume "p" "q")
(use "Truth")
(assume "p")
(use "Truth")
(assume "p" "q")
(use "Truth")
;; Proof finished.
(save "RatAbsMaxAux")


(set-goal "all a (a*a==abs(a*a))")
(cases)
(cases)
(auto)
(save "SqEqvAbsSq")



      
(set-goal "all a,b abs(a*b)==abs a*abs b")
(cases)
(assume "k" "p")
(cases)
(assume "j" "q")
(ng)
(use "Truth")
;; Proof finished.
(save "RatAbsTimesAux")







(set-goal "(IntN 1#2**p)<=a+ ~b -> b<=a+(1#2**p)")
(assume "p" "a" "b")
(assume "Cond")
(simp "RatPlusComm")
(use "RatLePlusCancelL" (pt "(IntN 1#2**p)"))
(simp "RatPlusAssoc")
(simprat (pf "(IntN 1#2**p)+(1#2**p)==0"))
(use "RatLePlusCancelR" (pt "~b"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "(b+ ~b)==0"))
(ng #t)
(auto)
(save "RatLeEpsAux")


(set-goal "all x,y(Real x -> Real y -> x<<=y -> all p ex n1 all n(n1<=n -> x seq n <=y seq n+(1#2**p)))")
; (assume "x" "y" "Rx" "Ry")
; (assume "x<<=y")
(cases)
(assume "as" "M")
(cases)
(assume "bs" "N")
(assume "Rxx" "Ryy")
(assume "RealLeInst")
(assume "p")
(assert "RealNNeg(RealConstr bs N+ ~(RealConstr as M))")
(ng #t)
(use "RealConstrLeElim2")
(auto)
(assume "RealNNegInst")
(inst-with-to "RealNNegCharOne" (pt "(RealConstr bs N+ ~(RealConstr as M))seq") (pt "(RealConstr bs N+ ~(RealConstr as M))mod") "CharOneInst")
(ng "CharOneInst")
(assert "all p exl n all n0(n<=n0 -> (IntN 1#2**p)<=bs n0+ ~(as n0))")
(use "CharOneInst")
(ng "RealNNegInst")
(use "RealNNegInst")
(assume "Assertion")
(inst-with-to "Assertion" (pt "p") "InstAssertion")
(by-assume "InstAssertion" "n1" "NProp")
(inst-with-to "NProp" (pt "n") "NpropInst")
(ex-intro (pt "n1"))
(assume "n" "n1<=n")
(ng #t) 
(use "RatLePlusCancelR" (pt "(IntN 1#2**p)"))
(ng #t)
(use "RatLeEpsAux")
(use "NpropInst")
(auto)
(save "RealLeSeqAux")

(set-goal "all x,y,p(Real x -> Real y -> Cont f -> all n f doml<=x seq n-> all n x seq n<=f domr->
    all n f doml<=y seq n-> all n y seq n<=f domr-> One < f uModCont p->
     abs(x+ ~y)<<= (1#2**f uModCont p) -> abs((f x) + ~ (f y))<<=1#2**p)")
(assume "f" "x" "y" "p" "Rx" "Ry" "Cf" "umodcond")
(assume "domlxc" "domrxc" "domlyc" "modcontL" "umodcond2")
(assert "ex n all n0(n<=n0 -> (abs(x+ ~y))seq n0<=(1#2**f uModCont p) seq n0+(1#2**f uModCont p))")
(use "RealLeSeqAux")
(autoreal)
(auto)
(assume "ExProp")
(by-assume "ExProp" "n1" "ExInst")
(auto)
(use "RealSeqLeToLe" (pt "n1 max f uMod p"))
(use "RealAbsReal")
(use "RealPlusReal")
(use "ContAppRealOne")
(auto)
(use "RealUMinusReal")
(use "ContAppRealOne")
(auto)
(realproof)
(assume "n" "f uMod p")
(ng #t)
(use "ContElim2")
(auto)
(ng #t)
(use "NatLeTrans" (pt "n1 max f uMod p"))
(use "NatMaxUB2")
(auto)
(use "RatLeTrans" (pt "(abs(x+ ~y))seq n"))
(use "RatLeRefl")
(assert "all x,y (abs(x seq n+ ~(y seq n))==(abs(x+ ~y))seq n)")
(cases)
(assume "as" "M")
(cases)
(assume "bs" "N")
(ng #t)
(auto)
(ng #t)
(simprat (pf "(1#2**PosPred(f uModCont p))==(1#2**f uModCont p)seq n+(1#2**f uModCont p)"))
(use "ExInst")
(use "NatLeTrans" (pt "n1 max f uMod p"))
(use "NatMaxUB1")
(auto)
(inst-with-to "RatPlusHalfExpPosS" (pt "PosPred(f uModCont p)") "Inst")
(simprat "<-" "Inst")
(simp (pf "PosS(PosPred(f uModCont p))=f uModCont p"))
(auto)
(use "PosSPosPredId")
(auto)
(save "ContMod")



(set-goal "all x,y,p(Real x -> Real y -> Cont f -> all n f doml<=x seq n-> all n x seq n<=f domr->
    all n f doml<=y seq n-> all n y seq n<=f domr-> 
      1#2**p <<= abs((f x) + ~ (f y)) -> (1#2**f uModCont (PosS(PosS(p))) <<= abs(x+ ~y)))")
(assume "f" "x" "y" "p" "Rx" "Ry" "Cf" "umodcond")
(assume "domlxc" "domrxc" "domlyc"  "umodcond2")
;;(use "RealLeChar2RealConstrFree")
;;(autoreal)
(inst-with-to "RealLeCharOneRealConstrFree" (pt "ReaRat((1#2**p))") (pt "abs(f x+ ~(f y))") "Inst2")
(use "RealLeChar2RealConstrFree")
(autoreal)
(assume "p0")
(cut "all p0 exl n all n0(n<=n0 -> (1#2**p)<=abs(f approx(x seq n0)n0+ ~(f approx(y seq n0)n0))+(1#2**p0))")
(assume "cutInst1")
(inst-with-to "cutInst1" (pt "PosS p") "cutExInst")
(by-assume "cutExInst" "n0" "cutInstExSpec")
(intro 0 (pt "n0 max f uMod(PosS(PosS p))"))
(assume "n" "n<=n0")
(simp (pf "(abs(x+ ~y))seq n eqd (abs(x seq n+ ~(y seq n)))"))
(use "RatLeTrans" (pt "abs(x seq n+ ~(y seq n))"))
(use "RatLtToLe")
(cut "(1#2**PosS(PosS(p)))<abs(f approx(x seq n)n+ ~(f approx(y seq n)n))")
(use "ImplicationNegPvar")
(assume "Cond")
(use "RatLeToNotLt")
(use "ContElim2")
(use "Cf")
(auto)
(use "NatLeTrans" (pt "n0 max (f uMod (PosS(PosS p)))"))
(use "NatMaxUB2")
(auto)
(cut "abs(x seq n-y seq n)<=1/2**(f uModCont(PosS(PosS p)))")
(assume "cutT")
(use "RatLeTrans" (pt "1/2**f uModCont(PosS(PosS p))"))
(auto)
(ng #t)
(use "PosExpLeMon")
(use "Truth")
(use "RatNotLtToLe")
(auto)
(inst-with-to "cutInstExSpec" (pt "n") "cutInstSpec")
(cut "(1#2**p)<=abs(f approx(x seq n)n+ ~(f approx(y seq n)n))+(1#2**PosS p)")
(assume "cutT")
(use "RatLtLeTrans" (pt "(1#2**PosS(p))"))
(ng #t)
(use "PosExpLtMon")
(auto)
(simprat (pf "(1#2**PosS p)==(1#2**p) + ~(1#2**PosS p)"))
(use "RatLePlusCancelR" (pt "1#2**PosS p"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "~(1#2**PosS p)+(1#2**PosS p)==0"))
(use "cutT")
(auto)
(use "RatEqvPlusCancelR" (pt "1#2**PosS p"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "~(1#2**PosS p)+(1#2**PosS p)==0"))
(simprat "RatPlusHalfExpPosS")
(auto)
(use "cutInstSpec")
(use "NatLeTrans" (pt "n0 max f uMod(PosS(PosS p))"))
(use "NatMaxUB1")
(auto)
(assert "all x,y (abs(x+ ~y))seq n eqd abs(x seq n+ ~(y seq n))")
(cases)
(assume "as" "M")
(cases)
(assume "as0" "M0")
(ng #t)
(use "InitEqD")
(auto)
(use "Inst2")
(ng #t)
(auto)
(save "ContModLeRev")

