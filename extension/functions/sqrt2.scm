
(display "loading sqrt2.scm ...") (newline)


;; Sqrt

(add-program-constant "sqrtmap" (py "rat=>nat=>rat"))
(animate "RatLeAbsBoundPos")
(add-computation-rules "sqrtmap a Zero" "(1#1)"
"sqrtmap a (Succ n)" "((sqrtmap a n) + a/(sqrtmap a n))/2"
)

(set-totality-goal "sqrtmap")
(use "AllTotalElim")
(assume "a")
(use "AllTotalElim")
(ind)
(ng #t)
(use "RatTotalVar")
(assume "n" "Ih")
(ng #t)
(use "RatTimesTotal")
(use "RatPlusTotal")
(auto)
(use "RatTimesTotal")
(use "RatTotalVar")
(use "RatUDivTotal")
(auto)
(use "RatTotalVar")
(save-totality)


(set-goal "all a (0<a ->  all n 0<sqrtmap a n)")
(assume "a" "0<a")
(ind)
(ng #t)
(auto)
(assume "n" "Ih")
(ng #t)
(use "RatLtTimesCancelR" (pt "2#1"))
(auto)
(ng #t)
(simp "<-" "RatTimesAssoc")
(simprat (pf "(1#2)*2==1"))
(ng #t)
(use "RatLtTrans" (pt "sqrtmap a n"))
(auto)
(use "RatLtPlusCancelL" (pt "~(sqrtmap a n)"))
(ng #t)
(simprat (pf "~(sqrtmap a n)+sqrtmap a n==0"))
(ng #t)
(use "RatLtTimesCancelL" (pt "1/a"))
(ng #t)
(use "RatLtToLe")
(use "ZeroLtToZeroLtRatUDiv")
(auto)
(ng #t)
(simprat (pf "RatUDiv a*a==1"))
(ng #t)
(simprat (pf "RatUDiv a*0==0"))
(use "ZeroLtToZeroLtRatUDiv")
(auto)
(simp "RatTimesComm")
(use "RatTimesUDivR")
(use "RatLtLeTrans" (pt "a"))
(auto)
(save "ZeroLtSqrtSeqn")



(set-goal "all a,n(0<a -> a<= (sqrtmap a (Succ n))**2)")
(assume "a" "n")
(assume "0<a")
(ng #t)
(simprat "RatExpTwoRewRule1")
(ng #t)
(simp "RatTimesComm")
(ng #t)
(inst-with-to "RatExpPosS" (pt "sqrtmap a n+a*RatUDiv(sqrtmap a n)") (pt "1") "RatInst4")
(simprat "RatInst4")
(ng #t)
(simp "<-" "RatTimesAssoc")
(simprat (pf "(sqrtmap a n+a*RatUDiv(sqrtmap a n))**1==(sqrtmap a n+a*RatUDiv(sqrtmap a n))"))
(simprat "RatBinomForm1")
(simprat "RatTimesPlusDistr")
(simprat "RatTimesPlusDistr")
(simprat (pf "2*sqrtmap a n*(a*RatUDiv(sqrtmap a n))==2*a"))
(use "RatLePlusCancelL" (pt "~a"))
(ng #t)
(simprat (pf "~a+a==0"))
(ng #t)
(simprat (pf "~a+(1#4)*sqrtmap a n**2+(1#2)*a+(1#4)*(a*RatUDiv(sqrtmap a n))**2==(1#4)*sqrtmap a n**2+(1#2)*a+ ~a+(1#4)*(a*RatUDiv(sqrtmap a n))**2"))
(simp "RatPlusComm")
(ng #t)
(simp "<-" "RatPlusAssoc")
(simprat (pf "(1#2)*a+ ~a==  (1#4)*(~(2*a))"))
(simprat "<-" "RatTimesPlusDistr")
(simprat "<-" "RatTimesPlusDistr")
(ng #t)
(simprat (pf "(a*RatUDiv(sqrtmap a n))**2+sqrtmap a n**2+ ~(2*a)==(a*RatUDiv(sqrtmap a n))**2 + ~(2*a)+sqrtmap a n**2"))
(inst-with-to "RatBinomForm2" (pt "a*RatUDiv(sqrtmap a n)") (pt "sqrtmap a n") "BinomInst")
(simprat (pf "(a*RatUDiv(sqrtmap a n))**2+ ~(2*a)+sqrtmap a n**2==(a*RatUDiv(sqrtmap a n))**2-2*(a*RatUDiv(sqrtmap a n))*sqrtmap a n+sqrtmap a n**2"))
(simprat "<-" "BinomInst")
(ng #t)
(use "RatLeTimesCancelL" (pt "4#1"))
(auto)
(ng #t)
(simp "<-" "RatTimesAssoc")
(simprat (pf "RatUDiv(sqrtmap a n)*sqrtmap a n==1"))
(auto)
(simp "RatTimesComm")
(use "RatTimesUDivR")
(use "RatLtLeTrans" (pt "sqrtmap a n"))
(use "ZeroLtSqrtSeqn")
(auto)
(ng #t)
(simp "RatPlusComm")
(ng #t)
(simp "RatPlusComm")
(ng #t)
(auto)
(ng #t)
(simprat (pf "~a==(~1)*a"))
(simprat "<-" "RatTimesPlusDistrLeft")
(ng #t)
(auto)
(ng #t)
(simp "<-" "RatPlusAssoc")
(simp "RatPlusComm")
(ng #t)
(auto)
(ng #t)
(use "RatEqvTimesCancelL" (pt "(1#2)"))
(auto)
(ng #t)
(simp "RatTimesComm")
(ng #t)
(simprat (pf "RatUDiv(sqrtmap a n)*sqrtmap a n==1"))
(auto)
(simp "RatTimesComm")
(use "RatTimesUDivR")
(use "RatLtLeTrans" (pt "sqrtmap a n"))
(use "ZeroLtSqrtSeqn")
(auto)
(save "SqrtSeqSqrAux")



(set-goal "all a,n(0<a -> sqrtmap a (Succ(Succ n)) <= sqrtmap a (Succ n))")
(assume "a")
(assume "n")
(assume "cond")
(use "RatLePlusCancelR" (pt "~(sqrtmap a(Succ(Succ n)))"))
(simprat (pf "sqrtmap a(Succ(Succ n))+ ~(sqrtmap a(Succ(Succ n)))==0"))
(simp (pf "sqrtmap a(Succ(Succ n))=(sqrtmap a(Succ n)+a/sqrtmap a(Succ n))/2"))
(simp "RatDiv0CompRule")
(simprat "RatTimesPlusDistrLeft")
(simp "RatDiv0CompRule")
(simprat (pf "sqrtmap a(Succ n)+ ~(sqrtmap a(Succ n)*RatUDiv 2+a*RatUDiv(sqrtmap a(Succ n))*RatUDiv 2)==sqrtmap a(Succ n) + ~(sqrtmap a(Succ n)*RatUDiv 2) + ~(a*RatUDiv(sqrtmap a(Succ n))*RatUDiv 2)"))
(simprat (pf "sqrtmap a(Succ n)+ ~(sqrtmap a(Succ n)*RatUDiv 2)==sqrtmap a(Succ n)*RatUDiv 2"))
(simprat (pf "~(a*RatUDiv(sqrtmap a(Succ n))*RatUDiv 2)== ~(a*RatUDiv(sqrtmap a(Succ n)))*RatUDiv 2"))
(simprat "<-" "RatTimesPlusDistrLeft")
(use "RatLeTrans" (pt "(sqrtmap a(Succ n)*sqrtmap a(Succ n)*RatUDiv(sqrtmap a(Succ n))+ ~(a)*RatUDiv(sqrtmap a(Succ n)))*RatUDiv 2"))
(simprat "<-" "RatTimesPlusDistrLeft")
(simprat (pf "0==0*0"))
(inst-with-to "RatLeMonTimesTwo" (pt "0#1") (pt "(sqrtmap a(Succ n)*sqrtmap a(Succ n)+ ~a)") (pt "0#1") (pt "RatUDiv(sqrtmap a(Succ n))*RatUDiv 2") "RatInst")
(use "RatInst")
(auto)
(use "RatLePlusCancelR" (pt "a"))
(simprat (pf "0+a==a"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "~a+a==0"))
(simprat (pf "sqrtmap a(Succ n)*sqrtmap a(Succ n)+0==sqrtmap a(Succ n)*sqrtmap a(Succ n)"))
(simprat (pf "sqrtmap a(Succ n)*sqrtmap a(Succ n)==sqrtmap a(Succ n)**2"))
(use "SqrtSeqSqrAux")
(auto)
(inst-with-to "RatExpPosS" (pt "sqrtmap a(Succ n)") (pt "1") "RatInst2")
(use "RatEqvSym")
(auto)
(simprat  "RatExpTwoE")
(auto)
(use "RatLeTrans" (pt "(0#1)*(0#1)"))
(auto)
(use "RatLeMonTimesTwo")
(auto)
(use "RatLtToLe")
(use "ZeroLtToZeroLtRatUDiv")
(use "ZeroLtSqrtSeqn")
(auto)
(ng #t)
(simprat (pf "sqrtmap a(Succ n)*sqrtmap a(Succ n)*RatUDiv(sqrtmap a(Succ n))==sqrtmap a(Succ n)"))
(ng #t)
(auto)
(simp "<-" "RatTimesAssoc")
(simprat (pf "sqrtmap a(Succ n)*RatUDiv(sqrtmap a(Succ n))==1"))
(auto)
(use "RatTimesUDivR")
(use "RatLtLeTrans" (pt "sqrtmap a(Succ n)"))
(use "ZeroLtSqrtSeqn")
(auto)
(simprat (pf "sqrtmap a(Succ n)+ ~(sqrtmap a(Succ n)*RatUDiv 2)==sqrtmap a(Succ n)*(1)+sqrtmap a(Succ n)*(~1)*RatUDiv 2"))
(simp "<-" "RatTimesAssoc")
(simprat "<-" "RatTimesPlusDistr")
(ng #t)
(auto)
(save "SqrtSeqMonDecr")

(add-program-constant "sqrtmapaux" (py "rat=>nat=>rat"))
(add-computation-rule  "sqrtmapaux a n" "a/(sqrtmap a n)")
(set-totality-goal "sqrtmapaux")
(use "AllTotalElim")
(assume "a")
(use "AllTotalElim")
(assume "n")
(use "RatTotalVar")
(save-totality)



(set-goal "all a,n,m ( 0<a -> m<=n -> sqrtmap a(Succ n)<=sqrtmap a(Succ m))")
(assume "a")
(ind)
(assume "m0" "0<a" "m0")
(simp "m0")
(auto)
(assume "n0" "Ih")
(assume "m0" "0<a" "msuccn")
(use "NatLeCases" (pt "m0") (pt "Succ n0"))
(auto)
(assume "m0succn")
(ng "m0succn")
(use "RatLeTrans" (pt "sqrtmap a((Succ n0))"))
(use "SqrtSeqMonDecr")
(auto)
(assume "m0=Succ n0")
(simp "m0=Succ n0")
(auto)
(save "SqrtSeqMonDecr2")




(set-goal "all a,n,m(0<a -> m<= n -> sqrtmapaux a (Succ n) <= sqrtmap a (Succ m))")
(assume "a" "n" "m")
(assume "0<a" "m<=n")
(use "RatLeTrans" (pt "sqrtmap a(Succ n)"))
(inst-with-to "SqrtSeqSqrAux" (pt "a") "SqrtSeqInst1")
(use "RatLeTimesCancelR" (pt "sqrtmap a(Succ n)"))
(inst-with-to "ZeroLtSqrtSeqn" (pt "a")  "ZeroLtInst")
(assert "all n 0<sqrtmap a n")
(auto)
(assume "ZeroLtInst2")
(inst-with-to "ZeroLtInst2" (pt "Succ n") "ZeroLtInst3")
(auto)
(simprat (pf "sqrtmap a(Succ n)*sqrtmap a(Succ n)==sqrtmap a(Succ n)**2"))
(use "RatLeTrans" (pt "a"))
(simp "sqrtmapaux0CompRule")
(simp "RatDiv0CompRule")
(simp "<-" "RatTimesAssoc")
(simprat (pf "RatUDiv(sqrtmap a(Succ n))*sqrtmap a(Succ n)==1"))
(auto)
(simp "RatTimesComm")
(use "RatTimesUDivR")
(use "RatLtLeTrans" (pt "sqrtmap a(Succ n)"))
(use "ZeroLtSqrtSeqn")
(auto)
(inst-with-to "RatExpPosS" (pt "sqrtmap a(Succ n)") (pt "1") "RatInst") 
(use "RatExpTwoE")
(auto)
(use "SqrtSeqMonDecr2")
(auto)
(save "bn2Lean2")

(set-goal "all a,n,m(0<a -> sqrtmapaux a (Succ n) <= sqrtmap a (Succ m))")
(assume "a")
(assume "n" "m")
(assume "cond")
(cases (pt "m<=n"))
(assume "case")
(use "bn2Lean2")
(auto)
(assume "m<=n-> F")
(assert "n<m")
(use "NatNotLeToLt")
(auto)
(assume "n<m")
(assert "all n,m (n<=m -> sqrtmapaux a(Succ n)<=sqrtmap a(Succ m))")
(assume "n0" "m0" "n<=m")
(simp "sqrtmapaux0CompRule")
(simp "RatDiv0CompRule")
(use "RatLeTimesCancelR" (pt "(sqrtmap a(Succ n0))"))
(use "ZeroLtSqrtSeqn")
(auto)
(simp "<-" "RatTimesAssoc")
(simprat (pf "(RatUDiv(sqrtmap a(Succ n0))*sqrtmap a(Succ n0))==1"))
(use "RatLeTrans" (pt "sqrtmap a(Succ m0)*sqrtmap a(Succ m0)"))
(simprat (pf "sqrtmap a(Succ m0)*sqrtmap a(Succ m0)==sqrtmap a(Succ m0)**2"))
(use "SqrtSeqSqrAux")
(auto)
(use "RatExpTwoE")
(auto)
(use "RatLeMonTimesTwo")
(use "RatLtToLe")
(use "ZeroLtSqrtSeqn")
(auto)
(use "RatLtToLe")
(use "ZeroLtSqrtSeqn")
(auto)
(use "SqrtSeqMonDecr2")
(auto)
(simp "RatTimesComm")
(use "RatTimesUDivR")
(use "RatLtLeTrans" (pt "sqrtmap a(Succ n0)") )
(use "ZeroLtSqrtSeqn")
(auto)
(assume "Assertion")
(use "Assertion")
(use "NatLtToLe")
(auto)
(save "bn2Lean2all")

(set-goal "all a,n,m ( 0<a -> m<=n -> sqrtmapaux a(Succ m)<=sqrtmapaux a(Succ n))")
(assume "a")
(ind)
(assume "m0" "0<a" "m0")
(simp "m0")
(auto)
(assume "n0" "Ih")
(assume "m0" "0<a" "msuccn")
(use "NatLeCases" (pt "m0") (pt "Succ n0"))
(auto)
(assume "m0succn")
(ng "m0succn")
(use "RatLeTrans" (pt "sqrtmapaux a((Succ n0))"))
(use "Ih")
(auto)
(simp "sqrtmapaux0CompRule")
(simp "sqrtmapaux0CompRule")
(simp "RatDiv0CompRule")
(simp "RatDiv0CompRule")
(simp "RatTimesComm")
(use "RatLeTrans" (pt "RatUDiv(sqrtmap a(Succ(Succ n0)))*a"))
(use "RatLeMonTimes")
(use "RatLtToLe")
(auto)
(use "RatLeUDiv")
(use "ZeroLtSqrtSeqn")
(auto)
(use "SqrtSeqMonDecr")
(auto)
(simp "RatTimesComm")
(auto)
(assume "m0=Succ n0")
(simp "m0=Succ n0")
(auto)
(save "SqrtAuxSeqMonInc2")


(set-goal "all a,n (0<a -> sqrtmap a (Succ n) - sqrtmapaux a (Succ n)<=(1#2**n)*(sqrtmap a (Succ Zero) + ~(sqrtmapaux a (Succ Zero))))")
(assume "a")
(ind)
(assume "0<a")
(ng #t)
(auto)
(assume "n" "Ih")
(assume "0<a")
(use "RatLeTrans" (pt "sqrtmap a(Succ(Succ n))-sqrtmapaux a((Succ n))"))
(simp "RatMinus0CompRule")
(simp "RatMinus0CompRule")
(use "RatLePlusCancelL" (pt "~(sqrtmap a(Succ(Succ n)))"))
(simp "RatPlusAssoc")
(simprat (pf "~(sqrtmap a(Succ(Succ n)))+(sqrtmap a(Succ(Succ n)))==0")) 
(simp "RatPlusAssoc")
(simprat (pf "~(sqrtmap a(Succ(Succ n)))+(sqrtmap a(Succ(Succ n)))==0")) 
(simprat (pf "0+ ~(sqrtmapaux a(Succ(Succ n)))== ~(sqrtmapaux a(Succ(Succ n)))"))
(simprat (pf "0+ ~(sqrtmapaux a(Succ n))== ~(sqrtmapaux a(Succ n))"))
(simp "RatLeNegToPos")
(simp "sqrtmapaux0CompRule")
(simp "sqrtmapaux0CompRule")
(simp "RatDiv0CompRule")
(simp "RatDiv0CompRule")
(use "RatLeMonTimesTwo")
(use "RatLtToLe")
(auto)
(use "RatLtToLe")
(use "ZeroLtToZeroLtRatUDiv")
(use "ZeroLtSqrtSeqn")
(auto)
(use "RatLeUDiv")
(use "ZeroLtSqrtSeqn")
(auto)
(use "SqrtSeqMonDecr")
(auto)
(simp "sqrtmap1CompRule")
(simp "RatDiv0CompRule")
(simprat "RatTimesPlusDistrLeft")
(simp "<-" "sqrtmapaux0CompRule")
(simp "RatMinus0CompRule")
;;(simprat (pf "(sqrtmap a(Succ n)+sqrtmapaux a(Succ n))*RatUDiv 2== (sqrtmap a(Succ n)*RatUDiv 2+sqrtmapaux a(Succ n)*RatUDiv 2)")) 
(simp "<-" "RatPlusAssoc")
(simprat (pf "sqrtmapaux a(Succ n)*RatUDiv 2+ ~(sqrtmapaux a(Succ n))== ~(sqrtmapaux a(Succ n))*RatUDiv 2"))
(use "RatLeTrans" (pt "(sqrtmap a(Succ Zero)+ ~(sqrtmapaux a(Succ Zero)))*(1#2**Succ n)"))
(use "RatLeTimesCancelR" (pt "2#1"))
(auto)
(simprat "<-" "RatTimesPlusDistrLeft")
(simp "<-" "RatTimesAssoc")
(simprat (pf "RatUDiv 2*2==1"))
(use "RatLeTrans" (pt "(sqrtmap a(Succ Zero)+ ~(sqrtmapaux a(Succ Zero)))*(1#2**n)"))
(simprat (pf "(sqrtmap a(Succ n)+ ~(sqrtmapaux a(Succ n)))*1==(sqrtmap a(Succ n)+ ~(sqrtmapaux a(Succ n)))"))
(simp "RatTimesComm")
(use "Ih")
(auto)
(simp "<-" "RatTimesAssoc")
(use "RatLeMonTimesTwo")
(use "RatLePlusCancelR" (pt "sqrtmapaux a(Succ Zero)"))
(simprat (pf "0+sqrtmapaux a(Succ Zero)==sqrtmapaux a(Succ Zero)"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "~(sqrtmapaux a(Succ Zero))+sqrtmapaux a(Succ Zero)==0"))
(simprat (pf "sqrtmap a(Succ Zero)+0==sqrtmap a(Succ Zero)"))
(use "bn2Lean2")
(auto)
(simp "RatTimesComm")
(auto)
(simprat (pf "~(sqrtmapaux a(Succ n))==sqrtmapaux a(Succ n)*(~1)"))
(simprat "<-" "RatTimesPlusDistr")
(auto)
(save "SqrtCauchyAux")

;;(pp (nt (pt "sqrtmap 4 (Succ Zero) + ~(sqrtmapaux 4 (Succ Zero))")))
;;(pp (nt (pt "sqrtmap 4 (Succ Zero) + ~(sqrtmapaux 4 (Succ Zero))")))

;;(bitwise-arithmetic-shift 7 -8)

(set-goal "all a (0<a ->  exl M Cauchy (sqrtmap a )  (M))")
(assume "a")
(assume "cond")
(intro 0 (pt "[p] Succ(cNatPos(p) + cRatLeAbsBound(sqrtmap a (Succ Zero) + ~(sqrtmapaux a (Succ Zero))) )"))
(use "CauchyIntro")
(assume "p")
(cases)
(cases)
(ng)
(auto)
(assume "m")
(ng #t)
(use "Efq")
(assume "n")
(cases)
(ng #t)
(assume "cond1")
(use "Efq")
(assume "m" "cond1" "cond2") 
(cut "all n,m(n<=m -> cNatPos(PosToNat p)+ cRatLeAbsBound((1+a)*(1#2)+ ~(a*RatUDiv((1+a)*(1#2))))<=n -> cNatPos(PosToNat p)+ cRatLeAbsBound((1+a)*(1#2)+ ~(a*RatUDiv((1+a)*(1#2))))<= m-> sqrtmap a(Succ n)+ ~(sqrtmap a(Succ m))<=(1#2**p))")
(assume "cutInst")
(cases (pt "n<=m"))
(assume "case1")
(use "RatLeTrans" (pt "sqrtmap a(Succ n)+ ~(sqrtmap a(Succ m))"))
(simp "RatAbsId")
(auto)
(use "RatLePlusCancelR" (pt "(sqrtmap a(Succ m))"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "(~(sqrtmap a(Succ m))+sqrtmap a(Succ m))==0"))
(use "SqrtSeqMonDecr2")
(use "cond")
(auto)
(assume "n<=m-F")
(simprat "RatAbsId3")
(use "cutInst")
(assert "m<n")
(use "NatNotLeToLt")
(auto)
(assume "m<n")
(use "NatLtToLe")
(auto)
(use "SqrtSeqMonDecr2")
(auto)
(use "NatLtToLe")
(use "NatNotLeToLt")
(auto)
(assume "n0" "m0")
(assume "n<=m")
(assume "cond11" "cond22")
(use "RatLeTrans" (pt "sqrtmap a(Succ n0)+ ~(sqrtmapaux a(Succ n0))"))
(use "RatLeMonPlus")
(auto)
(simp "RatLeNegToPos")
(use "bn2Lean2all")
(auto)
(use "RatLeTrans" (pt "(1#2**n0)*(sqrtmap a (Succ Zero) + ~(sqrtmapaux a (Succ Zero)))"))
(use "SqrtCauchyAux")
(auto)
(use "RatLeTrans" (pt "((1#2**((cNatPos(PosToNat p))+(cRatLeAbsBound(sqrtmap a(Succ Zero)+ ~(sqrtmapaux a(Succ Zero))))))*(sqrtmap a(Succ Zero)+ ~(sqrtmapaux a(Succ Zero))))"))
(use "RatLeMonTimesTwo")
(auto)
(use "RatLePlusCancelR" (pt "(sqrtmapaux a(Succ Zero))"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "~(sqrtmapaux a(Succ Zero))+sqrtmapaux a(Succ Zero)==0"))
(simprat (pf "0+sqrtmapaux a(Succ Zero)==sqrtmapaux a(Succ Zero)"))
(simprat (pf "sqrtmap a(Succ Zero)+0==sqrtmap a(Succ Zero)"))
(use "bn2Lean2all")
(auto)
(use "NatExpLe")
(auto)
(simprat "<-" "NatExpPlus")
(use "RatLeTrans" (pt "(1#2**cNatPos(PosToNat p))*(1#2**cRatLeAbsBound(sqrtmap a(Succ Zero)+ ~(sqrtmapaux a(Succ Zero))))*abs(sqrtmap a(Succ Zero)+ ~(sqrtmapaux a(Succ Zero)))"))
(ng #t)
(auto)
(simp "<-" "RatTimesAssoc")
(simprat (pf "(1#2**p)==(1#2**p)*1"))
(use "RatLeMonTimesTwo")
(auto)
(assert "all a,n (0<= ((1#2**n)*abs(a)))")
(cases)
(assume "k" "p0")
(ind)
(ng #t)
(auto)
(simp "NatPosExFree")
(simp "NatToPosToNatId")
(auto)
(use "NatExpBound1")
(use "RatLeAbsBoundExFree")
(auto)
(save "SqrtCauchyModulus")

(add-sound "SqrtCauchyModulus")

;;(remove-theorem "SqrtCauchyModulus")

;;(deanimate "SqrtCauchyModulus")


(set-goal "all a (0<a ->  exnc M0 (M0 eqd (cSqrtCauchyModulus a) andnc Cauchy (sqrtmap a )  (M0)))")
(assume "a" "0<a")
(intro 0 (pt "cSqrtCauchyModulus a"))
(split)
(use "InitEqD")
(inst-with-to "SqrtCauchyModulusSound" "Pro")
(use-with "ExLTMRElim" (py "pos=>nat") (make-cterm (pv "M") (pf "Cauchy (sqrtmap a) M")) (pt "cSqrtCauchyModulus a") "?")
(use "SqrtCauchyModulusSound")
(auto)
(save "SqrtCauchyModulusSoundCorr")


;;  "SqrtCauchyModulusProp" 
(set-goal "all a (0<a ->  Cauchy (sqrtmap a )  (cSqrtCauchyModulus a))")
(assume "a" "0<a")
(inst-with-to "SqrtCauchyModulusSoundCorr" (pt "a") "Prop")
(cut "exnc M(M eqd cSqrtCauchyModulus a andnc Cauchy(sqrtmap a)M)")
(assume "CutInst")
(by-assume "CutInst" "M0" "CutInstProp")
(simp "<-" "CutInstProp")
(use "CutInstProp")
(use "Prop")
(use "0<a")
(save "SqrtCauchyModulusProp")


(animate "RatLeAbsBound")
(animate "RatLeBound")

(deanimate "RatLeAbsBound")

(set-goal "all a,n (1<=a -> sqrtmap a n <= a)")
(assume "a")
(ind)
(ng #t)
(auto)
(cases)
(assume "Ih")
(assume "1<=a")
(ng #t)
(use "RatLeTimesCancelR" (pt "2#1"))
(auto)
(simp "<-" "RatTimesAssoc")
(simprat (pf "(1#2)*2==1"))
(ng #t)
(use "RatLeTrans" (pt "a+a"))
(use "RatLeMonPlus")
(auto)
(simprat "RatPlusIdEqvTimesTwo")
(simp "RatTimesComm")
(auto)
(assume "n" "Ih")
(assume "1<=a")
(use "RatLeTrans" (pt "sqrtmap a(Succ n)"))
(use "SqrtSeqMonDecr")
(use "RatLtLeTrans" (pt "1#1"))
(auto)
(save "SqrtSeqBoundOneLeft")


(set-goal "all a,n (0<a -> a<= 1 -> sqrtmap a n<= 1)")
(assume "a")
(ind)
(ng #t)
(auto)
(cases)
(ng #t)
(assume "Ih")
(assume "0<a" "a<= 1")
(use "RatLeTimesCancelR" (pt "2#1"))
(auto)
(simp "<-" "RatTimesAssoc")
(simprat (pf "((1#2)*2)==1"))
(ng #t)
(use "RatLeTrans" (pt "(1#1)+(1#1)"))
(use "RatLeMonPlus")
(auto)
(assume "n" "Ih")
(assume "0<a" "a<=1")
(use "RatLeTrans" (pt "sqrtmap a(Succ n)"))
(use "SqrtSeqMonDecr")
(auto)
(save "SqrtSeqBoundOneRight1")


(set-goal "all a,n (0<a -> a<=1 ->  a<= sqrtmap a n)")
(assume "a")
(ind)
(assume "0<a" "a<=1")
(ng #t)
(auto)
(assume "n")
(assume "Ih")
(assume "0<a" "a<=1")
(ng #t)
(use "RatLeTimesCancelR" (pt "2#1"))
(auto)
(simp "<-" "RatTimesAssoc")
(simprat (pf "(1#2)*(2)==1"))
(ng #t)
(use "RatLeTrans" (pt "a+a"))
(simp "RatTimesComm")
(simprat "<-" "RatPlusIdEqvTimesTwo")
(use "RatLeMonPlus")
(auto)
(use "RatLeMonPlus")
(auto)
(use "RatLeTimesCancelL" (pt "RatUDiv a"))
(use "RatUDivPosToRatPostwo")
(auto)
(ng #t)
(simprat (pf "RatUDiv a*a==1"))
(ng #t)
(use "RatLeTimesCancelR" (pt "sqrtmap a n"))
(use "ZeroLtSqrtSeqn")
(auto)
(ng #t)
(simprat (pf "RatUDiv(sqrtmap a n)*sqrtmap a n==1"))
(ng #t)
(use "SqrtSeqBoundOneRight1")
(auto)
(simp "RatTimesComm")
(use "RatTimesUDivR")
(use "RatLtLeTrans" (pt "sqrtmap a n"))
(use "ZeroLtSqrtSeqn")
(auto)
(simp "RatTimesComm")
(use "RatTimesUDivR")
(use "RatLtLeTrans" (pt "a"))
(auto)
(save "SqrtSeqBoundOneRight2")

(set-goal "all a,n (1<=a -> 1<=sqrtmap a n)")
(assume "a")
(ind)
(ng #t)
(auto)
(assume "n" "Ih")
(assume "cond")
(simp "sqrtmap1CompRule")
(ng #t)
(use "RatLeTimesCancelR" (pt "2#1"))
(auto)
(ng #t)
(simp "<-" "RatTimesAssoc")
(simprat (pf "((1#2)*2)==1"))
(ng #t)
(use "RatLeTrans" (pt "(1#1) + 1"))
(ng #t)
(auto)
(use "RatLeMonPlus")
(auto)
(use "RatLeTimesCancelR" (pt "sqrtmap a n"))
(use "ZeroLtSqrtSeqn")
(use "RatLtLeTrans" (pt "1#1"))
(auto)
(ng #t)
(simp "<-" "RatTimesAssoc")
(simprat (pf "(RatUDiv(sqrtmap a n)*sqrtmap a n)==1"))
(ng #t)
(use "SqrtSeqBoundOneLeft")
(auto)
(simp "RatTimesComm")
(use "RatTimesUDivR")
(use "RatLtLeTrans" (pt "1#1"))
(auto)
(use "RatLeTrans" (pt "sqrtmap a n"))
(auto)
(save "SqrtSeqBoundOneLeft2")



(set-goal "all a,c (0<a -> 0<c -> c<=a -> all n c min (1#1) <= sqrtmap a n)")
(assume "a" "c")
(assume "0<a" "0<c" "c<=a")
(ind)
(ng #t)
(use "RatMinLB2")
(assume "n" "Ih")
(cases (pt "1<a"))
(simp "sqrtmap1CompRule")
(assume "case")
(simp "RatDiv0CompRule")
(use "RatLeTimesCancelR" (pt "2#1"))
(auto)
(simp "<-" "RatTimesAssoc")
(simprat (pf "(RatUDiv 2*2)==1"))
(ng #t)
(simp "RatDiv0CompRule")
(use "RatLeTrans" (pt "c min 1+c min 1"))
(simp "RatTimesComm")
(simprat "RatPlusIdEqvTimesTwo")
(auto)
(use "RatLeMonPlus")
(auto)
(use "RatLeTrans" (pt "1#1"))
(use "RatMinLB2")
(use "RatLeTimesCancelR" (pt "sqrtmap a n"))
(use "ZeroLtSqrtSeqn")
(auto)
(simp "<-" "RatTimesAssoc")
(simprat (pf "RatUDiv(sqrtmap a n)*sqrtmap a n==1"))
(ng #t)
(use "SqrtSeqBoundOneLeft")
(use "RatLtToLe")
(auto)
(simp "RatTimesComm")
(use "RatTimesUDivR")
(use "RatLtLeTrans" (pt "sqrtmap a n"))
(use "ZeroLtSqrtSeqn")
(auto)
(assume "case2")
(assert "a<=1")
(use "RatNotLtToLe")
(auto)
(assume "a<=1")
(simp "sqrtmap1CompRule")
(ng #t)
(use "RatLeTimesCancelR" (pt "2#1"))
(auto)
(simp "<-" "RatTimesAssoc")
(simprat (pf "((1#2)*2)==1"))
(ng #t)
(use "RatLeTrans" (pt "c min 1 + c min 1"))
(simprat "RatPlusIdEqvTimesTwo")
(simp "RatTimesComm")
(auto)
(use "RatLeMonPlus")
(auto)
(use "RatLeTrans" (pt "c"))
(use "RatMinLB1")
(use "RatLeTimesCancelR" (pt "sqrtmap a n"))
(use "ZeroLtSqrtSeqn")
(auto)
(simp "<-" "RatTimesAssoc")
(simprat (pf "RatUDiv(sqrtmap a n)*sqrtmap a n==1"))
(use "RatLeMonTimesTwo")
(use "RatLtToLe")
(auto)
(use "RatLtToLe")
(use "ZeroLtSqrtSeqn")
(auto)
(use "SqrtSeqBoundOneRight1")
(auto)
(simp "RatTimesComm")
(use "RatTimesUDivR")
(use "RatLtLeTrans" (pt "sqrtmap a n"))
(use "ZeroLtSqrtSeqn")
(auto)
(save "SqrtSeqLeftB")


(animate "RatToPosZeroLB")


(set-goal "all a (0<a -> (1#2**cRatToPosZeroLB(a))<= a)")
(cases)
(cases)
(ng #t)
(cases)
(cases)
(ng #t)
(auto)
(assume "p")
(assume "T")
(ng #t)
(use "SZeroPosLePosExp")
(assume "p")
(assume "T")
(ng #t)
(inst-with-to "SZeroPosLePosExp" (pt "SOne p") "Inst")
(ng "Inst")
(auto)
(ng #t)
(assume "p" "p0" "T")
(use "PosLeTrans" (pt "2**p0"))
(use "PosLtToLe")
(ng #t)
(auto)
(use "PosLeTrans" (pt "p*2**p0"))
(use "PosLeTrans" (pt "One*2**p0"))
(use "Truth")
(use "PosLeMonTimes")
(use "Truth")
(use "Truth")
(use "Truth")
(assume "p" "p0")
(assume "T")
(ng #t)
(use "PosLeTrans" (pt "2**p0"))
(use "PosLtToLe")
(use "Truth")
(use "Truth")
(assume "p")
(ng #t)
(use "Efq")
(assume "p")
(assume "p0")
(ng #t)
(use "Efq")
(save "RatToPosZeroLBExFree")






(deanimate "NatPos")
(deanimate "RatLeAbsBound")
(deanimate "RatLeAbsBoundSeq")
(deanimate "RealBound")

(set-goal "all a ( 0<a -> Real (RealConstr (sqrtmap a) (cSqrtCauchyModulus a)))")
(assume "a")
(assume "cond")
(use "RealIntro")
(use "CauchyIntro")
(ng #t)
(assume "p" "n0" "m0")
(assume "cond1" "cond2")
(ng #t)
(use "CauchyElim" (pt "cSqrtCauchyModulus a"))
(use "SqrtCauchyModulusProp")
(auto)
(use "MonIntro")
(ng #t)
(assume "p" "q")
(simp "NatPosExFree")
(simp "NatPosExFree")
(simp "NatToPosToNatId")
(simp "NatToPosToNatId")
(simp "PosToNatLeLt")
(auto)
(save "SqrtRealOne")





(set-goal "all a,n (0<a -> (sqrtmapaux a(Succ n)*sqrtmapaux a(Succ n)) <=  a)")
(assume "a" "n")
(assume "0<a")
(simp "sqrtmapaux0CompRule")
(simp "RatDiv0CompRule")
(simp "RatTimesAssoc")
(use "RatLeTimesCancelL" (pt "RatUDiv a"))
(use "RatUDivPosToRatPostwo")
(auto)
(simp "RatTimesAssoc")
(simp "RatTimesAssoc")
(simp "RatTimesAssoc")
(simprat (pf "RatUDiv a*a==1"))
(ng #t)
(use "RatLeTrans" (pt "RatUDiv(sqrtmap a(Succ n))*a*RatUDiv(sqrtmap a(Succ n))"))
(auto)
(simp "RatTimesComm")
(simp "RatTimesAssoc")
(use "RatLeTimesCancelR" (pt "RatUDiv a"))
(use "RatUDivPosToRatPostwo")
(auto)
(simp "<-" "RatTimesAssoc")
(simprat (pf "a*RatUDiv a==1"))
(use "RatLeTrans" (pt "RatUDiv(sqrtmap a(Succ n))*(RatUDiv(sqrtmap a(Succ n)))"))
(auto)
(use "RatLeTrans" (pt "RatUDiv a"))
(simprat "<-" "RatUDivTimes")
(use "RatLeUDiv")
(auto)
(use "RatLeTrans" (pt "sqrtmap a(Succ n)**2"))
(use "SqrtSeqSqrAux")
(auto)
(simprat "RatExpTwoE")
(auto)
(use "RatTimesUDivR")
(use "RatLtLeTrans" (pt "a"))
(auto)
(simp "RatTimesComm")
(use "RatTimesUDivR")
(use "RatLtLeTrans" (pt "a"))
(auto)
(save "SqrtauxSeqSqrAux")





(set-goal "all a (0<a -> Real(RealConstr (sqrtmapaux a) (cSqrtCauchyModulus a)))")
(assume "a" "0<a")
(use "RealIntro")
(use "CauchyIntro")
(assume "p")
(cases)
(cases)
(ng #t)
(use "Efq")
(ng #t)
(assume "n")
(use "Efq")
(assume  "n")
(cases)
(ng #t)
(assume "mpd1")
(use "Efq")
(assume "m")
(assume "modcond1" "modcond2")
(simp "RealSeq0CompRule")
(use "NatLeLtCases" (pt "m") (pt "n"))
(assume "case1")
(use "RatLeTrans" (pt "(sqrtmap a(Succ m))+ ~(sqrtmapaux a(Succ m))"))
(simp "RatAbsId")
(use "RatLeMonPlus")
(auto)
(use "bn2Lean2all")
(use "0<a")
(auto)
(use "RatLeZeroPlusToRatLe")
(use "SqrtAuxSeqMonInc2")
(use "0<a")
(use "case1")
(use "RatLeTrans" (pt "((1#2**((cNatPos(PosToNat p))+(cRatLeAbsBound(sqrtmap a(Succ Zero)+ ~(sqrtmapaux a(Succ Zero))))))*(sqrtmap a(Succ Zero)+ ~(sqrtmapaux a(Succ Zero))))"))
(use "RatLeTrans" (pt "(1#2**m)*(sqrtmap a (Succ Zero) + ~(sqrtmapaux a (Succ Zero)))"))
(use "SqrtCauchyAux")
(auto)
(use "RatLeTrans" (pt "((1#2**((cNatPos(PosToNat p))+(cRatLeAbsBound(sqrtmap a(Succ Zero)+ ~(sqrtmapaux a(Succ Zero))))))*(sqrtmap a(Succ Zero)+ ~(sqrtmapaux a(Succ Zero))))"))
(use "RatLeMonTimesTwo")
(auto)
(use "RatLeZeroPlusToRatLe")
(use "bn2Lean2all")
(auto)
(use "NatExpLe")
(auto)
(simprat "<-" "NatExpPlus")
(simprat (pf "(1#2**p)==(1#2**p)*1"))
(simp "<-" "RatTimesAssoc")
(use "RatLeMonTimesTwo")
(auto)
(use "RatLeTimesMonR")
(auto)
(use "RatLeZeroPlusToRatLe")
(use "bn2Lean2all")
(auto)
(simp "NatPosExFree")
(simp "NatToPosToNatId")
(ng #t)
(use "Truth")
(use "RatLeTrans" (pt "(1#2**cRatLeAbsBound(sqrtmap a(Succ Zero)+ ~(sqrtmapaux a(Succ Zero))))*abs((sqrtmap a(Succ Zero)+ ~(sqrtmapaux a(Succ Zero))))"))
(use "Truth")
(use "NatExpBound1")
(use "RatLeAbsBoundExFree")
(auto)
(assume "case2")
(use "RatLeTrans" (pt "(sqrtmap a(Succ n))+ ~(sqrtmapaux a(Succ n))"))
(simprat "RatAbsId3")
(use "RatLeMonPlus")
(use "bn2Lean2all")
(auto)
(use "SqrtAuxSeqMonInc2")
(auto)
(use "NatLtToLe")
(auto)
(use "RatLeTrans" (pt "((1#2**((cNatPos(PosToNat p))+(cRatLeAbsBound(sqrtmap a(Succ Zero)+ ~(sqrtmapaux a(Succ Zero))))))*(sqrtmap a(Succ Zero)+ ~(sqrtmapaux a(Succ Zero))))"))
(use "RatLeTrans" (pt "(1#2**n)*(sqrtmap a (Succ Zero) + ~(sqrtmapaux a (Succ Zero)))"))
(use "SqrtCauchyAux")
(auto)
(auto)
(use "RatLeTrans" (pt "((1#2**((cNatPos(PosToNat p))+(cRatLeAbsBound(sqrtmap a(Succ Zero)+ ~(sqrtmapaux a(Succ Zero))))))*(sqrtmap a(Succ Zero)+ ~(sqrtmapaux a(Succ Zero))))"))
(use "RatLeMonTimesTwo")
(auto)
(use "RatLeZeroPlusToRatLe")
(use "bn2Lean2all")
(auto)
(use "NatExpLe")
(auto)
(simprat "<-" "NatExpPlus")
(simprat (pf "(1#2**p)==(1#2**p)*1"))
(simp "<-" "RatTimesAssoc")
(use "RatLeMonTimesTwo")
(auto)
(use "RatLeTimesMonR")
(auto)
(use "RatLeZeroPlusToRatLe")
(use "bn2Lean2all")
(auto)
(simp "NatPosExFree")
(simp "NatToPosToNatId")
(auto)
(use "RatLeTrans" (pt "(1#2**cRatLeAbsBound(sqrtmap a(Succ Zero)+ ~(sqrtmapaux a(Succ Zero))))*abs((sqrtmap a(Succ Zero)+ ~(sqrtmapaux a(Succ Zero))))"))
(use "Truth")
(use "NatExpBound1")
(use "RatLeAbsBoundExFree")
(auto)
(use "MonIntro")
(assume "p" "q")
(assume "p<=q")
(ng #t)
(simp "NatPosExFree")
(simp "NatPosExFree")
(simp "NatToPosToNatId")
(simp "NatToPosToNatId")
(simp "PosToNatLe")
(auto)
(save "SqrtAuxRealAux2")


(set-goal "all a (0<a -> (RealConstr (sqrtmapaux a) (cSqrtCauchyModulus a))===(RealConstr (sqrtmap a) (cSqrtCauchyModulus a)))")
(assume "a" "0<a")
(use "RealEqChar2")
(use "SqrtAuxRealAux2")
(auto)
(use "SqrtRealOne")
(auto)
(assume "p")
(intro 0 (pt "cSqrtCauchyModulus a p"))
(cases)
(ng #t)
(use "Efq")
(assume "n" "mlen")
(simprat "RatAbsId3")
(use "RatLeTrans" (pt "((1#2**((cNatPos(PosToNat p))+(cRatLeAbsBound(sqrtmap a(Succ Zero)+ ~(sqrtmapaux a(Succ Zero))))))*(sqrtmap a(Succ Zero)+ ~(sqrtmapaux a(Succ Zero))))"))
(use "RatLeTrans" (pt "(1#2**n)*(sqrtmap a (Succ Zero) + ~(sqrtmapaux a (Succ Zero)))"))
(use "SqrtCauchyAux")
(auto)
(use "RatLeTrans" (pt "((1#2**((cNatPos(PosToNat p))+(cRatLeAbsBound(sqrtmap a(Succ Zero)+ ~(sqrtmapaux a(Succ Zero))))))*(sqrtmap a(Succ Zero)+ ~(sqrtmapaux a(Succ Zero))))"))
(use "RatLeMonTimesTwo")
(auto)
(use "RatLePlusCancelR" (pt "sqrtmapaux a(Succ Zero)"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "~(sqrtmapaux a(Succ Zero))+sqrtmapaux a(Succ Zero)==0"))
(simprat (pf "0+sqrtmapaux a(Succ Zero)==sqrtmapaux a(Succ Zero)"))
(simprat (pf "sqrtmap a(Succ Zero)+0==sqrtmap a(Succ Zero)"))
(use "bn2Lean2all")
(use "0<a")
(auto)
(use "NatExpLe")
(auto)
(simprat "<-" "NatExpPlus")
(simprat (pf "(1#2**p)==(1#2**p)*1"))
(simp "<-" "RatTimesAssoc")
(use "RatLeMonTimesTwo")
(auto)
(use "RatLeTimesMonR")
(ng #t)
(use "Truth")
(use "RatLePlusCancelR" (pt "sqrtmapaux a(Succ Zero)"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "~(sqrtmapaux a(Succ Zero))+sqrtmapaux a(Succ Zero)==0"))
(simprat (pf "0+sqrtmapaux a(Succ Zero)==sqrtmapaux a(Succ Zero)"))
(simprat (pf "sqrtmap a(Succ Zero)+0==sqrtmap a(Succ Zero)"))
(use "bn2Lean2all")
(auto)
(simp "NatPosExFree")
(simp "NatToPosToNatId")
(ng #t)
(use "Truth")
(use "RatLeTrans" (pt "(1#2**cRatLeAbsBound(sqrtmap a(Succ Zero)+ ~(sqrtmapaux a(Succ Zero))))*abs((sqrtmap a(Succ Zero)+ ~(sqrtmapaux a(Succ Zero))))"))
(use "Truth")
(use "NatExpBound1")
(use "RatLeAbsBoundExFree")
(auto)
(use "bn2Lean2all")
(auto)
(save "bneqan")


(define MATCH-TREE-BOUND 1000)



(set-goal "all a (0<a -> (RealConstr (sqrtmap a) (cSqrtCauchyModulus a))*(RealConstr (sqrtmap a) (cSqrtCauchyModulus a))===a)")
(assume "a")
(assume "0<a")
(cut "Real(RealConstr(sqrtmap a)(cSqrtCauchyModulus a))")
(assume "RealCutInst")
(cut "Real(RealConstr(sqrtmapaux a)(cSqrtCauchyModulus a))")
(assume "RealCutInst2")
(use "RealEqTrans" (pt "(RealConstr (sqrtmapaux a) (cSqrtCauchyModulus a))*(RealConstr (sqrtmapaux a) (cSqrtCauchyModulus a))"))
(use "RealTimesCompat")
(use "RealEqSym")
(use "bneqan")
(auto)
(use "RealEqSym")
(use "bneqan")
(auto)
(use "RealLeAntiSym")
(use "RealLeIntro")
(use "RealTimesReal")
(autoreal)
(use "RealNNegChar2")
(use "RealEqSModEqReal" (pt "a+ ~(RealConstr(sqrtmapaux a)(cSqrtCauchyModulus a)*RealConstr(sqrtmapaux a)(cSqrtCauchyModulus a))"))
(autoreal)
(use "RealEqSIntro")
(ng #t)
(auto)
(assume "p")
(intro 0 (pt "cSqrtCauchyModulus a p")) 
(cases)
(ng #t)
(use "Efq")
(assume "n" "meqn")
(use "RatLeTrans" (pt "(a+ ~((sqrtmapaux a (Succ n))*(sqrtmapaux a (Succ n))))"))
(use "RatLeTrans" (pt "0#1"))
(auto)
(use "RatLePlusCancelL" (pt "~a"))
(simp "RatPlusAssoc")
(simprat (pf "~a+a==0"))
(use "RatLeTrans" (pt "~a"))
(auto)
(use "RatLeTrans" (pt " ~(sqrtmapaux a(Succ n)*sqrtmapaux a(Succ n)) "))
(simp "RatLeUMinus")
(use "SqrtauxSeqSqrAux")
(auto)
(use "RealLeTrans" (pt "RealConstr(sqrtmap a)(cSqrtCauchyModulus a)*RealConstr(sqrtmap a)(cSqrtCauchyModulus a)"))
(use "RealLeIntro")
(use "RealRat")
(use "RealTimesReal")
(use "SqrtRealOne")
(auto)
(use "RealNNegChar2")
(use "RealEqSModEqReal" (pt "(RealConstr(sqrtmap a)(cSqrtCauchyModulus a)*RealConstr(sqrtmap a)(cSqrtCauchyModulus a) + ~a)"))
(autoreal)
(use "RealEqSIntro")
(auto)
(assume "p")
(intro 0 (pt "cSqrtCauchyModulus a p")) 
(cases)
(ng #t)
(use "Efq")
(assume "n" "mlen")
(use "RatLeTrans" (pt "0#1"))
(auto)
(use "RatLeTrans" (pt "sqrtmap a (Succ n)*sqrtmap a (Succ n)+ ~a"))
(use "RatLePlusCancelR" (pt "a"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "~a+a==0"))
(use "RatLeTrans" (pt "a"))
(auto)
(use "RatLeTrans" (pt "sqrtmap a(Succ n)*sqrtmap a(Succ n)"))
(simprat "RatExpTwoE")
(use "SqrtSeqSqrAux")
(auto)
(use "RealLeReflNC")
(use "RealTimesCompat")
(use "RealEqSym")
(use "bneqan")
(auto)
(use "RealEqSym")
(use "bneqan")
(auto)
(use "SqrtAuxRealAux2")
(auto)
(use "SqrtRealOne")
(auto)
(save "RatSqrtSqrProp")

;(deanimate "RatToPosZeroLB")




(set-goal "all a,b ( a<=b oru b<=a)")
(assume "a" "b")
(cases (pt "a<=b"))
(assume "1")
(intro 0)
(auto)
(assume "a<=b -> F")
(intro 1)
(use "RatLtToLe")
(use "RatNotLeToLt")
(auto)
(save "QLeCases")

(add-program-constant "hsqrt" (py "rat=>rea"))

(add-computation-rule "hsqrt a" "[if (0< a) (RealConstr(sqrtmap a) (cSqrtCauchyModulus a)) (ReaRat 0)]")

(set-totality-goal "hsqrt")
(use "AllTotalElim")
(assume "a")
(use "ReaTotalVar")
(save-totality)

(add-program-constant "hsqrtaux" (py "rat=>rea"))

(add-computation-rule "hsqrtaux a" "[if (0< a) (RealConstr(sqrtmapaux a) (cSqrtCauchyModulus a)) (ReaRat 0)]")

(set-totality-goal "hsqrtaux")
(use "AllTotalElim")
(assume "a")
(use "ReaTotalVar")
(save-totality)

(set-goal "all a hsqrtaux a===hsqrt a")
(assume "a")
(simp "hsqrtaux0CompRule")
(simp "hsqrt0CompRule")
(cases (pt "0<a"))
(assume "case")
(ng #t)
(use "bneqan")
(auto)
(assume "case2")
(ng #t)
(use "RealEqRefl")
(autoreal)
(save "hsqrtauxeqhsqrt")




(add-program-constant "hsqrtmod" (py "pos=>pos"))

(add-computation-rule "hsqrtmod p" "p+p")

(set-totality-goal "hsqrtmod")
(use "AllTotalElim")
(assume "p")
(use "PosTotalVar")
(save-totality)


(deanimate "SqrtCauchyModulus")





(set-goal "all a  0<<=hsqrt a")
(ng #t)
(assume "a")
(cases (pt "0<a"))
(assume "case1")
(ng #t)
(use "RealLeSToLe")
(ng #t)
(use "RealRat")
(use "SqrtRealOne")
(auto)
(use "RealLeSIntro")
(use "RealNNegSIntro")
(assume "n")
(ng #t)
(use "RatLtToLe")
(use "ZeroLtSqrtSeqn")
(auto)
(assume "case2")
(ng #t)
(use "RealLeRefl")
(autoreal)
(save "HsqrtNNeg")

(set-goal "all a (0<=a -> hsqrt a*hsqrt a===a)")
(ng #t)
(assume "a")
(assume "case")
(cases (pt "0<a"))
(assume "case1")
(use "RatSqrtSqrProp")
(auto)
(assume "case1")
(ng #t)
(use "RatEqvToRealEq")
(use "RatLeAntiSym")
(auto)
(use "RatNotLtToLe")
(auto)
(save "HsqrtSqrProp")


(set-goal "all a (0<=a -> hsqrtaux a*hsqrtaux a===a)")
(ng #t)
(assume "a")
(assume "case")
(cases (pt "0<a"))
(assume "case1")
(use "RealEqTrans" (pt "(RealConstr (sqrtmap a) (cSqrtCauchyModulus a))*(RealConstr (sqrtmap a) (cSqrtCauchyModulus a))"))
(use "RealTimesCompat")
(use "bneqan")
(auto)
(use "bneqan")
(auto)
(use "RatSqrtSqrProp")
(auto)
(assume "case1")
(ng #t)
(use "RatEqvToRealEq")
(use "RatLeAntiSym")
(auto)
(use "RatNotLtToLe")
(auto)
(save "HsqrtAuxSqrProp")




(set-goal "UCFall (UCFallConstr hsqrt hsqrtmod)")
(use "UCFallIntro")
(assume "a")
(cases (pt "0<a"))
(assume "0<a")
(ng #t)
(simp "0<a")
(ng #t)
(use "SqrtRealOne")
(auto)
(assume "case2")
(ng #t)
(simp "case2")
(ng #t)
(use "RealRat")
(assume "a" "b" "p" "modcond")
(cut "all a,b,p( 0<=a -> 0 <=b -> abs(a+ ~b)<=(1#2**([p0]p0+p0)p) -> abs(([a0][if (0<a0) (RealConstr(sqrtmap a0)(cSqrtCauchyModulus a0)) 0])a+ ~(([a0][if (0<a0) (RealConstr(sqrtmap a0)(cSqrtCauchyModulus a0)) 0])b))<<=(1#2**p))")
(assume "cutInst")
(inst-with-to "QLeCases" (pt "0#1") (pt "a") "Inst")
(inst-with-to "QLeCases" (pt "0#1") (pt "b") "Inst2")
(cut "0<=a oru a<=0")
(elim)
(assume "H1")
(cut "0<=b oru b<=0")
(elim)
(assume "H2")
(use "cutInst")
(auto)
(assume "case2")
(ng #t)
(cases (pt "(0<b)"))
(assume "case3")
(ng #t)
(use "Efq")
(use "RatLeToNotLt" (pt "b") (pt "0#1") )
(use "case2")
(use "case3")
(assume "case3")
(inst-with-to "cutInst" (pt "a") (pt "0#1") "cutInstAux")
(ng)
(use "cutInstAux")
(auto)
(simp "RatAbsId")
(use "RatLePlusCancelR" (pt "~a"))
(simprat (pf "a+ ~a==0"))
(use "RatLeTrans" (pt "(1#2**(p+p))+ ~a  + b+ ~b"))
(use "RatLeTrans" (pt "(1#2**(p+p))+  ~(a + ~ b)+ ~b"))
(use "RatLeTrans" (pt "(0#1)+(0#1)+(0#1)"))
(auto)
(use "RatLeMonPlus")
(ng #t)
(use "RatLePlusCancelR" (pt "~b"))
(ng #t)
(simp "<-" "RatPlusAssoc")
(simprat (pf "b+ ~b==0"))
(ng #t)
(use "RatLePlusCancelR" (pt "a"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "~a+a==0"))
(ng #t)
(use "RatLeTrans" (pt "a + ~b"))
(simp "RatPlusComm")
(auto)
(use "RatLeTrans" (pt "abs(a+ ~b)"))
(auto)
(use "RatLeUMinusToLeSwitch")
(ng #t)
(auto)
(simp "<-" "RatPlusAssoc")
(simprat (pf "b+ ~b==0"))
(ng #t)
(use "Truth")
(auto)
(assume "case1")
(cases (pt "0<a"))
(assume "case2")
(use "Efq")
(use "RatLeToNotLt" (pt "a") (pt "0#1") )
(use "case1")
(auto)
(assume "case2")
(inst-with-to "cutInst" (pt "(0#1)") (pt "b") "cutInst2")
(elim "Inst2")
(assume "case3")
(ng)
(simp "case2")
(ng)
(use "cutInst2")
(auto)
(simp "RatAbsId")
(use "RatLeUMinusToLeSwitch")
(use "RatLePlusCancelR" (pt "(1#2**(p+p))"))
(simprat (pf "~(1#2**(p+p))+(1#2**(p+p))==0"))
(use "RatLeTrans" (pt "a + ~b+(1#2**(p+p)) + ~a"))
(use "RatLeTrans" (pt "(0#1)+(0#1)"))
(auto)
(use "RatLeMonPlus")
(use "RatLePlusCancelR" (pt "~(1#2**(p+p))"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "((1#2**(p+p))+ ~(1#2**(p+p)))==0"))
(simprat (pf "0+ ~(1#2**(p+p))== ~(1#2**(p+p))"))
(simprat (pf "a+ ~b+0==a + ~b"))
(inst-with-to "RatAbsLeCases" (pt "a+ ~b") (pt "(1#2**(p+p))") "InstAbs")
(use "InstAbs")
(auto)
(use "RatLeUMinusToLeSwitch")
(auto)
(simp "<-" "RatPlusAssoc")
(simp "RatPlusComm")
(simp "RatPlusAssoc")
(simp "RatPlusComm")
(simp "RatPlusAssoc")
(simp "RatPlusAssoc")
(simp "<-" "RatPlusAssoc")
(simprat (pf "~a+a==0"))
(auto)
(assume "case3")
(cases (pt "0<b"))
(assume "case4")
(use "Efq")
(use "RatLeToNotLt"  (pt "b") (pt "0#1") )
(auto)
(assume "case4")
(ng #t)
(simp "case4")
(simp "case2")
(ng #t)
(use "RatLeToRealLe")
(auto)
(assume "a0" "b0" "p0")
(assume "0lea" "0leb")
(assume "modcond0")
(ng #t)
(inst-with-to "RealSubVar" (pt "[if (0<a0) (RealConstr(sqrtmap a0)(cSqrtCauchyModulus a0)) 0]") "sub1")
(cut "ex y [if (0<a0) (RealConstr(sqrtmap a0)(cSqrtCauchyModulus a0)) 0]===y")
(assume "sub1cut")
(by-assume "sub1cut" "x1" "sub1Prop")
(inst-with-to "RealSubVar" (pt "[if (0<b0) (RealConstr(sqrtmap b0)(cSqrtCauchyModulus b0)) 0]") "sub2")
(cut "ex y [if (0<b0) (RealConstr(sqrtmap b0)(cSqrtCauchyModulus b0)) 0]===y")
(assume "sub2cut")
(by-assume "sub2cut" "y1" "sub2Prop")
(use "RealLeTrans" (pt "abs(x1 + ~y1)"))
(use "RealLeReflNC")
(use "RealAbsCompat")
(use "RealPlusCompat")
(auto)
(use "RealUMinusCompat")
(auto)
(use "RealLeAbs")
(use "RealLeTimesCancelR" (pt "((1#2**p0) + x1 +y1)") (pt "PosS(PosS(PosS(PosS p0)))") )
(autoreal)
(use "RealLtToRealPos")
(use "RealLtLeTrans" (pt "ReaRat(1#2**p0)"))
(realproof)
(simp "ReaRat0CompRule")
(autoreal)
(simp "ReaRat0CompRule")
(use "RealLeTrans" (pt "ReaRat (1#2**p0) + ReaRat 0"))
(ng #t)
(use "RatLeToRealLe")
(auto)
(simp "ReaRat0CompRule")
(simp "ReaRat0CompRule")
(simpreal "<-" "RealPlusAssoc")
(use "RealLeMonPlus")
(use "RatLeToRealLe")
(auto)
(use "RealLeTrans" (pt "ReaRat 0 + ReaRat 0"))
(ng #t)
(use "RealLeRefl")
(autoreal)
(use "RealLeMonPlus")
(ng #t)
(simpreal "<-" "sub1Prop")
(use "HsqrtNNeg")
(ng #t)
(simpreal "<-" "sub2Prop")
(use "HsqrtNNeg")
(autoreal)
(ng #t)
(auto)
(simpreal "<-" "RealPlusAssoc")
(simpreal "RealTimesPlusDistr")
(use "RealLeTrans" (pt " (1#2**p0)*(x1+y1) +(1#2**p0)*(1#2**p0)"))
(use "RealLeMonPlus")
(simpreal "RealTimesComm")
(simpreal "RealTimesPlusDistr")
(simpreal "RealTimesPlusDistr")
(use "RealLeMonPlus")
(use "RealLeRefl")
(autoreal)
(simpreal "RealTimesComm")
(simpreal "RealTimesUMinusId")
(use "RealLePlusCancelR" (pt "y1*(1#2**p0)"))
(autoreal)
(simpreal "RealPlusComm")
(use "RealLeTrans" (pt "ReaRat 0"))
(ng #t)
(use "RealLeReflNC")
(use "RealPlusMinusZero")
(autoreal)
(simp "ReaRat0CompRule")
(use "RealNNegToRealLe")
(use "RealNNegPlusNNeg")
(use "RealNNegTimesNNeg")
(use "RealLeToRealNNeg")
(use "RatLeToRealLe")
(auto)
(use "RealLeToRealNNeg")
(simpreal "<-" "sub2Prop")
(use "HsqrtNNeg")
(use "RealNNegTimesNNeg")
(simpreal "<-" "sub2Prop")
(use "RealLeToRealNNeg")
(use "HsqrtNNeg")
(use "RealLeToRealNNeg")
(use "RatLeToRealLe")
(auto)
(autoreal)
(simpreal "RealBinomForm3")
(simpreal "<-" "sub1Prop")
(simpreal "<-" "sub2Prop")
(simpreal "HsqrtSqrProp")
(simpreal "HsqrtSqrProp")
(use "RealLeTrans" (pt "abs(ReaRat a0 + ~ (ReaRat b0))"))
(ng #t)
(use "RatLeToRealLe")
(ng #t)
(use "Truth")
(simp "ReaRat0CompRule")
(simp "ReaRat0CompRule")
(use "RealLeTrans" (pt "ReaRat (1#2**([p]p+p)p0)"))
(ng #t)
(use "RatLeToRealLe")
(use "modcond0")
(simp "ReaRat0CompRule")
(ng #t)
(use "RatLeToRealLe")
(ng #t)
(simp "PosExpTwoPosPlus")
(auto)
(autoreal)
(simpreal "RealPlusComm")
(simpreal  "RealTimesPlusDistr")
(simpreal  "RealTimesPlusDistr")
(simpreal  "RealTimesPlusDistr")
(ng #t)
(use "RealLeRefl")
(autoreal)
(use "RealLeUMinusInv")
(use "RealLeTrans" (pt "x1+ ~y1"))
(use "RealLeTimesCancelR" (pt "((1#2**p0) + x1 +y1)") (pt "PosS(PosS(PosS(PosS p0)))") )
(autoreal)
(use "RealLtToRealPos")
(use "RealLtLeTrans" (pt "ReaRat(1#2**p0)"))
(realproof)
(simp "ReaRat0CompRule")
(realproof)
(realproof)
(simp "ReaRat0CompRule")
(use "RealLeTrans" (pt "ReaRat (1#2**p0) + ReaRat 0"))
(ng #t)
(use "RatLeToRealLe")
(auto)
(simp "ReaRat0CompRule")
(simp "ReaRat0CompRule")
(simpreal "<-" "RealPlusAssoc")
(use "RealLeMonPlus")
(use "RatLeToRealLe")
(auto)
(use "RealLeTrans" (pt "ReaRat 0 + ReaRat 0"))
(ng #t)
(use "RealLeRefl")
(autoreal)
(use "RealLeMonPlus")
(simp "ReaRat0CompRule")
(simpreal "<-" "sub1Prop")
(use "HsqrtNNeg")
(ng #t)
(simpreal "<-" "sub2Prop")
(use "HsqrtNNeg")
(autoreal)
(ng #t)
(use "Truth")
(simpreal "<-" "RealPlusAssoc")
(simpreal "RealTimesPlusDistr")
(simpreal "RealTimesPlusDistr")
(simpreal "RealTimesPlusDistr")
(use "RealLeTrans" (pt "(x1+ ~y1)*(x1+y1)+(x1+ ~y1)*(1#2**p0)"))
(use "RealLeMonPlus")
(simpreal "RealBinomForm3")
(simpreal "<-" "sub1Prop")
(simpreal "<-" "sub2Prop")
(simpreal "HsqrtSqrProp")
(simpreal "HsqrtSqrProp")
(use "RatLeToRealLe")
(inst-with-to "RatAbsLeCases" (pt "a0+ ~b0") (pt "1#2**([p]p+p)p0") "RatInst")
(ng #t)
(ng "RatInst")
(use "RatLeTrans" (pt "IntN 1#2**(p0+p0)"))
(ng #t)
(simp "PosExpTwoPosPlus")
(ng #t)
(use "Truth")
(use "RatInst")
(use "modcond0")
(auto)
(autoreal)
(simpreal "RealTimesPlusDistrLeft")
(use "RealLeMonPlus")
(ng #t)
(simpreal "RealTimesComm")
(use "RealLeMonTimes")
(use "RealLeToRealNNeg")
(simpreal "<-" "sub1Prop")
(use "HsqrtNNeg")
(use "RatLeToRealLe")
(ng #t)
(use "Truth")
(autoreal)
(simpreal "RealTimesComm")
(simpreal "RealTimesUMinusId")
(use "RealLeReflNC")
(simpreal "RealTimesComm")
(simpreal "RealTimesUMinusId")
(use "RealUMinusCompat")
(simpreal "RealTimesComm")
(use "RealEqRefl")
(autoreal)
(simpreal "RealPlusComm")
(use "RealLeRefl")
(autoreal)
(use "RealLeReflNC")
(use "RealEqSym")
(use "RealUMinusUMinus")
(autoreal)
(use "sub2")
(use "RealLeElim1" (pt "ReaRat 0") )
(simp "ReaRat0CompRule")
(use "HsqrtNNeg")
(use "sub1")
(use "RealLeElim1" (pt "ReaRat 0") )
(simp "ReaRat0CompRule")
(use "HsqrtNNeg")
(ng #t)
(assume "p" "q")
(assume "pleq")
(use "PosLeMonPlus")
(auto)
(save "UCFallsqrt")

(set-goal "all a  0<<=hsqrtaux a")
(ng #t)
(assume "a")
(cases (pt "0<a"))
(assume "case1")
(ng #t)
(use "RealLeSToLe")
(realproof)
(use "SqrtAuxRealAux2")
(auto)
(use "RealLeSIntro")
(use "RealNNegSIntro")
(assume "n")
(ng #t)
(use "RatLeTimesCancelR" (pt "sqrtmap a n"))
(use "ZeroLtSqrtSeqn")
(auto)
(simp "<-" "RatTimesAssoc")
(simprat (pf "RatUDiv(sqrtmap a n)*sqrtmap a n==1"))
(simprat (pf "0*sqrtmap a n==0"))
(ng #t)
(use "RatLtToLe")
(auto)
(simprat "RatTimesZeroL")
(auto)
(simp "RatTimesComm")
(use "RatTimesUDivR")
(simp "RatAbsId")
(use "ZeroLtSqrtSeqn")
(auto)
(use "RatLtToLe")
(use "ZeroLtSqrtSeqn")
(auto)
(assume "case2")
(ng #t)
(use "RealLeRefl")
(autoreal)
(save "HsqrtAuxNNeg")


(set-goal "UCFall (UCFallConstr hsqrtaux hsqrtmod)")
(use "UCFallIntro")
(assume "a")
(simp "hsqrtaux0CompRule")
(cases (pt "0<a"))
(assume "case1")
(use "SqrtAuxRealAux2")
(auto)
(assume "case2")
(ng #t)
(autoreal)
(assume "a" "b" "p")
(assume "modcond")
(simp "hsqrtaux0CompRule")
(simp "hsqrtaux0CompRule")
(cut "all a,b,p( 0<=a -> 0 <=b -> abs(a+ ~b)<=(1#2**([p0]p0+p0)p) -> abs([if (0<a) (RealConstr(sqrtmapaux a)(cSqrtCauchyModulus a)) (ReaRat 0)]+ ~[if (0<b)(RealConstr(sqrtmapaux b)(cSqrtCauchyModulus b))(ReaRat 0)])<<=(1#2**p))")
(assume "cutInst")
(inst-with-to "QLeCases" (pt "0#1") (pt "a") "Inst")
(inst-with-to "QLeCases" (pt "0#1") (pt "b") "Inst2")
(cut "0<=a oru a<=0")
(elim)
(assume "H1")
(cut "0<=b oru b<=0")
(elim)
(assume "H2")
(use "cutInst")
(auto)
(assume "case2")
(ng #t)
(cases (pt "(0<b)"))
(assume "case3")
(ng #t)
(use "Efq")
(use "RatLeToNotLt" (pt "b") (pt "0#1") )
(use "case2")
(use "case3")
(assume "case3")
(inst-with-to "cutInst" (pt "a") (pt "0#1") "cutInstAux")
(ng)
(use "cutInstAux")
(auto)
(simp "RatAbsId")
(use "RatLePlusCancelR" (pt "~a"))
(simprat (pf "a+ ~a==0"))
(use "RatLeTrans" (pt "(1#2**(p+p))+ ~a  + b+ ~b"))
(use "RatLeTrans" (pt "(1#2**(p+p))+  ~(a + ~ b)+ ~b"))
(use "RatLeTrans" (pt "(0#1)+(0#1)+(0#1)"))
(auto)
(use "RatLeMonPlus")
(ng #t)
(use "RatLePlusCancelR" (pt "~b"))
(ng #t)
(simp "<-" "RatPlusAssoc")
(simprat (pf "b+ ~b==0"))
(ng #t)
(use "RatLePlusCancelR" (pt "a"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "~a+a==0"))
(ng #t)
(use "RatLeTrans" (pt "a + ~b"))
(simp "RatPlusComm")
(auto)
(use "RatLeTrans" (pt "abs(a+ ~b)"))
(auto)
(use "RatLeUMinusToLeSwitch")
(ng #t)
(auto)
(simp "<-" "RatPlusAssoc")
(simprat (pf "b+ ~b==0"))
(ng #t)
(use "Truth")
(auto)
(assume "case1")
(cases (pt "0<a"))
(assume "case2")
(use "Efq")
(use "RatLeToNotLt" (pt "a") (pt "0#1"))
(use "case1")
(auto)
(assume "case2")
(inst-with-to "cutInst" (pt "(0#1)") (pt "b") "cutInst2")
(elim "Inst2")
(assume "case3")
(ng)
(use "cutInst2")
(auto)
(simp "RatAbsId")
(use "RatLeUMinusToLeSwitch")
(use "RatLePlusCancelR" (pt "(1#2**(p+p))"))
(simprat (pf "~(1#2**(p+p))+(1#2**(p+p))==0"))
(use "RatLeTrans" (pt "a + ~b+(1#2**(p+p)) + ~a"))
(use "RatLeTrans" (pt "(0#1)+(0#1)"))
(auto)
(use "RatLeMonPlus")
(use "RatLePlusCancelR" (pt "~(1#2**(p+p))"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "((1#2**(p+p))+ ~(1#2**(p+p)))==0"))
(simprat (pf "0+ ~(1#2**(p+p))== ~(1#2**(p+p))"))
(simprat (pf "a+ ~b+0==a + ~b"))
(inst-with-to "RatAbsLeCases" (pt "a+ ~b") (pt "(1#2**(p+p))") "InstAbs")
(use "InstAbs")
(auto)
(use "RatLeUMinusToLeSwitch")
(auto)
(simp "<-" "RatPlusAssoc")
(simp "RatPlusComm")
(simp "RatPlusAssoc")
(simp "RatPlusComm")
(simp "RatPlusAssoc")
(simp "RatPlusAssoc")
(simp "<-" "RatPlusAssoc")
(simprat (pf "~a+a==0"))
(auto)
(assume "case3")
(cases (pt "0<b"))
(assume "case4")
(use "Efq")
(use "RatLeToNotLt" (pt "b") (pt "0#1"))
(auto)
(assume "case4")
(ng #t)
(use "RatLeToRealLe")
(auto)
(assume "a0" "b0" "p0")
(assume "0lea" "0leb")
(assume "modcond0")
(inst-with-to "RealSubVar" (pt "[if (0<a0)(RealConstr(sqrtmapaux a0)(cSqrtCauchyModulus a0))(ReaRat 0)]") "sub1")
(cut "ex y [if (0<a0)(RealConstr(sqrtmapaux a0)(cSqrtCauchyModulus a0))(ReaRat 0)]===y")
(assume "sub1cut")
(by-assume "sub1cut" "x1" "sub1Prop")
(inst-with-to "RealSubVar" (pt "[if (0<b0)(RealConstr(sqrtmapaux b0)(cSqrtCauchyModulus b0))(ReaRat 0)]") "sub2")
(cut "ex y [if (0<b0)(RealConstr(sqrtmapaux b0)(cSqrtCauchyModulus b0))(ReaRat 0)]===y")
(assume "sub2cut")
(by-assume "sub2cut" "y1" "sub2Prop")
(use "RealLeTrans" (pt "abs(x1 + ~y1)"))
(use "RealLeReflNC")
(use "RealAbsCompat")
(use "RealPlusCompat")
(auto)
(use "RealUMinusCompat")
(auto)
(use "RealLeAbs")
(use "RealLeTimesCancelR" (pt "((1#2**p0) + x1 +y1)") (pt "PosS(PosS(PosS(PosS p0)))") )
(autoreal)
(use "RealLtToRealPos")
(use "RealLtLeTrans" (pt "ReaRat(1#2**p0)"))
(realproof)
(simp "ReaRat0CompRule")
(autoreal)
(simp "ReaRat0CompRule")
(use "RealLeTrans" (pt "ReaRat (1#2**p0) + ReaRat 0"))
(ng #t)
(use "RatLeToRealLe")
(auto)
(simp "ReaRat0CompRule")
(simp "ReaRat0CompRule")
(simpreal "<-" "RealPlusAssoc")
(use "RealLeMonPlus")
(use "RatLeToRealLe")
(auto)
(use "RealLeTrans" (pt "ReaRat 0 + ReaRat 0"))
(ng #t)
(use "RealLeRefl")
(autoreal)
(use "RealLeMonPlus")
(ng #t)
(simpreal "<-" "sub1Prop")
(use "HsqrtAuxNNeg")
(ng #t)
(simpreal "<-" "sub2Prop")
(use "HsqrtAuxNNeg")
(autoreal)
(ng #t)
(auto)
(simpreal "<-" "RealPlusAssoc")
(simpreal "RealTimesPlusDistr")
(use "RealLeTrans" (pt " (1#2**p0)*(x1+y1) +(1#2**p0)*(1#2**p0)"))
(use "RealLeMonPlus")
(simpreal "RealTimesComm")
(simpreal "RealTimesPlusDistr")
(simpreal "RealTimesPlusDistr")
(use "RealLeMonPlus")
(use "RealLeRefl")
(autoreal)
(use "RealLePlusCancelR" (pt "y1*(1#2**p0)"))
(autoreal)
(simpreal "RealTimesComm")
(simpreal (pf "~y1*(1#2**p0)+y1*(1#2**p0)===0"))
(simpreal "RealTimesComm")
(simpreal "<-" "RealTimesPlusDistr")
(use "RealNNegToRealLe")
(use "RealNNegTimesNNeg")
(use "RealLeToRealNNeg")
(simpreal "<-" "sub2Prop")
(use "HsqrtAuxNNeg")
(use "RealLeToRealNNeg")
(use "RatLeToRealLe")
(auto)
(autoreal)
(simpreal "RealPlusComm")
(simpreal "RealTimesUMinusId")
(use "RealPlusMinusZero")
(autoreal)
(simpreal "RealBinomForm3")
(simpreal "<-" "sub1Prop")
(simpreal "<-" "sub2Prop")
(simp "<-" "hsqrtaux0CompRule")
(simp "<-" "hsqrtaux0CompRule")
(use "RealLeTrans" (pt "a0+ ~(ReaRat b0)"))
(use "RealLeReflNC")
(use "RealPlusCompat")
(use "HsqrtAuxSqrProp")
(auto)
(use "RealUMinusCompat")
(simp "ReaRat0CompRule")
(use "HsqrtAuxSqrProp")
(auto)
(use "RealLeTrans" (pt "abs(ReaRat a0 + ~ (ReaRat b0))"))
(ng #t)
(use "RatLeToRealLe")
(ng #t)
(use "Truth")
(simp "ReaRat0CompRule")
(simp "ReaRat0CompRule")
(use "RealLeTrans" (pt "ReaRat (1#2**([p]p+p)p0)"))
(ng #t)
(use "RatLeToRealLe")
(use "modcond0")
(simp "ReaRat0CompRule")
(ng #t)
(use "RatLeToRealLe")
(ng #t)
(simp "PosExpTwoPosPlus")
(auto)
(autoreal)
(simpreal "RealPlusComm")
(simpreal  "RealTimesPlusDistr")
(simpreal  "RealTimesPlusDistr")
(simpreal  "RealTimesPlusDistr")
(ng #t)
(use "RealLeRefl")
(autoreal)
(use "RealLeUMinusInv")
(use "RealLeTrans" (pt "x1+ ~y1"))
(use "RealLeTimesCancelR" (pt "((1#2**p0) + x1 +y1)") (pt "PosS(PosS(PosS(PosS p0)))") )
(autoreal)
(use "RealLtToRealPos")
(use "RealLtLeTrans" (pt "ReaRat(1#2**p0)"))
(realproof)
(simp "ReaRat0CompRule")
(autoreal)
(simp "ReaRat0CompRule")
(use "RealLeTrans" (pt "ReaRat (1#2**p0) + ReaRat 0"))
(ng #t)
(use "RatLeToRealLe")
(auto)
(simp "ReaRat0CompRule")
(simp "ReaRat0CompRule")
(simpreal "<-" "RealPlusAssoc")
(use "RealLeMonPlus")
(use "RatLeToRealLe")
(auto)
(use "RealLeTrans" (pt "ReaRat 0 + ReaRat 0"))
(ng #t)
(use "RealLeRefl")
(autoreal)
(use "RealLeMonPlus")
(simp "ReaRat0CompRule")
(simpreal "<-" "sub1Prop")
(use "HsqrtAuxNNeg")
(ng #t)
(simpreal "<-" "sub2Prop")
(use "HsqrtAuxNNeg")
(autoreal)
(ng #t)
(use "Truth")
(simpreal "<-" "RealPlusAssoc")
(simpreal "RealTimesPlusDistr")
(simpreal "RealTimesPlusDistr")
(simpreal "RealTimesPlusDistr")
(use "RealLeTrans" (pt "(x1+ ~y1)*(x1+y1)+(x1+ ~y1)*(1#2**p0)"))
(use "RealLeMonPlus")
(simpreal "RealBinomForm3")
(simpreal "<-" "sub1Prop")
(simpreal "<-" "sub2Prop")
(simp "<-" "hsqrtaux0CompRule")
(simp "<-" "hsqrtaux0CompRule")
(use "RealLeTrans" (pt "a0 + ~ (ReaRat b0)"))
(simp "ReaRat0CompRule")
(use "RatLeToRealLe")
(inst-with-to "RatAbsLeCases" (pt "a0+ ~b0") (pt "1#2**([p]p+p)p0") "RatInst")
(ng #t)
(ng "RatInst")
(use "RatLeTrans" (pt "IntN 1#2**(p0+p0)"))
(ng #t)
(simp "PosExpTwoPosPlus")
(ng #t)
(use "Truth")
(use "RatInst")
(use "modcond0")
(use "RealLeMonPlus")
(simpreal "HsqrtAuxSqrProp")
(use "RealLeRefl")
(autoreal)
(auto)
(use "RealLeReflNC")
(use "RealUMinusCompat")
(simp "ReaRat0CompRule")
(simpreal "HsqrtAuxSqrProp")
(use "RealEqRefl")
(autoreal)
(auto)
(autoreal)
(simpreal "RealTimesPlusDistrLeft")
(use "RealLeMonPlus")
(ng #t)
(simpreal "RealTimesComm")
(use "RealLeMonTimes")
(use "RealLeToRealNNeg")
(simpreal "<-" "sub1Prop")
(use "HsqrtAuxNNeg")
(use "RatLeToRealLe")
(ng #t)
(use "Truth")
(autoreal)
(simpreal "RealTimesComm")
(simpreal "RealTimesUMinusId")
(use "RealLeReflNC")
(simpreal "RealTimesComm")
(simpreal "RealTimesUMinusId")
(use "RealUMinusCompat")
(simpreal "RealTimesComm")
(use "RealEqRefl")
(autoreal)
(simpreal "RealPlusComm")
(use "RealLeRefl")
(autoreal)
(use "RealLeReflNC")
(use "RealEqSym")
(use "RealUMinusUMinus")
(autoreal)
(use "sub2")
(use "RealLeElim1" (pt "ReaRat 0") )
(simp "ReaRat0CompRule")
(use "HsqrtAuxNNeg")
(use "sub1")
(use "RealLeElim1" (pt "ReaRat 0") )
(simp "ReaRat0CompRule")
(use "HsqrtAuxNNeg")
(ng #t)
(assume "p" "q")
(assume "pleq")
(use "PosLeMonPlus")
(auto)
(save "UCFallsqrtaux")



(add-program-constant "Rsqrt" (py "rea=>rea"))

;;(animate "RealBoundX")

;;(pt "ContexApplicationbounded (ContexConstr sqrtmapex (SqrtCauchyModex) (SqrtModulus)) (~(1#2)) (cRealBoundX(x)) x")

(add-computation-rule "Rsqrt x" "(UCFallConstr hsqrt hsqrtmod) x")

(set-totality-goal "Rsqrt")
(use "AllTotalElim")
(assume "x")
(use "ReaTotalVar")
(save-totality)



(set-goal "all x(Real x -> Real(Rsqrt x))")
(assume "x")
(simp "Rsqrt0CompRule")
(assume "Rx")
(inst-with-to "UCFallApplicationReal" (pt "UCFallConstr hsqrt hsqrtmod") (pt "x") "RealInst")
(use "RealInst")
(use "UCFallsqrt")
(auto)
(save "RealSqrtReal")


(add-program-constant "Rsqrtaux" (py "rea=>rea"))
(add-computation-rule "Rsqrtaux x" "(UCFallConstr hsqrtaux hsqrtmod) x")

(set-totality-goal "Rsqrtaux")
(use "AllTotalElim")
(assume "x")
(use "ReaTotalVar")
(save-totality)

(set-goal "all x (Real(x) -> Real(Rsqrtaux x))")
(assume "x" "Rx")
(simp "Rsqrtaux0CompRule")
(inst-with-to "UCFallApplicationReal" (pt "UCFallConstr hsqrtaux hsqrtmod") (pt "x") "RealInst")
(use "RealInst")
(use "UCFallsqrtaux")
(autoreal)
(save "RealSqrtAuxReal")




(set-goal "all x (Real x -> Rsqrtaux x === Rsqrt x)")
(assume "x" "Rx")
(use "RealEqChar2RealConstrFree")
(use "RealSqrtAuxReal")
(realproof)
(use "RealSqrtReal")
(autoreal)
(assume "p")
(intro 0 (pt "Succ(PosToNat (p))"))
(assume "n"   "s" )
(ng #t)
(inst-with-to "NatSubVar" (pt "([if (0<x seq(x mod(SOne(cNatPos n))))(RealConstr([n0]x seq(x mod(SOne(cNatPos n)))*RatUDiv(sqrtmap(x seq(x mod(SOne(cNatPos n))))n0))(cSqrtCauchyModulus(x seq(x mod(SOne(cNatPos n))))))0]mod(cNatPos(Succ(Succ n))))") "sub1")
(by-assume "sub1" "m0" "sub1Prop")
(simp "sub1Prop")
(inst-with-to "NatSubVar" (pt "([if (0<x seq(x mod(SOne(cNatPos n))))(RealConstr(sqrtmap(x seq(x mod(SOne(cNatPos n)))))(cSqrtCauchyModulus(x seq(x mod(SOne(cNatPos n))))))0]mod(cNatPos(Succ(Succ n))))") "sub2")
(by-assume "sub2" "m1" "sub2Prop")
(simp "sub2Prop")
(inst-with-to "RealEqCharOnev2ExFreeConstrFree" (pt "hsqrtaux (x seq(x mod(SOne(cNatPos n))))") (pt "hsqrt(x seq(x mod(SOne(cNatPos n))))") "Inst")
(use "Inst")
(use "hsqrtauxeqhsqrt")
(ng #t)
(simp "<-" "sub1Prop")
(ng #t)
(cases (pt "0<x seq(x mod(SOne(cNatPos n)))"))
(assume "case1")
(ng #t)
(use "MonElim")
(use "RealConstrToMon" (pt "([n0] sqrtmap (x seq(x mod(SOne(cNatPos n)))) n0)"))
(use "SqrtRealOne")
(auto)
(simp "NatPosExFree")
(simp "<-" "PosToNatLe")
(simp "PosToNatToPosId")
(simp "PosSSucc")
(simp "PosSSucc")
(ng #t)
(use "NatLeTrans" (pt "Succ(PosToNat p)"))
(ng #t)
(use "Truth")
(auto)
(simp "<-" "sub2Prop")
(ng #t)
(cases (pt "0<x seq(x mod(SOne(cNatPos n)))"))
(assume "case1")
(ng #t)
(use "MonElim")
(use "RealConstrToMon" (pt "([n0] sqrtmap (x seq(x mod(SOne(cNatPos n)))) n0)"))
(use "SqrtRealOne")
(auto)
(simp "NatPosExFree")
(simp "<-" "PosToNatLe")
(simp "PosToNatToPosId")
(simp "PosSSucc")
(simp "PosSSucc")
(ng #t)
(use "NatLeTrans" (pt "Succ(PosToNat p)"))
(ng #t)
(use "Truth")
(auto)
(save "RsqrtauxEqRsqrt")



(define MATCH-TREE-BOUND 1000)

(deanimate "SqrtCauchyModulus")

(set-goal "all x( 0<<=x ->Rsqrt x*Rsqrt x===x)")
(cases)
(assume "as" "M")
(assume "0<=x")
(assert "Real(Rsqrt (RealConstr as M))")
(use "RealSqrtReal")
(autoreal)
(assume "Real(Rsqrt x)")
(assert "Real(Rsqrtaux (RealConstr as M))")
(use "RealSqrtAuxReal")
(autoreal)
(assume "RealRsqrtaux")
(use "RealLeAntiSym")
(simpreal "<-" "RsqrtauxEqRsqrt")
(use "RealLeIntro")
(autoreal)
(assert "Real(RealConstr as M+ ~(Rsqrtaux(RealConstr as M)*Rsqrtaux(RealConstr as M)))")
(autoreal)
(assume "cutInstAux")
(use "RealNNegChar2")
(auto)
(assume "p")
(intro 0 (pt "Succ(PosToNat p)max M(PosS p)"))
(assume "n")
(assume "cond")
(ng #t)
(inst-with-to "RatSubVar" (pt "[if (0<as(M(SOne(cNatPos n))))(RealConstr([n0]as(M(SOne(cNatPos n)))*RatUDiv(sqrtmap(as(M(SOne(cNatPos n))))n0))(cSqrtCauchyModulus(as(M(SOne(cNatPos n))))))0]seq([if (0<as(M(SOne(cNatPos n))))(RealConstr([n0]as(M(SOne(cNatPos n)))*RatUDiv(sqrtmap(as(M(SOne(cNatPos n))))n0))(cSqrtCauchyModulus(as(M(SOne(cNatPos n))))))0]mod(cNatPos(Succ(Succ n))))") "sub1")
(by-assume "sub1" "b1" "sub1Prop")
(simprat "sub1Prop")
(use "RatLeTrans" (pt "as n+ ~(as(M(SOne(cNatPos n))))+ as(M(SOne(cNatPos n))) + ~(b1*b1)"))
(ng #t)
(use "RatLeTrans" (pt "(IntN 1#2**(PosS p)) + (IntN 1#2**(PosS p))"))
(use "RatLeTrans" (pt "~(1#2**p)"))
(auto)
(use "RatLeTrans" (pt "~(1#2**PosS(p))+ ~(1#2**PosS(p))"))
(simprat "<-" "RatPlusHalfExpPosS")
(ng #t)
(use "Truth")
(use "RatLeMonPlus")
(auto)
(simp "<-" "RatPlusAssoc")
(use "RatLeMonPlus")
(inst-with-to "RatAbsLeCases" (pt "as n+ ~(as(M(SOne(cNatPos n))))") (pt "1#2**PosS p") "RatInst")
(use "RatInst")
(use "CauchyElim" (pt "M"))
(use "RealConstrToCauchy")
(autoreal)
(use "NatLeTrans" (pt "Succ(PosToNat p)max M(PosS p)"))
(use "NatMaxUB2")
(auto)
(use "MonElim")
(use "RealConstrToMon" (pt "as"))
(autoreal)
(use "PosLeTrans" (pt "cNatPos n"))
(simp "NatPosExFree")
(simp  "<-" "PosToNatLe")
(simp "PosToNatToPosId")
(simp "PosSSucc")
(use "NatLeTrans" (pt "Succ(PosToNat p)max M(PosS p)"))
(use "NatMaxUB1")
(auto)
(use "NatLtLeTrans" (pt "Succ(PosToNat p)max M(PosS p)")) 
(use "NatLtLeTrans" (pt "Succ(PosToNat p)"))
(auto)
(use "NatMaxUB1")
(auto)
(use "PosLeTrans" (pt "SZero(cNatPos n) "))
(auto)
(use "RatLePlusCancelR" (pt "b1*b1"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "(~(b1*b1)+b1*b1)==0"))
(ng #t)
(cases (pt "0<as(M(SOne(cNatPos n)))"))
(assume "case1")
(use "RatLeTrans" (pt "b1*b1"))
(use "RatLeTrans" (pt "0+b1*b1"))
(use "RatLeMonPlus")
(auto)
(simprat "<-" "sub1Prop")
(simp "case1")
(ng #t)
(animate "SqrtCauchyModulus")
(use "SqrtauxSeqSqrAux")
(use "case1")
(assume "case2")
(simprat "<-" "sub1Prop")
(simp "case2")
(ng #t)
(use "RealNNegCharOneExFree" (pt "M"))
(use "RealLeToRealNNeg")
(auto)
(ng #t)
(use "MonElim")
(use "RealConstrToMon" (pt "as"))
(autoreal)
(ng #t)
(use "PosLeLtTrans" (pt "PosS(cNatPos n)"))
(ng #t)
(simp "NatPosExFree")
(simp  "<-" "PosToNatLe")
(simp "PosToNatToPosId")
(use "NatLeTrans" (pt "Succ(PosToNat p)max M(PosS p)"))
(use "NatLeTrans" (pt "Succ(PosToNat p)"))
(auto)
(use "NatMaxUB1")
(auto)
(use "NatLtLeTrans" (pt "Succ(PosToNat p)"))
(auto)
(use "NatLeTrans" (pt "Succ(PosToNat p)max M(PosS p)"))
(use "NatMaxUB1")
(auto)
(simp "<-" "PosS1CompRule")
(assert "all p,q (PosS p < PosS q)=(p<q)")
(auto)
(assume "assertion")
(simp "assertion")
(auto)
(use "RatLePlusCancelR" (pt "b1*b1"))
(simp "<-" "RatPlusAssoc")
(simprat (pf "~(b1*b1)+b1*b1==0"))
(simp "<-" "RatPlusAssoc")
(simp "<-" "RatPlusAssoc")
(simp "<-" "RatPlusAssoc")
(simprat (pf "~(b1*b1)+b1*b1==0"))
(ng #t)
(simp "<-" "RatPlusAssoc")
(simprat (pf "~(as(M(SOne(cNatPos n))))+as(M(SOne(cNatPos n)))==0"))
(auto)
(autoreal)
(deanimate "SqrtCauchyModulus")
;; part 1 done
;;(simpreal "<-" "RsqrtauxEqRsqrt")
(use "RealLeIntro")
(autoreal)
(assert "Real(Rsqrt(RealConstr as M)*Rsqrt(RealConstr as M)+ ~(RealConstr as M))")
(autoreal)
(assume "RealCutInst")
(use "RealNNegChar2")
(auto)
(assume "p")
(intro 0 (pt "Succ(PosToNat p)max M(PosS p)"))
(assume "n" "cond")
(ng #t)
(inst-with-to "RatSubVar" (pt "[if (0<as(M(SOne(cNatPos n))))(RealConstr(sqrtmap(as(M(SOne(cNatPos n)))))(cSqrtCauchyModulus(as(M(SOne(cNatPos n))))))0]seq([if (0<as(M(SOne(cNatPos n))))(RealConstr(sqrtmap(as(M(SOne(cNatPos n)))))(cSqrtCauchyModulus(as(M(SOne(cNatPos n))))))0]mod(cNatPos(Succ(Succ n))))") "sub1")
(by-assume "sub1" "b1" "sub1Prop")
(simprat "sub1Prop")
(use "RatLeTrans" (pt "(IntN 1#2**(PosS p)) + (IntN 1#2**(PosS p))"))
(use "RatLeTrans" (pt "~(1#2**p)"))
(auto)
(use "RatLeTrans" (pt "~(1#2**PosS(p))+ ~(1#2**PosS(p))"))
(simprat "<-" "RatPlusHalfExpPosS")
(auto)
(use "RatLeTrans" (pt "~(as(M(SOne(cNatPos n)))) + b1*b1+ ~(as n) + as(M(SOne(cNatPos n)))"))
(simp "<-" "RatPlusAssoc")
(use "RatLeMonPlus")
(cases (pt "0<(as(M(SOne(cNatPos n))))")) 
(assume "case1")
(use "RatLePlusCancelL" (pt "(as(M(SOne(cNatPos n))))"))
(ng #t)
(simprat (pf "(as(M(SOne(cNatPos n)))+ ~(as(M(SOne(cNatPos n)))))==0"))
(ng #t)
(use "RatLeTrans" (pt "as(M(SOne(cNatPos n)))"))
(use "RatLePlusCancelL" (pt "~(as(M(SOne(cNatPos n))))"))
(ng #t)
(simprat (pf "~(as(M(SOne(cNatPos n))))+as(M(SOne(cNatPos n)))==0"))
(ng #t)
(use "Truth")
(auto)
(simprat "<-" "sub1Prop")
(simp "case1")
(ng #t)
(animate "SqrtCauchyModulus")
(simprat "RatExpTwoE")
(use "SqrtSeqSqrAux")
(auto)
(assume "case2")
(simprat "<-" "sub1Prop")
(ng #t)
(simp "case2")
(ng #t)
(use "RatLeUMinusToLeSwitch")
(ng #t)
(use "RatLeTrans" (pt "0#1"))
(use "RatNotLtToLe")
(auto)
(inst-with-to "RatAbsLeCases"  (pt "~(as n)+as(M(SOne(cNatPos n)))") (pt "(1#2**(PosS p))") "RatInst")
(ng "RatInst")
(use "RatInst")
(simp "RatPlusComm")
(use "CauchyElim" (pt "M"))
(use "RealConstrToCauchy")
(autoreal)
(use "MonElim")
(use "RealConstrToMon" (pt "as"))
(autoreal)
(use "PosLeTrans" (pt "cNatPos n"))
(simp "NatPosExFree")
(simp  "<-" "PosToNatLe")
(simp "PosToNatToPosId")
(simp "PosSSucc")
(use "NatLeTrans" (pt "Succ(PosToNat p)max M(PosS p)"))
(use "NatMaxUB1")
(auto)
(use "NatLtLeTrans" (pt "Succ(PosToNat p)max M(PosS p)"))
(use "NatLtLeTrans" (pt "Succ(PosToNat p)"))
(auto)
(use "NatMaxUB1")
(auto)
(use "PosLeTrans" (pt "PosS(cNatPos n)"))
(auto)
(use "NatLeTrans" (pt "Succ(PosToNat p)max M(PosS p)"))
(use "NatMaxUB2")
(auto)
(use "RatLePlusCancelL" (pt "(as(M(SOne(cNatPos n))))"))
(ng #t)
(simprat (pf "as(M(SOne(cNatPos n)))+ ~(as(M(SOne(cNatPos n))))==0"))
(ng #t)
(simp "RatPlusComm")
(auto)
(deanimate "SqrtCauchyModulus")
(save "RealSqrtProp")






(set-goal "all x (0<<=x ->  0<<=Rsqrt x)")
(cases)
(assume "as" "M")
(assume "cond1")
(use "RealLeIntro")
(realproof)
(use "RealSqrtReal")
(realproof)
(use "RealNNegChar2RealConstrFree")
(use "RealPlusReal")
(use "RealSqrtReal")
(autoreal)
(assume "p")
(intro 0 (pt "Zero"))
(assume "n")
(assume "M p <=n")
(ng #t)
(cases (pt "0<as(M(SOne(cNatPos n)))"))
(assume "case")
(ng #t)
(use "RatLeTrans" (pt "0#1"))
(auto)
(use "RatLtToLe")
(use "ZeroLtSqrtSeqn")
(auto)
(save "RsqrtNNeg")




(set-goal "all x,y (0<<=x -> 0<<=y ->  Rsqrt(x*y)===Rsqrt x*Rsqrt y)")
(assume "x" "y" "0<=x" "0<=y")
(assert "all x (Real x -> Real(Rsqrt x))")
(use "RealSqrtReal")
(assume "RAssertion")
(assert "Real(Rsqrt(x*x))")
(use "RealSqrtReal")
(use "RealTimesReal")
(use "RealLeElim1" (pt "ReaRat 0"))
(auto)
(autoreal)
(assume "RealRsqrt")
(use "SqrRevCompat")
(use "RsqrtNNeg")
(use "RealNNegToRealLe")
(use "RealNNegTimesNNeg")
(use "RealLeToRealNNeg")
(auto)
(use "RealLeToRealNNeg")
(auto)
(use "RealNNegToRealLe")
(use "RealNNegTimesNNeg")
(use "RealLeToRealNNeg")
(use "RsqrtNNeg")
(auto)
(use "RealLeToRealNNeg")
(use "RsqrtNNeg")
(use "0<=y")
(use "RealEqTrans" (pt "x*y"))
(use "RealSqrtProp")
(use "RealNNegToRealLe")
(use "RealNNegTimesNNeg")
(use "RealLeToRealNNeg")
(auto)
(use "RealLeToRealNNeg")
(use "0<=y")
(inst-with-to "RealSubVar" (pt "Rsqrt x") "sub1")
(inst-with-to "RealSubVar" (pt "Rsqrt y") "sub2")
(cut "ex y Rsqrt x===y")
(assume "sub1p")
(by-assume "sub1p" "z0" "sub1Prop")
(cut "ex y0 Rsqrt y===y0")
(assume "sub2p")
(by-assume "sub2p" "z1" "sub2Prop")
(simpreal "sub1Prop")
(simpreal "sub2Prop")
(use "RealEqTrans" (pt "z0*z0*(z1*z1)"))
(simpreal "<-" "sub1Prop")
(simpreal "RealSqrtProp")
(simpreal "<-" "sub2Prop")
(simpreal "RealSqrtProp")
(use "RealEqRefl")
(autoreal)
(use "0<=y")
(use "0<=x")
(simpreal "RealTimesAssoc")
(simpreal "RealTimesAssoc")
(use "RealTimesCompat")
(simpreal "RealTimesComm")
(simpreal "RealTimesAssoc")
(use "RealTimesCompat")
(use "RealTimesComm")
(autoreal)
(use "RealEqRefl")
(autoreal)
(use "RealEqRefl")
(autoreal)
(use "sub2")
(use "RealSqrtReal")
(autoreal)
(use "sub1")
(use "RealSqrtReal")
(autoreal)
(save "RealSqrtProp3")



(set-goal "all x,y (0<<=x -> x <<=y -> Rsqrt x<<=Rsqrt y)")
(assume "x" "y")
(assume "0<=x" "x<=y")
(cut "Real(Rsqrt x)")
(cut "Real(Rsqrt y)")
(assume "cut1" "cut2")
(use "RealLeIntro")
(autoreal)
(use "RealLeToRealNNeg")
(use "NotGtIsLt")
(autoreal)
(assume "Hyp1")
(assert "exl p RealLt 0 y p -> F")
(assume "Hyp2")
(by-assume "Hyp1" "p0" "Hyp1Prop")
(cut "RealLt(Rsqrt y+ ~(Rsqrt x))0 p0")
(use "LeIsNotGtExFree")
(autoreal)
(use "RealLeTimesCancelLC" (pt "Rsqrt y+ (Rsqrt x)"))
(autoreal)
(assume "Hyp3")
(assert "Rsqrt y === 0")
(use "RealLeAntiSym")
(use "RealLeTrans" (pt "Rsqrt y+Rsqrt x"))
(use "RealLeTrans" (pt "Rsqrt y + 0"))
(use "RealLeReflNC")
(use "RealEqSym")
(use "RealPlusZero")
(autoreal)
(use "RealLeMonPlus")
(use "RealLeRefl")
(autoreal)
(use "RsqrtNNeg")
(auto)
(use "RsqrtNNeg")
(use "RealLeTrans" (pt "x"))
(auto)
(assume "sqrty eq 0")
(by-assume "Hyp2" "p1" "Hyp2Prop")
(cut "RealLt 0 y p1")
(use "LeIsNotGtExFree")
(autoreal)
(simpreal "<-" "RealSqrtProp")
(simpreal (pf "0===(ReaRat 0)*(ReaRat 0)"))
(inst-with-to "RealTimesCompat" (pt "Rsqrt y ")   (pt "ReaRat 0")  (pt "Rsqrt y") (pt "ReaRat 0") "CompatInst")
(use "RealLeReflNC")
(use "CompatInst")
(simp "ReaRat0CompRule")
(use "sqrty eq 0")
(simp "ReaRat0CompRule")
(use "sqrty eq 0")
(ng #t)
(use "RealEqRefl")
(autoreal)
(use "RealLeTrans" (pt "x"))
(auto)
(simpreal "RealTimesComm")
(simpreal "RealBinomForm3")
(simpreal (pf "Rsqrt y*Rsqrt y===y"))
(simpreal (pf "Rsqrt x*Rsqrt x===x"))
(use "RealLeTrans" (pt "x + ~x"))
(use "RealLeReflNC")
(use "RealEqSym")
(use "RealPlusMinusZero")
(autoreal)
(use "RealLeMonPlus")
(auto)
(use "RealLeReflNC")
(use "RealEqRefl")
(autoreal)
(use "RealSqrtProp")
(auto)
(use "RealSqrtProp")
(use "RealLeTrans" (pt "x"))
(auto)
(autoreal)
(auto)
(assume "H")
(assert "y<<=0")
(use "NotGtIsLt")
(autoreal)
(use "H")
(assume "y<<=0")
(by-assume "Hyp1" "p0" "Hyp1Prop")
(cut "RealLt(Rsqrt y+ ~(Rsqrt x))0 p0")
(use "LeIsNotGtExFree")
(autoreal)
(use "RealLeTrans" (pt "Rsqrt 0 + ~(Rsqrt 0)"))
(ng #t)
(use "RealLeReflNC")
(ng #t)
(use "RealEqSToEq")
(autoreal)
(use "RealEqSIntro")
(auto)
(use "RealLeMonPlus")
(use "RealLeReflNC")
(simp "Rsqrt0CompRule")
(simp "Rsqrt0CompRule")
(use "UCFallApplicationCompat")
(use "UCFallsqrt")
(use "RealLeAntiSym")
(use "RealLeTrans" (pt "x"))
(auto)
(use "RealLeReflNC")
(use "RealUMinusCompat")
(simp "Rsqrt0CompRule")
(simp "Rsqrt0CompRule")
(use "UCFallApplicationCompat")
(use "UCFallsqrt")
(use "RealLeAntiSym")
(auto)
(use "RealLeTrans" (pt "y"))
(auto)
(use "RealSqrtReal")
(realproof)
(use "RealSqrtReal")
(realproof)
(save "RealSqrtInc")

(set-goal "all x,y (0<<=x ->0<<=y -> Rsqrt x<<=Rsqrt y -> x <<=y )")
(assume "x" "y")
(assume "0<<=x" "0<<=y")
(assume "RsqrtCond")
(simpreal "<-" "RealSqrtProp")
(simpreal (pf "y===Rsqrt y*Rsqrt y"))
(use "RealLeMonTimesTwo")
(use "RealLeToRealNNeg")
(use "RsqrtNNeg")
(auto)
(use "RealLeToRealNNeg")
(use "RsqrtNNeg")
(auto)
(use "RealEqSym")
(use  "RealSqrtProp")
(auto)
(save "RealSqrtAntiInc")


(set-goal "all x (Real x -> Rsqrt(x*x) === abs(x))")
(assume "x" "Rx")
(cut "Real(Rsqrt x)")
(assume "cutX")
(cut "Real(Rsqrt(x*x))")
(assume "cutXX")
(simpreal (pf "abs(x)===Rsqrt(abs(x))*Rsqrt(abs(x))"))
(use "RealEqTrans" (pt "Rsqrt(abs(x*x))"))
(simp "Rsqrt0CompRule")
(simp "Rsqrt0CompRule")
(use "UCFallApplicationCompat")
(use "UCFallsqrt")
(use "RealEqSym")
(use "RealEqAbs")
(use "RealLeToRealNNeg")
(use "SqrNNeg")
(auto)
(cut "Real(Rsqrt abs(x*x))")
(assume "cutX3")
(simpreal "<-" "RealSqrtProp3")
(simp "Rsqrt0CompRule")
(simp "Rsqrt0CompRule")
(use "UCFallApplicationCompat")
(use "UCFallsqrt")
(use "RealAbsTimes")
(auto)
(use "RealAbsNNeg")
(auto)
(use "RealAbsNNeg")
(auto)
(use "RealSqrtReal")
(autoreal)
(use "RealEqSym")
(use "RealSqrtProp")
(use "RealAbsNNeg")
(realproof)
(use "RealSqrtReal")
(realproof)
(use "RealSqrtReal")
(realproof)
(save "RealSqrtProp4")


(set-goal "all x,y (0<<=x -> 0 <<=y-> x*x <<=y*y -> x<<=y)")
(assume "x" "y" "0lex" "0ley")
(assume "xxleyy")
(simpreal (pf "x===Rsqrt(x*x)"))
(cut "Real(Rsqrt(x*x))")
(assume "RsqrtCut")
(simpreal (pf "y===Rsqrt(y*y)"))
(use "RealSqrtInc")
(use "SqrNNeg")
(autoreal)
(auto)
(simpreal "RealSqrtProp4")
(use "RealEqSym")
(use "RealEqAbs")
(use "RealLeToRealNNeg")
(auto)
(realproof)
(use "RealSqrtReal")
(autoreal)
(simpreal "RealSqrtProp4")
(use "RealEqSym")
(use "RealEqAbs")
(use "RealLeToRealNNeg")
(auto)
(realproof)
(save "RealSqrAntiInc")


(set-goal "all x,y( 0<<=x -> 0<<=y -> Rsqrt x === Rsqrt y -> x===y)")
(assume "x" "y" "0lex" "0ley" "Sx=Sy")
(simpreal "<-" "RealSqrtProp")
(simpreal (pf "y===Rsqrt y*Rsqrt y"))
(use "RealTimesCompat")
(auto)
(simpreal "RealSqrtProp")
(use "RealEqRefl")
(autoreal)
(auto)
(save "RSqrtCompatRev")


(animate "SqrtCauchyModulus")
(animate "RatLeAbsBound")
(animate "RealApprox")
(animate "NatPos")


