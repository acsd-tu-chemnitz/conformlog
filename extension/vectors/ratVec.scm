(display "loading ratVec.scm")(newline)


(add-algs "ratVec" '("RatVecConstr" "list rat=>ratVec"))

;basic variables
(add-var-name "e" (py "ratVec"))
(add-var-name "dimV" (py "pos"))
(add-var-name "eV" (py "(list rat)"))
(add-var-name "rls" (py "list rat"))

(add-totality "ratVec")


(set-goal "all e TotalRatVec e")
(cases)
(cases)
(ng #t)
(use "TotalRatVecRatVecConstr")
(use "TotalListNil")
(assume "a" "eV")
(use "TotalRatVecRatVecConstr")
(use "TotalListCons")
(use "RatTotalVar")
(use "ListTotalVar")
(save "RatVecTotalVar")


;Computational rules
(add-program-constant "RatVecEqv" (py "ratVec=>ratVec=>boole")) ;; eqv
(add-program-constant "RatVecDim" (py "ratVec=>nat") t-deg-zero) ;; dim
(add-program-constant "RatVecToList" (py "ratVec=>(list rat)") t-deg-zero) ;; get_data
(add-program-constant "RatVecPlus" (py "ratVec=>ratVec=>ratVec")) ;; plus
(add-program-constant "RatVecUMinus" (py "ratVec=>ratVec")) ;; unitary minus
(add-program-constant "RatVecSTimes" (py "rat=>ratVec=>ratVec")) ;; scalar mult
(add-program-constant "RatVecDTimes" (py "ratVec=>ratVec=>rat")) ;; inner product
(add-program-constant "RatVecMaxNorm" (py "ratVec=>rat" ) t-deg-zero) ;; infinity norm
(add-program-constant "RatVecOneNorm" (py "ratVec=>rat") t-deg-zero) ;; 1-norm
(add-program-constant "RatVecNth" (py "ratVec=>nat=>rat") t-deg-zero)

;; operator overload - legacy support 

(define (add-item-to-algebra-edge-to-embed-term-alist-star
         alg1-name alg2-name embed-term)
  (set! ALGEBRA-EDGE-TO-EMBED-TERM-ALIST
        (cons (list (list (make-alg alg1-name) (make-alg alg2-name))
		    embed-term)
              ALGEBRA-EDGE-TO-EMBED-TERM-ALIST)))

; ; operator overloading 
(add-item-to-algebra-edge-to-embed-term-alist-star
 "rat" "list rat"
 (let ((var (make-var (make-alg "rat") -1 t-deg-one "")))
   (make-term-in-abst-form
    var (mk-term-in-app-form
    (make-term-in-const-form
     (let* ((constr (constr-name-to-constr "Cons"))
	    (tvars (const-to-tvars constr))
	    (subst (make-substitution tvars (list (alg-form-to-name var)))))
       (const-substitute constr subst #f)))
    (make-term-in-var-form var)
    (make-term-in-const-form
     (let* ((constr (constr-name-to-constr "Nil"))
	    (tvars (const-to-tvars constr))
	    (subst (make-substitution tvars (list (alg-form-to-name var)))))
       (const-substitute constr subst #f)))))))

(alg-le? (make-alg "rat") (make-alg "list rat"))

(add-item-to-algebra-edge-to-embed-term-alist-star
 "list rat" "ratVec"
 (let ((var (make-var (py "list rat") -1 t-deg-one "")))
   (make-term-in-abst-form
    var (mk-term-in-app-form
         (make-term-in-const-form
          (constr-name-to-constr "RatVecConstr"))
           (make-term-in-var-form var)
          ))))


(alg-le? (make-alg "list rat") (make-alg "ratVec"))



(add-token-and-type-to-name "==" (py "ratVec") "RatVecEqv")
(add-display (py "boole") (make-display-creator "RatVecEqv" "==" 'rel-op))



(add-token-and-type-to-name "+" (py "ratVec") "RatVecPlus")
(add-display (py "ratVec") (make-display-creator "RatVecPlus" "+" 'add-op))



(add-token-and-type-to-name "~" (py "ratVec") "RatVecUMinus")
(add-display (py "ratVec") (make-display-creator1 "RatVecUMinus" "~" 'prefix-op))



(add-token-and-type-to-name "*" (py "ratVec") "RatVecDTimes")
(add-display (py "rat") (make-display-creator "RatVecDTimes" "*" 'mul-op))

(add-token-and-type-to-name "*" (list (py "rat") (py "ratVec")) "RatVecSTimes")
(pp (pt "a*e"))
; (add-token "|*|" 'mul-op (make-term-creator-exp "|*|"))
; (add-token-and-type-to-name "|*|" (list (py "rat") (py "ratVec")) "RatVecSTimes")
; (pp (pt "a|*|e"))


(add-token "|_" 'prefix-op (make-term-creator1 "|_" "ratVec"))
(add-token-and-type-to-name "|_" (py "ratVec") "RatVecMaxNorm")
(add-display (py "rat") (make-display-creator1 "RatVecMaxNorm" "|_" 'prefix-op))


(add-token "||_" 'prefix-op (make-term-creator1 "||_" "ratVec"))
(add-token-and-type-to-name "||_" (py "ratVec") "RatVecOneNorm")
(add-display (py "rat") (make-display-creator1 "RatVecOneNorm" "||_" 'prefix-op))


(add-token "values" 'postfix-op (make-term-creator1 "values" "ratVec"))
(add-token-and-type-to-name "values" (py "ratVec") "RatVecToList")
(add-display (py "list rat") (make-display-creator1 "RatVecToList" "values" 'postfix-op))

(add-token "dim" 'postfix-op (make-term-creator1 "dim" "ratVec"))
(add-token-and-type-to-name "dim" (py "ratVec") "RatVecDim")
(add-display (py "nat") (make-display-creator1 "RatVecDim" "dim" 'postfix-op))

(add-token-and-type-to-name "__"  (py "ratVec") "RatVecNth")
(add-display (py "rat") (make-display-creator "RatVecNth" "__" 'mul-op))





(pp (pt "e==e"))
(pp (pt "e+e"))
(pp (pt "~e"))
(pp (pt "e*e"))
(pp (pt "|_e"))
(pp (pt "||_e"))


(pp  (pt "e values"))
(pp (pt "e dim"))
(pp (pt "e__n"))




; (add-token "=_" 'rel-op (make-term-creator "=_" "ratVec"))
; (add-token-and-type-to-name "=_" (py "ratVec") "RatVecEqv")
; (add-display (py "boole") (make-display-creator "RatVecEqv" "_=" 'rel-op))
; (add-infix-display-string "RatVecPlus" "+_" 'add-op)
; (add-infix-display-string "RatVecDTimes" "**_" 'add-op)
; (add-infix-display-string "RatVecSTimes" "*_" 'add-op)
; (add-prefix-display-string "RatVecUMinus" "~_")
; (add-prefix-display-string "RatVecInfNorm" "|_")
; (add-prefix-display-string "RatVecOneNorm" "||_")

;; auxiliary program constants 

(add-program-constant "RatZeroVecAux" (py "nat=>(list rat)")) ;; rename later to RatZeroOrNilVecAux
(add-computation-rules
  "RatZeroVecAux (Succ n)" "(0#1)::(RatZeroVecAux n)"
  "RatZeroVecAux Zero" "(Nil rat)")

(set-totality-goal "RatZeroVecAux")
(assume "n^1" "Tn1")
(elim "Tn1")
(ng #t)
(use "TotalListNil")
(assume "n^2" "Tn2" "IHS")
(ng #t)
(use "TotalListCons")
(use "RatTotalVar")
(use "IHS")
(save-totality)

(add-program-constant "RatZeroVec" (py "nat=>ratVec"))
(add-computation-rule "RatZeroVec n" "RatVecConstr(RatZeroVecAux n)")

(set-totality-goal "RatZeroVec")
(assume "n^1" "Tn1")
(ng #t)
(use "TotalRatVecRatVecConstr")
(use "RatZeroVecAuxTotal")
(use "Tn1")
(save-totality)

(add-program-constant "RatVecEqvAux" (py "(list rat)=>(list rat)=>boole"))
(add-computation-rules
  "RatVecEqvAux (Nil rat) (Nil rat)" "True"
  "RatVecEqvAux (Nil rat) eV" "True"
  "RatVecEqvAux eV (Nil rat)" "True"
  "RatVecEqvAux (a::eV1) (b::eV2)" "[if (a==b) (RatVecEqvAux eV1 eV2) (False)]")

(pp(nt(pt "RatVecConstr((1#1):)==RatVecConstr((1#1)::(1#1):)")))

; (add-token "~=_" 'rel-op (make-term-creator "=_" "(list rat)"))
; (add-token-and-type-to-name "~=_" (py "(list rat)") "RatVecEqvAux")
; (add-display (py "boole") (make-display-creator "RatVecEqvAux" "~_=" 'rel-op))

(set-totality-goal "RatVecEqvAux")
(use "AllTotalElim")
(ind)
(assume "eV^1" "TeV1")
(elim "TeV1")
(ng #t)
(use "TotalBooleTrue")
(assume "a^1" "Ta1" "eV^2" "TeV2" "Is")
(ng #t)
(use "TotalBooleTrue")
(assume "a" "eV" "IH")
(assume "eV^2" "TeV2")
(ng #t)
(elim "TeV2")
(ng #t)
(use "TotalBooleTrue")
(assume "a^2" "Ta2" "eV^3" "TeV3")
(assume "IS2")
(ng #t)
(use "BooleIfTotal")
(use "RatEqvTotal")
(use "RatTotalVar")
(use "Ta2")
(use "IH")
(use "TeV3")
(use "TotalBooleFalse")
(save-totality)

(remove-theorem "NatEqSym") ;; ???

(set-goal "all n,m((n=m)=(m=n))")
(assume "m" "n")
(use "BooleAeqToEq")
(assume 1)
(simp 1)
(use "Truth")
(assume 1)
(simp 1)
(use "Truth")
(save "NatEqSym")

;; RatVecToList
(add-computation-rules 
  "(RatVecConstr eV) values" "eV"
  "(RatVecConstr (Nil rat))values" "(Nil rat)")

(set-totality-goal "RatVecToList")
(assume "e^1" "Te1")
(elim "Te1")
(assume "eV^1" "TeV1")
(ng #t)
(use "TeV1")
(save-totality)


(add-computation-rules "RatVecDim e" "Lh(e values)")

(set-totality-goal "RatVecDim")
(assume "e^1" "Te1")
(ng #t)
(use "ListLengthTotal")
(use "RatVecToListTotal")
(use "Te1")
(save-totality)

;; RatVecEqv
(add-computation-rule
  "e1 == e2" "[if ((e1 dim) = (e2 dim)) (RatVecEqvAux (e1 values) (e2 values)) (False)]")

(set-totality-goal "RatVecEqv")
(assume "e^1" "Te1" "e^2" "Te2")
(ng #t)
(elim "Te1")
(elim "Te2")
(assume "eV^1" "TeV1" "eV^2" "TeV2")
(use "BooleIfTotal")
(use "NatEqTotal")
(use "ListLengthTotal")
(use "RatVecToListTotal")
(use "TotalRatVecRatVecConstr")
(use "TeV2")
(use "ListLengthTotal")
(use "RatVecToListTotal")
(use "TotalRatVecRatVecConstr")
(use "TeV1")
(use "RatVecEqvAuxTotal")
(use "RatVecToListTotal")
(use "TotalRatVecRatVecConstr")
(use "TeV2")
(use "RatVecToListTotal")
(use "TotalRatVecRatVecConstr")
(use "TeV1")
(use "TotalBooleFalse")
(save-totality)


(add-computation-rules "e__n" "(e values)__n") 

(set-totality-goal "RatVecNth")
(use "AllTotalElim")
(cases)
(assume "rls")
(ng #t)
(use "AllTotalElim")
(assume "n")
(use "RatTotalVar")
(save-totality)

;; 
(add-program-constant "RatVecUMinusAux" (py "(list rat)=>(list rat)"))
(add-computation-rules "RatVecUMinusAux (a::eV)" "((~a)::(RatVecUMinusAux eV))"
                       "RatVecUMinusAux (Nil rat)" "(Nil rat)")

(set-totality-goal "RatVecUMinusAux")
(assume "eV^1" "TeV1")
(elim "TeV1")
(ng #t)
(use "ListTotalVar")
(assume "a^1" "Ta1" "eV^2" "TeV2" "IS")
(ng #t)
(use "TotalListCons")
(use "RatUMinusTotal")
(use "Ta1")
(use "IS")
(save-totality)

;; RatVecUMinus
(add-computation-rule "~ e1" "RatVecConstr(RatVecUMinusAux (e1 values))")

(set-totality-goal "RatVecUMinus")
(assume "e^1" "Te1")
(elim "Te1")
(assume "eV^1" "TeV1")
(ng #t)
(use "TotalRatVecRatVecConstr")
(use "RatVecUMinusAuxTotal")
(use "TeV1")
(save-totality)

; (add-computation-rule "RatVecEqv e1 e2" "[if ((RatVecDim e1) = (RatVecDim e2)) (RatVecEqvAux (qVal e1) (qVal e2)) (False)]")

; (set-totality-goal "RatVecEqv")
; (assume "e^1" "Te1" "e^2" "Te2")
; (ng #t)
; (elim "Te1")
; (elim "Te2")
; (assume "eV^1" "TeV1" "eV^2" "TeV2")
; (use "BooleIfTotal")
; (use "NatEqTotal")
; (use "ListLengthTotal")
; (use "RatVecToListTotal")
; (use "TotalRatVecRatVecConstr")
; (use "TeV2")
; (use "ListLengthTotal")
; (use "RatVecToListTotal")
; (use "TotalRatVecRatVecConstr")
; (use "TeV1")
; (use "RatVecEqvAuxTotal")
; (use "RatVecToListTotal")
; (use "TotalRatVecRatVecConstr")
; (use "TeV2")
; (use "RatVecToListTotal")
; (use "TotalRatVecRatVecConstr")
; (use "TeV1")
; (use "TotalBooleFalse")
; (save-totality)

(add-program-constant "RatVecYprod" (py "ratVec=>((list rat) yprod nat)"))
(add-postfix-display-string "RatVecYprod" "vecDeconst")
(add-computation-rules
    "RatVecYprod e"
    "((e values) pair (Lh (e values)))")

(set-totality-goal "RatVecYprod")
(use "AllTotalElim")
(cases)
(assume "eV")
(ng #t)
(use "YprodTotalVar")
(save-totality)

(add-program-constant "RatVecSTimesAux" (py "rat => (list rat) => (list rat)"))
(add-computation-rules
  "RatVecSTimesAux a (b::eV)" "(a*b)::(RatVecSTimesAux a eV)"
  "RatVecSTimesAux a (Nil rat)" "(Nil rat)")

(add-infix-display-string "RatVecSTimesAux" "~*_" 'add-op)

(set-totality-goal "RatVecSTimesAux")
(assume "a^" "Ta" "eV^" "TeV")
(elim "TeV")
(ng #t)
(use "ListTotalVar")
(assume "b^" "Tb" "eV^1" "TeV1" "TList")
(ng #t)
(use "TotalListCons")
(use "RatTimesTotal")
(use "Ta")
(use "Tb")
(use "TList")
(save-totality)

(add-computation-rules "RatVecSTimes a e" "RatVecConstr (RatVecSTimesAux a (e values))")

(set-totality-goal "RatVecSTimes")
(assume "a^" "Ta" "e^" "Te")
(ng #t)
(use "TotalRatVecRatVecConstr")
(elim "Te")
(ng #t)
(assume "eV^" "TeV")
(ng #t)
(use "RatVecSTimesAuxTotal")
(use "Ta")
(use "TeV")
(save-totality)

(add-program-constant "RatVecPlusAux" (py "(list rat)=>(list rat)=>(list rat)"))
(add-computation-rules "RatVecPlusAux (Nil rat) (Nil rat)" "(Nil rat)"
                       "RatVecPlusAux (Nil rat) eV" "(Nil rat)"
                       "RatVecPlusAux eV (Nil rat)" "(Nil rat)"
                       "RatVecPlusAux (a::eV1) (b::eV2)" "[if ((Lh (a::eV1)) = (Lh (b::eV2))) ((a+b)::(RatVecPlusAux eV1 eV2)) (Nil rat)]")


(set-totality-goal "RatVecPlusAux")
(use "AllTotalElim")
(ind)
(use "AllTotalElim")
(ind)
(ng #t)
(use "ListTotalVar")
(assume "a" "eV" "IH")
(ng #t)
(use "ListTotalVar")
(assume "a" "eV" "IH1")
(assume "eV^1" "TeV1")
(elim "TeV1")
(ng #t)
(use "ListTotalVar")
(assume "a^" "Ta" "eV^2" "TeV2" "TList1")
(ng #t)
(use "BooleIfTotal")
(use "NatEqTotal")
(use "ListLengthTotal")
(use "ListTotalVar")
(use "ListLengthTotal")
(use "TeV2")
(ng #t)
(use "TotalListCons")
(use "RatPlusTotal")
(use "RatTotalVar")
(use "Ta")
(inst-with "IH1" (pt "(eV^2)"))
(use 6)
(use "TeV2")
(use "ListTotalVar")
(save-totality)


(add-computation-rules "e1 + e2" "[if ((e1 dim) = (e2 dim)) (RatVecConstr(RatVecPlusAux (e1 values) (e2 values))) (RatZeroVec Zero) ]")

(set-totality-goal "RatVecPlus")
(assume "e^1" "Te1")
(assume "e^2" "Te2")
(elim "Te1")
(elim "Te2")
(assume "eV^1" "TeV1" "eV^2" "TeV2")
(ng #t)
(use "BooleIfTotal")
(use "NatEqTotal")
(use "ListLengthTotal")
(use "TeV2")
(use "ListLengthTotal")
(use "TeV1")
(use "TotalRatVecRatVecConstr")
(use "RatVecPlusAuxTotal")
(use "TeV2")
(use "TeV1")
(use "TotalRatVecRatVecConstr")
(use "TotalListNil")
(save-totality)

(add-program-constant "RatVecDTimesAux" (py "(list rat) => (list rat) => rat"))
(add-computation-rules 
    "RatVecDTimesAux (a::eV1) (b::eV2)" "[if (Lh(a::eV1)=Lh(b::eV2)) ((a*b)+(RatVecDTimesAux eV1 eV2)) (0#1)]"
    "RatVecDTimesAux (Nil rat) eV" "0"
    "RatVecDTimesAux eV (Nil rat)" "0"
    "RatVecDTimesAux (Nil rat) (Nil rat)" "0")


(set-totality-goal "RatVecDTimesAux")
(use "AllTotalElim")
(ind)
(use "AllTotalElim")
(ind)
(ng #t)
(use "RatTotalVar")
(assume "a" "eV1" "IS")
(ng #t)
(use "RatTotalVar")
(assume "a" "eV1" "IH")
(use "AllTotalElim")
(ind)
(ng)
(use "RatTotalVar")
(assume "b" "eV2" "IS")
(ng #t)
(use "BooleIfTotal")
(use "NatEqTotal")
(use "ListLengthTotal")
(use "ListTotalVar")
(use "ListLengthTotal")
(use "ListTotalVar")
(use "RatPlusTotal")
(use "RatTimesTotal")
(use "RatTotalVar")
(use "RatTotalVar")
(use "IH")
(use "ListTotalVar")
(use "RatTotalVar")
(save-totality)


(add-computation-rules "e1 * e2" "[if ((e1 dim)=(e2 dim)) (RatVecDTimesAux (e1 values) (e2 values)) (0#1)]")

(set-totality-goal "RatVecDTimes")
(assume "e^1" "Te1" "e^2" "Te2")
(ng #t)
(use "BooleIfTotal")
(use "NatEqTotal")
(use "ListLengthTotal")
(use "RatVecToListTotal")
(use "Te1")
(use "ListLengthTotal")
(use "RatVecToListTotal")
(use "Te2")
(use "RatVecDTimesAuxTotal")
(use "RatVecToListTotal")
(use "Te1")
(use "RatVecToListTotal")
(use "Te2")
(use "RatTotalVar")
(save-totality)


(add-program-constant "ratListAbsMax" (py "list rat => rat"))
(add-computation-rules
    "ratListAbsMax (Nil rat)" "0#1"
    "ratListAbsMax (a::eV)" "abs(a) max (ratListAbsMax (eV))")


(set-totality-goal "ratListAbsMax")
(assume "eV^" "TeV")
(elim "TeV")
(ng #t)
(use "RatTotalVar")
(assume "a^" "Ta" "eV^2" "TeV2")
(assume "TRateV2")
(use "RatMaxTotal")
(use "RatAbsTotal")
(use "Ta")
(use "TRateV2")
(save-totality)


(add-computation-rules "|_ e" "ratListAbsMax (e values)")

(set-totality-goal "RatVecMaxNorm")
(assume "e^" "Te")
(ng #t)
(use "ratListAbsMaxTotal")
(use "RatVecToListTotal")
(use "Te")
(save-totality)


(add-program-constant "RatVecOneNormAux" (py "(list rat) => rat" )t-deg-zero)
(add-computation-rules 
    "RatVecOneNormAux (Nil rat)" "0"
    "RatVecOneNormAux (a::eV)" "abs(a)+(RatVecOneNormAux eV) ")

    
(set-totality-goal "RatVecOneNormAux")
(assume "eV^" "TeV")
(elim "TeV")
(ng #t)
(use "RatTotalVar")
(assume "a^1" "Ta1" "eV^1" "TeV1" "TrateV")
(ng #t)
(use "RatPlusTotal")
(use "RatAbsTotal")
(use "Ta1")
(use "TrateV")
(save-totality)


(add-computation-rules "||_ e" "RatVecOneNormAux(e values)")

(set-totality-goal "RatVecOneNorm")
(assume "e^" "Te")
(ng #t)
(use "RatVecOneNormAuxTotal")
(use "RatVecToListTotal")
(use "Te")
(save-totality)

(set-goal "all e (0 <= ||_ e)")
(cases)
(ind)
(ng #t) 
(use "Truth")
(assume "a" "eV" "IH")
(ng #t)
(use "RatLeTrans" (pt "RatVecOneNormAux eV"))
(use "IH")
(ng #t)
(inst-with "RatLePlusCancelRInv" (pt "RatVecOneNormAux eV") (pt "0#1") (pt "abs a"))
(ng 2)
(use 2)
(use "Truth")
(save "RatVecOneNormPSD")


(pp (nt (pt "||_ (RatVecConstr ((a)::(b):))")))

(pp (nt (pt "RealLt 0 (||_ (RatVecConstr ((a)::(b):))) (PosS p)")))




(add-program-constant "RatVecNotZeroAux" (py "(list rat)=>boole"))
(add-computation-rules 
    "RatVecNotZeroAux (a::eV)" "[if (0 < abs(a)) (T) (RatVecNotZeroAux(eV)) ]"
    "RatVecNotZeroAux (Nil rat)" "F")

(set-totality-goal "RatVecNotZeroAux")
(use "AllTotalElim")
(ind)
(ng #t)
(use "BooleTotalVar")
(assume "a")
(assume "eV")
(ng #t)
(assume "TL")
(use "BooleIfTotal")
(use "RatLtTotal")
(use "RatTotalVar")
(use "RatTotalVar")
(use "BooleTotalVar")
(use "TL")
(save-totality)


(add-program-constant "RatVecNotZero" (py "ratVec=>boole"))
(add-computation-rules "RatVecNotZero e" "RatVecNotZeroAux (e values)")

(set-totality-goal "RatVecNotZero")
(assume "e^" "Te")
(elim "Te")
(assume "eV^" "TeV")
(ng #t)
(use "RatVecNotZeroAuxTotal")
(use "TeV")
(save-totality)

(set-goal "all n(RatVecNotZero(RatZeroVec n)->F)")
(ind)
(ng #t)
(use "Efq")
(assume "n" "IH")
(ng #t)
(ng "IH")
(use "IH")
(save "RatZeroVecNotZeroCorr")

(set-goal "all e(RatVecNotZeroAux (e values)  -> RatVecNotZero e)")
(cases)
(cases)
(ng #t)
(use "Efq")
(assume "a" "eV")
(ng #t)
(cases (pt "0 < abs a"))
(assume "c1")
(ng #t)
(assume 1)
(use 2)
(assume "nc1")
(ng #t)
(assume 1)
(use 2)
(save "RatVecToListZeroElim0")

; (set-goal "all e(RatVecNotZero e -> RatVecNotZeroAux (lft e vecDeconst))")
; (cases)
; (assume "eV" "RVnZ")
; (ng "RVnZ")
; (ng #t)
; (use "RVnZ")
; (save "ratListToVecZero")

(set-goal "all a(RatVecNotZeroAux(a:) -> 0 < abs a)")
(assume "a")
(ng #t)
(auto)
(save "RatVecNotZeroAuxOneElim0")

(set-goal "all eV(RatVecNotZeroAux eV -> Zero < Lh eV)")
(ind)
(ng #t)
(assume 1)
(use 1)
(assume "a" "eV" "IH")
(ng #t)
(cases (pt "0<abs a"))
(assume "c1")
(ng #t)
(assume 1)
(use 3)
(assume "nc1")
(ng #t)
(assume 1)
(use "Truth")
(save "RatVecNotZeroAuxElim1")

(set-goal "all eV,a(RatVecNotZeroAux eV -> RatVecNotZeroAux(a::eV))")
(assume "eV" "a")
(assume "eVNz")
(ng #t)
(simp "IfOrb")
(simp "eVNz")
(ng #t)
(use "Truth")
(save "RatVecIndElim0")

(add-ids
  (list (list "RatVecValPos" (make-arity (py "ratVec"))))
   '("all e( Zero < e dim-> RatVecNotZero e -> RatVecValPos e)" "RatVecValPosIntro"))

;; move to rat.scm
(set-goal "all a,b((0 < a) orb (0 < b) -> 0 < a max b)")
(cases)
(cases)
(assume "p1" "p2")
(cases)
(cases)
(assume "p3" "p4")
(ng #t)
(assume "useless")
(cases (pt "p3*p2<=p1*p4"))
(assume 1)
(use "Truth")
(assume 1)
(use "Truth")
(assume "p3")
(ng #t)
(assume 1)
(use "Truth")
(assume "p3" "p4")
(ng #t)
(assume 1)
(use "Truth")
(assume "p1")
(cases)
(cases)
(assume "p2" "p3")
(ng #t)
(assume 1)
(use "Truth")
(assume "p2")
(ng #t)
(use "Efq")
(assume "p2" "p3")
(ng #t)
(use "Efq")
(assume "p1" "p2")
(cases)
(cases)
(assume "p3" "p4")
(ng #t)
(assume 1)
(use "Truth")
(assume "p3")
(ng #t)
(use "Efq")
(assume "p3" "p4")
(ng #t)
(use "Efq")
(save "RatMaxLtToOrb")

(set-goal "all c,a,b((c <= a) orb (c <= b) -> c <= a max  b)")
(assume "c" "a" "b")
(cases (pt "c <= a"))
(assume "c1")
(assume 1)
(use "RatLeTrans" (pt "a"))
(use "c1")
(use "RatMaxUB1")
(assume "nc1")
(cases (pt "c <= b"))
(assume "c2")
(assume 1)
(use "RatLeTrans" (pt "b"))
(use "c2")
(use "RatMaxUB2")
(assume "nc2")
(ng #t)
(use "Efq")
(save "RatMaxLeToOrb")


(set-goal "all eV,a(0 < Lh eV -> 0<ratListAbsMax eV -> 0 < ratListAbsMax(a::eV))")
(ind)
(assume "a")
(ng #t)
(use "Efq")
(assume "a" "eV" "IH" "b" "LenNz" "LisMax")
(ng #t)
(use "RatMaxLtToOrb")
(simp "LisMax")
(use "Truth")
(save "RatListMaxIndElim")

(set-goal "all e(RatVecValPos e -> 0 < |_ e)")
(assume "e")
(elim)
(cases)
(ind)
(assume "LenEqDim")
(ng #t)
(use "Efq")
(assume "a")
(assume "eV")
(assume "IH")
(assume "dimNz" "VecNz")
(cases (pt "0<abs a"))
(assume "case 1")
(ng #t)
(use "RatMaxLtToOrb")
(simp "case 1")
(use "Truth")
(assume "case 2")
(ng #t)
(use "RatMaxLtToOrb")
(simp "case 2")
(ng #t)
(ng "IH")
(use "IH")
(ng)
(simphyp "VecNz" "case 2")
(ng 6)
(use "RatVecNotZeroAuxElim1")
(use 6)
(ng)
(simphyp "VecNz" "case 2")
(ng 6)
(use 6)
(save "RatVecMaxNormPD")

;; move to rat
; (set-goal "all a,b(0 < abs a andb 0 < b -> 0 < abs a + b) ")
; (cases)
; (cases)
; (assume "p1" "p2")
; (cases)
; (cases)
; (assume "p3" "p4")
; (ng #t)
; (strip)
; (use "Truth")
; (assume "p3")
; (ng #t)
; (strip)
; (use "Truth")
; (assume "p3" "p4")
; (ng #t)
; (use "Efq")
; (assume "p1")
; (cases)
; (cases)
; (assume "p2" "p3")
; (ng #t)
; (assume 1)
; (use "Truth")
; (assume "p2")
; (ng #t)
; (use "Efq")
; (assume "p2" "p3")
; (ng #t)
; (use "Efq")
; (assume "p1" "p2")
; (cases)
; (cases)
; (assume "p3" "p4")
; (ng #t)
; (assume 1)
; (use "Truth")
; (assume "p3")
; (ng #t)
; (assume 1)
; (use "Truth")
; (assume "p3" "p4")
; (ng #t)
; (use "Efq")
; (save "RatPlusSplit2")


; (set-goal "all a,b(0 < abs a -> 0 < b -> 0 < abs a + b) ")
; (cases)
; (cases)
; (assume "p1" "p2")
; (cases)
; (cases)
; (assume "p3" "p4")
; (ng #t)
; (strip)
; (use "Truth")
; (assume "p3")
; (ng #t)
; (strip)
; (use "Truth")
; (assume "p3" "p4")
; (ng #t)
; (assume 1)
; (use "Efq")
; (assume "p1")
; (cases)
; (cases)
; (assume "p2" "p3")
; (ng #t)
; (strip)
; (use "Truth")
; (assume "p2")
; (ng #t)
; (use "Efq")
; (assume "p2" "p3")
; (ng #t)
; (use "Efq")
; (assume "p1" "p2")
; (cases)
; (cases)
; (assume "p3" "p4")
; (ng #t)
; (strip)
; (use "Truth")
; (assume "p3")
; (ng #t)
; (strip)
; (use "Truth")
; (assume "p3" "p4")
; (ng #t)
; (assume 1)
; (use "Efq")
; (save "RatPlusSplit")

;; move to rat.scm
(set-goal "all a,b( abs a + abs b == abs(abs a + abs b))")
(cases)
(cases)
(assume "p1" "p2")
(cases)
(cases)
(assume "p3" "p4")
(ng #t)
(use "Truth")
(assume "p3")
(ng #t)
(use "Truth")
(assume "p3" "p4")
(ng #t)
(use "Truth")
(assume "p1")
(cases)
(cases)
(assume "p2" "p3")
(ng #t)
(use "Truth")
(assume "p2")
(ng #t)
(use "Truth")
(assume "p2" "p3")
(ng #t)
(use "Truth")
(assume "p1" "p2")
(cases)
(cases)
(assume "p3" "p4")
(ng #t)
(use "Truth")
(assume "p3")
(ng #t)
(use "Truth")
(assume "p3" "p4")
(ng #t)
(use "Truth")
(save "RatAbsElim0")


(set-goal "all eV(RatVecOneNormAux eV == abs(RatVecOneNormAux eV))")
(ind)
(ng #t)
(use "Truth")
(assume "a" "eV")
(assume "IH")
(ng #t)
(simprat "IH")
(ng #t)
(simprat "RatAbsElim0")
(ng #t)
(use "Truth")
(save "RatVecOneNormEqvAbs")

;; move to rat.scm
(set-goal "all a(a = 0 -> (0 < abs a->F))")
(cases)
(cases)
(assume "p1" "p2")
(ng #t)
(use "Efq")
(assume "p")
(ng #t)
(assume 1)
(use "Efq")
(assume "p1" "p2")
(ng #t)
(use "Efq")
(save "RatEqZeroToNotLtRatAbs")

;; move to rat.scm
(set-goal "all a((0 < abs a -> F)-> a == 0)")
(cases)
(cases)
(assume "p1" "p2")
(ng #t)
(assume 1)
(cut "T")
(use 1)
(use "Truth")
(assume "p1")
(ng #t)
(strip)
(use "Truth")
(assume "p1" "p2")
(ng #t)
(assume 1)
(cut "T")
(use 1)
(use "Truth")
(save "RatAbsLtZeroToZero")

(set-goal "all e(RatVecValPos e -> 0 < ||_e)")
(assume "e")
(elim)
(cases)
(ind)
(ng #t)
(assume 1)
(use "Efq")
(assume "a" "eV" "IH")
(assume "dimNZ")
(ng #t)
(cases (pt "0 < abs a"))
(assume "case1")
(ng #t)
(assume "useless")
(use "RatLtLeTrans" (pt "abs a"))
(use "case1")
(ng #t)
(inst-with "RatLePlusCancelLInv" (pt "abs a") (pt "(0#1)") (pt "RatVecOneNormAux eV"))
(ng 6)
(use 6)
(use-with "RatVecOneNormPSD" (pt "RatVecConstr eV"))
(assume "case2")
(ng #t)
(assume "NZeV")
(simprat (pf "abs a == (0#1)"))
(ng #t)
(use "IH")
(ng #t)
(use "RatVecNotZeroAuxElim1")
(use "NZeV")
(use "NZeV")
(use "RatLeAntiSym")
(use "RatNotLtToLe")
(use "case2")
(use "RatNotLtToLe")
(ng #t)
 (assert "all a (abs a < 0 ->F)")
  (cases)
  (cases)
  (assume "p" "q")
  (ng #t)
  (use "Efq")
  (assume "p")
  (ng #t)
  (use "Efq")
  (assume "p" "q")
  (ng #t)
  (use "Efq")
 (assume "Absurd")
(use "Absurd")
(save "RatVecOneNormPD")

(set-goal "all eV1,eV2(RatVecPlusAux eV1 eV2 = RatVecPlusAux eV2 eV1)")
(ind)
(cases)
(ng #t)
(use "Truth")
(assume "a" "eV")
(ng #t)
(use "Truth")
(assume "a1" "eV1" "IH")
(cases)
(ng #t)
(use "Truth")
(assume "a2" "eV2")
(ng #t)
(simp "NatEqSym")
(cases (pt "(ListLength rat)eV2=(ListLength rat)eV1"))
(assume "c1")
(ng #t)
(split)
(use "RatPlusComm")
(use "IH")
(assume "nc1")
(ng #t)
(use "Truth")
(save "RatVecPlusAuxComm")

(set-goal "all e1( e1 dim = (~ e1) dim)")
(cases)
(ind)
(ng #t)
(use "Truth")
(assume "a" "eV" "IH")
(ng #t)
(use "IH")
(save "RatVecUMinusDim")

(set-goal "all eV(Lh(RatVecUMinusAux eV) = Lh eV)")
(ind)
(ng #t)
(use "Truth")
(assume "a" "eV" "IH")
(ng #t)
(use "IH")
(save "RatVecUMinusAuxLh")

(set-goal "all eV,a(ratListAbsMax(RatVecSTimesAux a(RatVecPlusAux eV (RatVecUMinusAux eV))) == (0#1))")
(ind)
(assume "a")
(ng #t)
(use "Truth")
(assume "a" "eV")
(assume "IH")
(ng #t)
(assume "b")
(simp "RatVecUMinusAuxLh")
(ng #t)
(use "RatLeAntiSym")
(use "RatMaxLUB")
(simprat (pf "a+ ~a == (0#1) "))
(use "Truth")
(use "Truth")
(use "RatEqvToLe")
(use "IH")
(simprat "RatMaxComm")
(simprat "RatMaxEqvCancelR" (pt "(0#1)"))
(simprat "RatMaxComm")
(simprat "RatMaxEqvCancelR" (pt "(0#1)"))
(use "Truth")
(simprat (pf "a+ ~a == (0#1)"))
(simprat (pf "b*0==0"))
(use "Truth")
(use "Truth")
(use "Truth")
(use "IH")
(save "RatLisMaxSTimesAuxeVUMinIdEqZero")

;; move to rat.scm

(set-goal "all a abs(a*0)==0")
(cases)
(cases)
(assume "p" "p0")
(ng #t)
(auto)
(add-rewrite-rule "abs(a*0)==0" "True")

(set-goal "all e1,a(|_(RatVecSTimes a ( e1 +(~ e1))) == (0#1))")
(cases)
(cases)
(assume "a")
(ng #t)
(use "Truth")
(assume "a" "eV")
(assume "b")
(ng #t)
(simp "RatVecUMinusAuxLh")
(ng #t)
(use "RatLeAntiSym")
(use "RatMaxLUB")
(simprat (pf "a+ ~a == (0#1)"))
(use "Truth")
(use "Truth")
(use "RatEqvToLe")
(use "RatLisMaxSTimesAuxeVUMinIdEqZero")
(simprat "RatMaxEqvCancelR" (pt "(0#1)"))
(simprat "RatMaxComm")
(simprat "RatMaxEqvCancelR" (pt "(0#1)"))
(use "Truth")
(simprat "RatLisMaxSTimesAuxeVUMinIdEqZero")
(use "Truth")
(simprat (pf "a+ ~a == (0#1)"))
(use "Truth")
(use "Truth")
(save "RatVecMaxNormSTimeseUMinIdEqZero")

(set-goal "all eV,b(Lh (RatVecSTimesAux b eV) = (Lh eV))")
(ind)
(assume "a")
(ng #t)
(use "Truth")
(assume "a" "eV" "IH" "b" )
(ng #t)
(use "IH")
(save "RatVecSTimesAuxLhEqLhList")


(set-goal "all e,a(( RatVecSTimes a e) dim =  e dim)")
(cases)
(ind)
(assume "a")
(ng #t)
(use "Truth")
(assume "a1" "eV1" "IH" "a")
(ng #t)
(use "IH")
(save "RatVecSTimesDimEqVecDim")
(add-rewrite-rule "( RatVecSTimes a e) dim" "e dim")

(set-goal "all eV1,eV2(Lh eV1 = Lh eV2 -> Lh(RatVecPlusAux eV1 eV2) = Lh eV1)" )
(ind)
(ng #t)
(assume "eV" "Eq")
(use "Truth")
(assume "a" "eV" "IH")
(cases)
(ng #t)
(assume "Con")
(use "Con")
(assume "a1" "eV1" "Eq")
(ng #t)
(ng "Eq")
(simp "Eq")
(ng #t)
(use "IH")
(use "Eq")
(save "RatVecPlusAuxLhEqVecLh")


(add-program-constant "RatVecListTimesAux" (py "(list rat)=>(list rat)=>(list rat)"))
(add-computation-rules  "RatVecListTimesAux (a::eV1) eV2" "(a*(Head eV2))::(RatVecListTimesAux eV1 (Tail eV2))"
                        "RatVecListTimesAux (Nil rat) eV" "(Nil rat)"
                        "RatVecListTimesAux (Nil rat) (Nil rat)" "(Nil rat)")
(set-totality-goal "RatVecListTimesAux")
(use "AllTotalElim")
(ind)
(assume "eV^2" "TeV2")
(ng #t)
(use "TotalListNil")
(assume "a1" "eV3" "IHS1")
(ng #t)
(assume "eV^2" "TeV2")
(use "TotalListCons")
(use "RatTimesTotal")
(use "RatTotalVar")
(use "ListHeadTotal")
(use "TeV2")
(use "IHS1")
(use "ListTailTotal")
(use "TeV2")
(save-totality)

(set-goal "all eV1,eV2(Lh eV1 = Lh eV2 -> Lh(RatVecListTimesAux eV1 eV2) = Lh eV1)")
(ind)
(assume "eV")
(ng #t)
(assume 1)
(use "Truth")
(assume "a" "eV" "IH")
(assume "eV2")
(ng #t)
(assume "lenEq")
(inst-with "IH" (pt "Tail eV2"))
(use 3)
  (assert "all eV,n(Succ n = Lh eV -> n = Lh (Tail eV))")
    (ind)
    (assume "n")
    (ng #t)
    (use "Efq")
    (assume "b" "eV1" "IHb")
    (assume "n1")
    (ng #t)
    (assume 1)
    (use 5)
  (assume "ass1")
(use "ass1")
(use "lenEq")
(save "RatVecListTimesAuxLhEqeV1")

(set-goal "all e((0#1) <= |_e)")
(cases)
(ind)
(ng #t)
(use "Truth")
(assume "a" "eV" "IH")
(ng #t)
(use "RatMaxLeToOrb")
(use "Truth")
(save "RatVecMaxNormPSD")


;; move to list.scm
(set-goal "all eV,n(n < Lh eV -> (n = Zero -> F)-> (n thof eV) eqd (Pred n thof (Tail eV)))")
(ind)
(ng #t)
(assume "n")
(use "Efq")
(assume "a" "eV" "IH")
(cases)
(ng #t)
(assume 1 1)
(use "Efq")
(use 3)
(use "Truth")
(assume "n" "lim1" "case")
(ng #t)
(use "InitEqD")
(save "RatListThofShift")

(set-goal "all eV1,n(n < Lh eV1 -> abs(eV1__n) <= ratListAbsMax eV1)")
(ind)
(assume "n")
(ng #t)
(use "Efq")
(assume "a" "eV" "IH")
(cases)
(ng #t)
(assume 1)
(use "RatMaxUB1")
(assume "n")
(ng #t)
(assume "Lim")
(use "RatLeTrans" (pt "ratListAbsMax eV"))
(use "IH")
(use "Lim")
(use "RatMaxUB2")
(save "RatListMaxLeThofeV")

(set-goal "all eV1,eV2,n(Zero < Lh eV1 -> n < Lh eV1 -> Lh eV1 = Lh eV2 -> abs ((eV1__n)+(eV2__n)) <= ratListAbsMax(RatVecPlusAux eV1 eV2))")
(ind)
(assume "eV" "n")
(ng #t)
(use "Efq")
(assume "a" "eV1" "IH")
(cases)
(assume "n")
(ng #t)
(assume 1 1)
(use "Efq")
(assume "b" "eV2")
(cases)
(ng #t)
(assume "Taut1" "Taut2" "LenEq")
(simp  "LenEq")
(ng #t)
(use "RatMaxUB1")
(assume "n")
(ng #t)
(cases (pt "Zero = Lh eV1"))
(assume "c1")
(simp (pf "eV1 eqd (Nil rat)"))
(ng #t)
(assume "Taut1")
(use "Efq")
(use "ListLengthEqZeroToEmptyList")
(use "NatLeToNotLt")
(ng #t)
(simp "c1")
(use "Truth")
(assume "nc1")
(assume "Taut" "LenLim" "LenEq")
(simp "LenEq")
(ng #t)
(use "RatMaxLeToOrb")
(simp "IH")
(use "Truth")
(use "LenEq")
(use "LenLim")
(use "NatNotLeToLt")
(ng #t)
(simp "NatEqSym")
(use "nc1")
(save "RatRatListThofSumLeMaxList")

(set-goal "all eV1,eV2,n(Zero < Lh eV1 -> n < Lh eV1 -> Lh eV1 = Lh eV2 -> ((n thof eV1) + (n thof eV2)) = (n thof (RatVecPlusAux eV1 eV2)))")
(ind)
(assume "eV2")
(assume "n")
(ng #t)
(use "Efq")
(assume "a" "eV1" "IH")
(cases)
(assume "n")
(ng #t)
(assume 1 1)
(use "Efq")
(assume "b" "eV2")
(cases)
(ng #t)
(assume "Taut1" "Taut2" "LenEq")
(simp "LenEq")
(ng #t)
(use "Truth")
(assume "n")
(ng #t)
(assume "Taut" "LenLim" "LenEq")
(simp "LenEq")
(ng #t)
(use "IH")
  (assert "all n,m(n<m -> Zero < m)")
    (cases)
    (assume "m")
    (assume "Cond")
    (use "Cond")
    (assume "n1" "m" "Cond")
    (use "NatLtTrans" (pt "Succ n1"))
    (use "Truth")
    (use "Cond")
  (assume "Ass1")
(use "Ass1" (pt "n"))
(use "LenLim")
(use "LenLim")
(use "LenEq")
(save "RatVecListPlusThofDist")

(set-goal "all eV1,n(Zero < Lh eV1 -> n < Lh eV1 -> (n thof (RatVecUMinusAux eV1)) = (~(n thof eV1)))")
(ind)
(assume "n")
(ng #t)
(use "Efq")
(assume "a" "eV" "IH")
(cases)
(assume "Taut1" "LenLim")
(ng #t)
(use "Truth")
(assume "n" "Taut" "LenLim")
(ng #t)
(use "IH")
(ng "LenLim")
  (assert "all n,m(n<m -> Zero < m)")
    (cases)
    (assume "m")
    (assume "Cond")
    (use "Cond")
    (assume "n1" "m" "Cond")
    (use "NatLtTrans" (pt "Succ n1"))
    (use "Truth")
    (use "Cond")
  (assume "Ass1")
(use "Ass1" (pt "n"))
(use "LenLim")
(use "LenLim")
(save "RatVecListUMinusEqThof")

(set-goal "all eV1 (ratListAbsMax eV1 = abs(ratListAbsMax eV1))")
(ind)
(ng #t)
(use "Truth")
(assume "a" "eV" "IH")
(ng #t)
(simp (pf "abs(abs a  max ratListAbsMax eV) = abs a max ratListAbsMax eV"))
(use "Truth")
(use "RatAbsId")
(use "RatLeTrans" (pt "ratListAbsMax eV"))
(inst-with-to "RatVecMaxNormPSD" (pt "RatVecConstr eV") "PSD")
(ng "PSD")
(use "PSD")
(use "RatMaxUB2")
(save "RatVecAbsListAbsMaxEqId")
;;(add-rewrite-rule "ratListAbsMax eV1" "abs (ratListAbsMax eV1)")

;(add-rewrite-rule "all eV1 (ratListAbsMax eV1 = abs(ratListAbsMax eV1))" "True")


; (set-goal "all e1,e2,a(Zero < e1 dim -> e1 dim = e2 dim-> |_((RatVecSTimes a e1)+(RatVecSTimes a e2)) == |_(RatVecSTimes a (e1+e2)))")
; (assert "all a,b,c(c*(a+b) == c*a+c*b)")
;     (assume "a""b" "c")
;     (simp-with "RatTimesComm" (pt "c") (pt "a+b"))
;     (simp-with "RatTimesComm" (pt "c") (pt "a"))
;     (simp-with "RatTimesComm" (pt "c") (pt "b"))
;     (use "RatTimesPlusDistrLeft")
;   (assume "Assertion1")
; (cases)
; (ind)
; (cases)
; (assume "eV2")
; (assume "a")
; (ng #t)
; (assume 1 1)
; (use "Truth")
; (assume "a" "eV1" "IH")
; (cases)
; (cases)
; (assume "c")
; (ng #t)
; (assume "Taut1" "LenEq")
; (use "Truth")
; (assume "b" "eV2" "c")
; (cases (pt "Zero = Lh eV1"))
; (assume "c1")
; (simp (pf "eV1 eqd (Nil rat)"))
; (ng #t)
; (assume "Taut1" "LenEq")
; (simp (pf "eV2 eqd (Nil rat)"))
; (ng #t)
; (use "RatLeAntiSym")
; (use "RatMaxLUB")
; (simprat (pf "c*a+c*b == c*(a+b)"))
; (use "RatMaxUB1")
; (simp "RatEqvSym")
; (use "Truth")
; (use "Assertion1")
; (use "RatMaxUB2")
; (use "RatMaxLUB")
; (simprat (pf "c*(a+b) == c*a+c*b"))
; (use "RatMaxUB1")
; (use "Assertion1")
; (use "RatMaxUB2")
; (use "ListLengthEqZeroToEmptyList")
; (use "NatLeToNotLt")
; (ng #t)
; (simp "LenEq")
; (use "Truth")
; (use "ListLengthEqZeroToEmptyList")
; (use "NatLeToNotLt")
; (simp "c1")
; (use "Truth")
; (assume "nc1")
; (assume "DimLim" "LenEq")
; (ng #t)
; (simp "RatVecSTimesAuxLhEqLhList")
; (simp "RatVecSTimesAuxLhEqLhList")
; (simp "LenEq")
; (use "RatLeAntiSym")
; (use "RatMaxLUB")
; (simprat (pf "c*a+c*b == c*(a+b)"))
; (use "RatMaxUB1")
; (use "RatEqvSym")
; (use "Assertion1")
; (inst-with-to "IH" (pt "RatVecConstr eV2") (pt "c") "IHTrans")
; (ng "IHTrans")
; (simphyp-with-to "IHTrans" (pf "(ListLength rat)(RatVecSTimesAux c eV1)=
;                     (ListLength rat)(RatVecSTimesAux c eV2)") "IHTrans1")
; (simphyp-with-to "IHTrans1" "LenEq" "IHTrans2")
; (ng "IHTrans2")
; (simprat "IHTrans2")
; (use "RatMaxUB2")
; (use "Truth")
; (use "NatNotLeToLt")
; (ng #t)
; (simp "NatEqSym")
; (use "nc1")
; (ng "LenEq")
; (simp "RatVecSTimesAuxLhEqLhList")
; (simp "RatVecSTimesAuxLhEqLhList")
; (simp "LenEq")
; (use "Truth")
; (ng #t)
; (use "RatMaxLUB")
; (simprat (pf "c*(a+b) == c*a+c*b"))
; (use "RatMaxUB1")
; (use "Assertion1")
; (inst-with-to "IH" (pt "RatVecConstr eV2") (pt "c") "IHTrans")
; (ng "IHTrans")
; (simphyp-with-to "IHTrans" (pf "(ListLength rat)(RatVecSTimesAux c eV1)=
;                     (ListLength rat)(RatVecSTimesAux c eV2)") "IHTrans1")
; (simphyp-with-to "IHTrans1" "LenEq" "IHTrans2")
; (ng "IHTrans2")
; (simprat "<-" "IHTrans2")
; (use "RatMaxUB2")
; (use "Truth")
; (use "NatNotLeToLt")
; (ng #t)
; (simp "NatEqSym")
; (use "nc1")
; (simp "RatVecSTimesAuxLhEqLhList")
; (simp "RatVecSTimesAuxLhEqLhList")
; (use "LenEq")
; (save "RatVecSTimesPlus")

(set-goal "all a((0#1)*a == (0#1))")
(cases)
(ng #t)
(strip)
(use "Truth")
(save "RatTimesZeroEqZero")
(add-rewrite-rule "(0#1)*a==(0#1)" "True")






(set-goal "all eV,a(ratListAbsMax(RatVecSTimesAux a eV) == abs a*(ratListAbsMax eV))")
(ind)
(assume "a")
(ng #t)
(use "RatEqvSym")
(use "Truth")
(assume "a" "eV" "Ih" "b")
(ng #t)
(use "RatLeAntiSym")
(use "RatMaxLUB")
(simp "RatAbsTimes")
(cases (pt "b == (0#1)"))
(assume "c1")
(simprat "c1")
(ng #t)
(simprat (pf "0*abs a==0"))
(simprat (pf "0*(abs a max ratListAbsMax eV)==0"))
(auto)
(assume "nc1")
(use "RatLeTimesCancelLInv")
(use "Truth")
(use "RatMaxUB1")
(simprat "Ih")
(cases (pt "b == (0#1)"))
(assume "c1")
(simprat "c1")
(ng #t)
(simprat (pf "0*ratListAbsMax eV==0"))
(simprat (pf "0*(abs a max ratListAbsMax eV)==0"))
(auto)
(assume "nc1")
(use "RatLeTimesCancelLInv")
(use "Truth")
(use "RatMaxUB2")
(simprat-with "RatMaxComm" (pt "abs(b*a)") (pt "ratListAbsMax(RatVecSTimesAux b eV)"))
(inst-with "RatMaxEqvCancelR" (pt "ratListAbsMax(RatVecSTimesAux b eV)") (pt "abs(b*a)") (pt "abs b*ratListAbsMax eV"))
(simprat 2)
(inst-with "RatLeTimesCancelLInv" (pt "abs b") (pt "abs a max ratListAbsMax eV") (pt "ratListAbsMax eV max abs(b*a)"))
(inst-with-to "RatMaxComm" (pt "abs b*ratListAbsMax eV") (pt "abs(b*a)") "MaxComm1")
(simprat "MaxComm1")
(inst-with-to "RatMaxEqvCancelR" (pt "abs(b*a)") (pt "abs b*ratListAbsMax eV") (pt "abs b * abs a") "MaxDistr1")
(simprat "MaxDistr1")
(cases (pt "b == (0#1)"))
(assume "c1")
(simprat (pf "abs b*(abs a max ratListAbsMax eV) == (0#1)*(abs a max ratListAbsMax eV)"))
(inst-with-to "RatMaxEqvCancelR" (pt "(abs b*abs a)") (pt "abs b*ratListAbsMax eV") (pt "abs (0#1)*abs b") "MaxEqv1")
(simprat "MaxEqv1")
(simprat (pf "0*(abs a max ratListAbsMax eV)==0"))
(ng #t)
(simprat (pf "0*abs b==0"))
(use "RatMaxUB1")
(auto)
(simprat "c1")
(use "Truth")
(simprat "c1")
(use "Truth")
(assume "nc1")
(inst-with-to "RatMaxTimesDistr" (pt "abs b") (pt "abs a") (pt "ratListAbsMax eV") "MaxDistr")
(simprat "MaxDistr")
(use "RatLeTimesCancelLInv")
(use "Truth")
(use "Truth")
(use "RatNZeroToLtAbs")
(use "nc1")
(simp "RatAbsTimes")
(use "Truth")
(use "Ih")
(save "RatVecListAbsMaxSTimes")

(set-goal "all a,e(|_(RatVecSTimes a e) == abs a* |_e)")
(assume "a")
(cases)
(assume "eV")
(ng #t)
(use "RatVecListAbsMaxSTimes")
(save "RatVecMaxNormSTimes")

;;(add-var-name "ap" (py "alpha"))
;; (add-var-name "aps" (py "(list alpha)"))

(set-goal "all xl1,xl2,xls1,xls2((xl1 eqd xl2) -> (xls1 eqd xls2) -> ((xl1::xls1) eqd (xl2::xls2)))")
(strip)
(simp 1)
(simp 2)
(use "InitEqD")
(save "ListConstEqdCases")

(set-goal "all eV1,eV2(eV1 eqd eV2 -> (RatVecConstr eV1) eqd (RatVecConstr eV2))")
(ng #t)
(strip)
(simp 1)
(use "InitEqD")
(save "RatVecEqdListToConstr")


(set-goal "all eV1,a(RatVecUMinusAux(RatVecSTimesAux a eV1) eqd RatVecSTimesAux a (RatVecUMinusAux eV1))")
(ind)
(assume "a")
(ng #t)
(use "InitEqD")
(assume "a" "eV" "IH")
(assume "b")
(ng #t)
(use "ListConstEqdCases")
(use "InitEqD")
(use "IH")
(save "RatVecUMinusSTimesEqd")

(set-goal "all e3( Zero < Lh (e3 values) -> |_e3 == (Head(e3 values)) max (|_ e3))")
(cases)
(ind)
(ng #t)
(use "Efq")
(assume "a" "eV1")
(assume "IH")
(ng #t)
(assume" Taut")
(use "RatLeAntiSym")
(use "RatMaxUB2")
(use "RatMaxLUB")
(use "RatLeTrans" (pt "abs a"))
(use "Truth")
(use "RatMaxUB1")
(use "Truth")
(save "RatVecMaxNormToMax")

(set-goal "Lh(RatVecUMinusAux eV) = Lh eV")
(ind)
(ng #t)
(use "Truth")
(assume "a" "eV")
(assume "IH")
(ng #t)
(use "IH")
(save "RatVecUMinusAuxLhId")


(set-goal "all e1,e2( e1 dim = e2 dim -> e1+ e2+  ~e2 == e1)")
(cases)
(ind)
(cases)
(cases)
(ng #t)
(assume 1)
(use 1)
(assume "a" "eV2")
(ng #t)
(assume 1)
(use "Truth")
(assume "a" "eV1" "IH")
(cases)
(cases)
(ng #t)
(assume 1)
(use 2)
(assume "b" "eV2")
(ng #t)
(assume "LenEq")
(simp "LenEq")
(ng #t)
(simp "RatVecPlusAuxLhEqVecLh")
(simp-with "RatVecUMinusAuxLhId" (pt "eV2"))
(simp "LenEq")
(ng #t)
(simp "RatVecPlusAuxLhEqVecLh")
(simp "RatVecPlusAuxLhEqVecLh")
(ng #t)
(simp (pf "a+b+ ~b==a"))
(ng #t)
(inst-with "IH" (pt "RatVecConstr eV2"))
(simphyp-with 3 (pf "(ListLength rat)eV1=
                              (ListLength rat)(RatVecConstr eV2) values"))
(ng 4)
(simphyp-with 4 (pf "(ListLength rat)(RatVecPlusAux eV1 eV2)=(ListLength rat)(RatVecUMinusAux eV2)"))
(ng 5)
(simphyp-with 5 (pf "(ListLength rat)(RatVecPlusAux(RatVecPlusAux eV1 eV2)(RatVecUMinusAux eV2))=(ListLength rat)eV1"))
(ng 6)
(use 6)
(use "Truth")
(simp "RatVecPlusAuxLhEqVecLh")
(simp "RatVecPlusAuxLhEqVecLh")
(use "Truth")
(simp "LenEq")
(use "Truth")
(ng #t)
(simp "RatVecPlusAuxLhEqVecLh")
(simp "RatVecUMinusAuxLhId")
(use "LenEq")
(use "LenEq")
(simp "RatVecPlusAuxLhEqVecLh")
(simp "RatVecUMinusAuxLhId")
(use "LenEq")
(use "LenEq")
(ng #t)
(use "LenEq")
(simp "RatPlusComm")
(ng #t)
(simp "RatPlusComm")
(ng #t)
(simprat (pf "b+ ~b == (0#1)"))
(use "Truth")
(use "Truth")
(use "LenEq")
(ng #t)
(simp "RatVecUMinusAuxLhId")
(simp "RatVecPlusAuxLhEqVecLh")
(use "LenEq")
(use "LenEq")
(use "LenEq")
(save "RatVecPlusMinusElim")


(set-goal "all e1,e2,e3(e1==e2 -> e2==e3 -> e1==e3)")
(cases)
(ind)
(cases)
(cases)
(cases)
(cases)
(ng #t)
(assume 1 1)
(use 1)
(assume "a" "eV")
(ng #t)
(assume 1)
(use "Efq")
(assume "b" "eV")
(cases)
(cases)
(ng #t)
(use "Efq")
(assume "c" "eV3")
(ng #t)
(use "Efq")
(assume "a" "eV")
(assume "IH")
(cases)
(cases)
(cases)
(cases)
(ng #t)
(use "Efq")
(assume "c" "eV3")
(ng #t)
(use "Efq")
(assume "b" "eV2")
(cases)
(cases)
(ng #t)
(assume 1)
(use "Efq")
(assume "c" "eV3")
(ng #t)
(cases (pt "Lh eV = Lh eV2"))
(assume "C1")
(ng #t)
(simp "C1")
(cases (pt "Lh eV2 = Lh eV3"))
(assume "C2")
(ng #t)
(cases (pt "a==b"))
(assume "C3")
(ng #t)
(cases (pt "b==c"))
(assume "C4")
(ng #t)
(assume 1 1)
(assert "a==c")
(simprat "C3")
(use "C4")
(assume "A1")
(simp "A1")
(ng #t)
(inst-with "IH" (pt "RatVecConstr eV2") (pt "RatVecConstr eV3"))
(ng 9)
(simphyp-with 9 "C1")
(simphyp-with 10 "C2")
(simphyp-with 11 (pf "Lh eV = Lh eV3"))
(ng 12)
(use 12)
(use 6)
(use 7)
(simp "C1")
(use "C2")
(assume "nC4")
(ng #t)
(assume 1)
(use "Efq")
(assume "nC3")
(ng #t)
(use "Efq")
(assume "nC2")
(ng #t)
(assume 1 1)
(use 5)
(assume "nc1")
(ng #t)
(use "Efq")
(save "RatVecEqvTrans")

(set-goal "all e1,e2,e3,e4(e1==e2 -> e3==e4 -> (e1==e3)=(e2==e4))")
(cases)
(ind)
(cases)
(cases)
(cases)
(cases)
(cases)
(cases)
(ng #t)
(assume 1 1)
(use 1)
(ng #t)
(assume "b" "eV")
(assume 1 1)
(use 2)
(assume "a3" "eV3")
(cases)
(cases)
(ng #t)
(assume 1 1)
(use 2)
(assume "a4" "eV4")
(ng #t)
(assume 1 1)
(use "Truth")
(assume "a2" "eV2")
(ng #t)
(assume "e3" "e4")
(use "Efq")
(assume "a1" "eV1" "IH")
(cases)
(cases)
(ng #t)
(assume "e3" "e4")
(use "Efq")
(assume "a2" "eV2")
(ng #t)
(cases)
(cases)
(ng #t)
(cases)
(cases)
(ng #t)
(assume 1 1)
(use "Truth")
(assume "a4" "eV4")
(ng #t)
(assume 1)
(use "Efq")
(assume "a3" "eV3")
(cases)
(cases)
(ng #t)
(assume 1)
(use "Efq")
(assume "a4" "eV4")
(ng #t)
(cases (pt "Lh eV1 = Lh eV2"))
(assume "C1")
(cases (pt "Lh eV3 = Lh eV4"))
(assume "C2")
(cases (pt "Lh eV1 = Lh eV3"))
(assume "C3")
(assert "Lh eV2 = Lh eV4")
(simp "<-" "C1")
(simp "<-" "C2")
(use "C3")
(assume "A1")
(cases (pt "a1==a2"))
(cases (pt "a3==a4"))
(cases (pt "a1==a3"))
(assume "C4")
(assume "C5")
(assume "C6")
(assert "a2==a4")
(simprat "<-" "C6")
(simprat "<-" "C5")
(use "C4")
(assume "A2")
(simp "A1")
(simp "A2")
(ng #t)
(inst-with "IH"
  (pt "RatVecConstr eV2")
  (pt "RatVecConstr eV3")
  (pt "RatVecConstr eV4"))
(ng 10)
(simphyp-with 10 "C1")
(simphyp-with 11 "C2")
(simphyp-with 12 "C3")
(simphyp-with 13 "A1")
(ng 14)
(use 14)
(assume "nC6")
(ng #t)
(assume "C4" "C5")
(assume 1 1)
(assert "a2==a4 -> F")
(assume 1)
(use "nC6")
(simprat "C4")
(simprat "C5")
(use 11)
(assume "A2")
(simp "A2")
(ng #t)
(use "Truth")
(assume "nC6")
(assume "C5")
(ng #t)
(assume 1)
(use "Efq")
(assume "nC3")
(ng #t)
(use "Efq")
(assume "nC3")
(ng #t)
(assert "Lh eV2 = Lh eV4 -> F")
(assume 1)
(use "nC3")
(simp "C2")
(simp "C1")
(use 5)
(assume "nC4")
(simp "nC4")
(ng #t)
(assume 1 1)
(use "Truth")
(assume "nC2")
(ng #t)
(assume 1)
(use "Efq")
(assume "nC1")
(ng #t)
(use "Efq")
(save "RatVecEqvCompat")

(set-goal "all e (e==e)")
(cases)
(ind)
(ng #t)
(use "Truth")
(assume "a" "rls")
(assume "Ih")
(ng #t)
(ng "Ih")
(use "Ih")
(save "RatVecEqvRefl")

(add-rewrite-rule "e==e" "True")

(set-goal "all rls RatVecEqvAux rls rls")
(ind)
(ng #t)
(use "Truth")
(assume "a" "rls")
(assume "Ih")
(ng #t)
(ng "Ih")
(use "Ih")
(save "RatVecEqvAuxRefl")


(add-rewrite-rule "RatVecEqvAux rls rls" "True")

(set-goal "all e1,e2,a(e1 dim = e2 dim -> (RatVecSTimes a (e1 + e2 + ~e2))==(RatVecSTimes a e1))")
(cases)
(ind)
(cases)
(cases)
(assume "a")
(ng #t)
(assume 1)
(use 1)
(assume "a2" "eV2" "a")
(ng #t)
(assume 1)
(use "Truth")
(assume "a1" "eV1" "IH")
(cases)
(cases)
(assume "a")
(ng #t)
(assume 1)
(use 2)
(assume "a2" "eV2" "a")
(assume "LenEq")
(ng #t)
(simp "LenEq")
(ng #t)
(simp "RatVecUMinusAuxLhId")
(simp "RatVecPlusAuxLhEqVecLh")
(simp "LenEq")
(ng #t)
(simp "RatVecSTimesAuxLhEqLhList")
(simp "RatVecPlusAuxLhEqVecLh")
(simp "RatVecPlusAuxLhEqVecLh")
(simp "RatVecSTimesAuxLhEqLhList")
(ng #t)
  (assert "a*(a1+a2+ ~a2) == a*a1")
    (simp "RatPlusComm")
    (ng #t)
    (simp "RatPlusComm")
    (ng #t)
    (simprat (pf "a2+ ~a2 == (0#1)"))
    (use "Truth")
    (use "Truth")
  (assume "A1")
(simp "A1")
(ng #t)
(inst-with "IH" (pt "RatVecConstr eV2") )
(ng 4)
(simphyp-with 4 "LenEq")
(ng 5)
(simphyp-with 5 (pf "(ListLength rat)(RatVecPlusAux eV1 eV2)=(ListLength rat)(RatVecUMinusAux eV2)"))
(ng 6)
(inst-with 6 (pt "a"))
(simphyp-with 7 (pf "(ListLength rat)(a~*_(RatVecPlusAux(RatVecPlusAux eV1 
eV2)(RatVecUMinusAux eV2)))=(ListLength rat)(a~*_eV1)"))
(ng 8)
(use 8)
(use "Truth")
(simp "RatVecSTimesAuxLhEqLhList")
(simp "RatVecPlusAuxLhEqVecLh")
(simp "RatVecPlusAuxLhEqVecLh")
(simp "RatVecSTimesAuxLhEqLhList")
(use "Truth")
(use "LenEq")
(simp "RatVecPlusAuxLhEqVecLh")
(simp "RatVecUMinusAuxLhId")
(simp "LenEq")
(use "Truth")
(use "LenEq")
(simp "RatVecPlusAuxLhEqVecLh")
(simp "RatVecUMinusAuxLhId")
(use "LenEq")
(use "LenEq")
(use "LenEq")
(simp "RatVecPlusAuxLhEqVecLh")
(simp "RatVecUMinusAuxLhId")
(use "LenEq")
(use "LenEq")
(use "LenEq")
(save "RatVecSTimesPlusMinusElim")

; (set-goal "all eV1,eV2,a(Lh eV1 = Lh eV2 -> ~|(a~*_eV1) == ~|_(a~*_(eV1~+_eV2~+_ ~~_eV2)))")
; (ind)
; (cases)
; (assume "c")
; (ng #t)
; (assume 1)
; (use 1)
; (assume "a1" "eV1")
; (ng #t)
; (assume "c")
; (assume 1)
; (use "Truth")
; (assume "a1" "eV1" "IH")
; (cases)
; (assume "c")
; (ng #t)
; (use "Efq")
; (assume "a2" "eV2" "c")
; (ng #t)
; (assume "LenEq")
; (simp "LenEq")
; (ng #t)
; (simp "RatVecPlusAuxLhEqVecLh")
; (simp "RatVecUMinusAuxLhEqId")
; (simp "LenEq")
; (ng #t)
; (use "RatLeAntiSym")
; (use "RatMaxLUB")
; (inst-with "RatMaxEqvCancelR" (pt "abs(c*a1)") (pt "~|_(c~*_(eV1~+_eV2~+_ ~~_eV2))") (pt "abs(c*(a1+a2+ ~a2))"))
; (simprat "<-" 3)
; (use "RatMaxUB1")
; (simp "RatPlusComm")
; (ng #t)
; (simp "RatPlusComm")
; (ng #t)
; (simprat (pf "a2+ ~a2 == (0#1)"))
; (use "Truth")
; (use "Truth")
; (simprat (pf "~|_(c~*_eV1) ==  ~|_(c~*_(eV1~+_eV2~+_ ~~_eV2))"))
; (use "RatMaxUB2")
; (use "IH")
; (use "LenEq")
; (use "RatMaxLUB")
; (inst-with "RatMaxEqvCancelR" (pt "abs(c*a1)") (pt "~|_(c~*_(eV1))") (pt "abs(c*(a1+a2+ ~a2))"))
; (simprat 3)
; (use "RatMaxUB1")
; (simp "RatPlusComm")
; (ng #t)
; (simp "RatPlusComm")
; (ng #t)
; (simprat (pf "a2+ ~a2 == (0#1)"))
; (use "Truth")
; (use "Truth")
; (simprat (pf "~|_(c~*_(eV1~+_eV2~+_ ~~_eV2)) == ~|_(c~*_eV1)"))
; (use "RatMaxUB2")
; (use "RatEqvSym")
; (use "IH")
; (use "LenEq")
; (use "LenEq")
; (save "RatVecInfNormSTimesSumPlusUMinusTrans")
;; todo


;; (set-goal "Lh(RatVecUMinusAux eV) = Lh eV")
;; (ind)
;; (ng #t)
;; (use "Truth")
;; (assume "a" "eV")
;; (assume "IH")
;; (ng #t)
;; (use "IH")
;; (save "RatVecUMinusAuxLhId")

(set-goal "e dim= (~e) dim")
(cases)
(assume "eV")
(ng #t)
(simp "NatEqSym")
(use "RatVecUMinusAuxLhId")
(save "RatVecUMinusDimId")





; (set-goal "all eV1,eV2,a,b(Lh eV1 = Lh eV2 -> (~|_(b~*_(eV1~+_eV2~+_ ~~_eV2))<= a) = (~|_(b~*_eV1) <= a))")
; (ind)
; (cases)
; (assume "a" "b")
; (ng #t)
; (assume 1)
; (use "Truth")
; (assume "a2" "eV2")
; (assume "a" "b")
; (ng #t)
; (assume 1)
; (use "Truth")
; (assume "a1" "eV1")
; (assume "IH")
; (cases)
; (assume "a" "b")
; (ng #t)
; (use "Efq")
; (assume "a2" "eV2" "a" "b")
; (ng #t)
; (assume "LenEq")
; (ng #t)
; (simp "LenEq")
; (ng #t)
; (simp "RatVecUMinusAuxLhId")
; (simp "RatVecPlusAuxLhEqVecLh")
; (simp "LenEq")
; (ng #t)
; (use "BooleAeqToEq")
; (inst-with "RatMaxEqvCancelR" (pt "abs(b*(a1+a2+ ~a2))")  (pt "abs(b*a1)"))
; (simprat 3)
; (assume "Lhs")
; (inst-with "RatMaxEqvCancelR" (pt "abs(b*(a1+a2+ ~a2))") (pt "~|_(b~*_eV1)") (pt "abs(b*a1)"))
; (simprat "<-" 5)
; (simp "RatMaxComm")
; (inst-with "RatMaxEqvCancelR" (pt "~|_(b~*_eV1)") (pt "abs(b*(a1+a2+ ~a2))") (pt "~|_(b~*_(eV1~+_eV2~+_ ~~_eV2))"))
; (simprat 6)
; (simp "RatMaxComm")
; (use "Lhs")
; (use "RatVecInfNormSTimesSumPlusUMinusTrans")
; (use "LenEq")
; (simp "RatPlusComm")
; (ng #t)
; (simp "RatPlusComm")
; (ng #t)
; (simprat (pf "a2+ ~a2 == (0#1)"))
; (use "Truth")
; (use "Truth")
; (assume "Rhs")
; (simprat "RatMaxEqvCancelR" (pt "abs(b*(a1+a2+ ~a2))") (pt "~|_(b~*_(eV1~+_eV2~+_ ~~_eV2))") (pt "abs(b*a1)"))
; (use "RatMaxLUB")
; (simp "RatPlusComm")
; (ng #t)
; (simp "RatPlusComm")
; (ng #t)
; (simprat (pf "a2+ ~a2 == (0#1)"))
; (ng #t)
; (use "RatLeTrans" (pt "abs(b*a1)max~|_(b~*_eV1)"))
; (use "RatMaxUB1")
; (use "Rhs")
; (use "Truth")
; (use "RatLeTrans" (pt "~|_(b~*_eV1)"))
; (simprat "<-" "RatVecInfNormSTimesSumPlusUMinusTrans")
; (use "Truth")
; (use "LenEq")
; (use "RatLeTrans" (pt "abs(b*a1)max~|_(b~*_eV1)"))
; (use "RatMaxUB2")
; (use "Rhs")
; (use "Truth")
; (use "LenEq")
; (save "RatVecInfNormSumUMinEq")

; (set-goal "all eV1,eV2(Lh eV1 = Lh eV2 -> ~|_(eV1~+_eV2~+_ ~~_ eV2) == ~|_(eV1))")
; (ind)
; (cases)
; (ng #t)
; (assume 1)
; (use "Truth")
; (assume "a2" "eV2")
; (ng #t)
; (assume 1)
; (use "Truth")
; (assume "a1" "eV1" "IH")
; (cases)
; (ng #t)
; (use "Efq")
; (assume "a2" "eV2" "LenEq")
; (ng #t)
; (simp "LenEq")
; (ng #t)
; (simp "RatVecPlusAuxLhEqVecLh")
; (simp "RatVecUMinusAuxLhEqId")
; (simp "LenEq")
; (ng #t)
; (use "RatLeAntiSym")
; (use "RatMaxLUB")
; (simp "RatPlusComm")
; (ng #t)
; (simp "RatPlusComm")
; (ng #t)
; (simprat (pf "a2+ ~a2 == (0#1)"))
; (use "RatMaxUB1")
; (use "Truth")
; (simprat "IH")
; (use "RatMaxUB2")
; (use "LenEq")
; (use "RatMaxLUB")
; (inst-with-to "RatMaxEqvCancelR" (pt "abs(a1+a2+ ~a2)") (pt "~|_(eV1~+_eV2~+_ ~~_eV2)") (pt "abs a1") "RatMaxTrans1")
; (simprat "RatMaxTrans1")
; (use "RatMaxUB1")
; (simp "RatPlusComm")
; (ng #t)
; (simp "RatPlusComm")
; (ng #t)
; (simprat (pf "a2+ ~a2 == (0#1)"))
; (use "Truth")
; (use "Truth")
; (simprat "<-" "IH" (pt "eV2"))
; (use "RatMaxUB2")
; (use "LenEq")
; (use "LenEq")
; (save "RatVecSumUMinIdElim")

; (set-goal "all eV(~|_((0#1)~*_ eV) == (0#1))")
; (ind)
; (ng #t)
; (use "Truth")
; (assume "a" "eV" "IH")
; (ng #t)
; (use "RatLeAntiSym")
; (use "RatMaxLUB")
; (use "Truth")
; (simprat "IH")
; (use "Truth")
; (use "RatMaxUB1")
; (save "RatVecInfNormSTimesZeroEqZero")

; (set-goal "all eV,a(( ~|_(a~*_eV)) == abs a* ~|_eV)")
; (ind)
; (assume "a")
; (ng #t)
; (use "Truth")
; (assume "a" "eV" "IH" "c")
; (ng #t)
; (cases (pt "c == (0#1)"))
; (assume "C1")
; (inst-with-to "RatMaxEqvCancelR" (pt "abs(c*a)") (pt "~|_(c~*_eV)") (pt "(0#1)") "RatMaxEqv1")
; (simprat "RatMaxEqv1")
; (simp "RatMaxComm")
; (inst-with-to "RatMaxEqvCancelR" (pt "~|_(c~*_eV)") (pt "(0#1)") (pt "(0#1)") "RatMaxEqv2")
; (simprat "RatMaxEqv2")
; (simprat "C1")
; (ng #t)
; (use "Truth")
; (simprat "IH")
; (simprat "C1")
; (use "Truth")
; (simprat "C1")
; (use "Truth")
; (assume "nC1")
; (simp "RatMaxComm")
; (inst-with-to "RatMaxEqvCancelR" (pt "~|_(c~*_eV)") (pt "abs(c*a)") (pt "abs c* ~|_eV") "RatMaxEqv1")
; (simprat "RatMaxEqv1")
; (simp "RatMaxComm")
; (inst-with-to "RatMaxEqvCancelR" (pt "abs(c*a)") (pt "abs c* ~|_eV") (pt "abs c*abs a") "RatMaxEqv2")
; (simprat "RatMaxEqv2")
; (ng #t)
; (inst-with-to "RatMaxTimesDistr" (pt "abs c") (pt "abs a") (pt "~|_eV") "RatMaxDist1")
; (simprat "RatMaxDist1")
; (ng #t)
; (use "Truth")
; (ng #t)
; (use "RatNZeroToLtAbs")
; (use "nC1")
; (simp "RatAbsTimes")
; (use "Truth")
; (use "IH")
; (save "RatVecInfNormSTimesDist")

; (set-goal "all e1,e2(e1 dim = e2 dim -> |_(e1 + e2)<= |_ e1 + |_e2)")
; (cases)
; (ind)
; (cases)
; (assume "eV")
; (ng #t)
; (assume 1)
; (simp (pf "eV eqd (Nil rat)"))
; (ng #t)
; (use "Truth")
; (use "ListLengthEqZeroToEmptyList")
; (use "NatLeToNotLt")
; (ng #t)
; (simp 1)
; (use "Truth")
; (assume "a" "eV" "IH")
; (cases)
; (ng #t)
; (cases)
; (ng #t)
; (use "Efq")
; (assume "a2" "eV1")
; (assume 1)
; (simp 2)
; (ng #t)
; (simp 2)
; (ng #t)
; (use "RatMaxLUB")
; (use "RatLeTrans" (pt "abs a + abs a2"))
; (ng #t)
; (use "Truth")
; (use "RatLeSumToCases")
; (split)
; (use "RatMaxUB1")
; (use "RatMaxUB1")
; (inst-with-to "IH" (pt "RatVecConstr eV1") "IHLst")
; (use "RatLeTrans" (pt "ratListAbsMax eV+ ratListAbsMax eV1"))
; (ng "IHLst")
; (simphyp-with-to "IHLst" 2 "IhLstC")
; (use "IhLstC")
; (use "Truth")
; (use "RatLeSumToCases")
; (split)
; (use "RatMaxUB2")
; (use "RatMaxUB2")
; (save "RatVecMaxNormTriangEq")




; (set-goal "all eV1,eV2(Lh eV1 = Lh eV2 -> ~|_(eV1 ~+_ eV2) <= ~|_eV1 + ~|_eV2)")
; (assume "eV1" "eV2")
; (assume "LengEq")
; (inst-with "RatVecInfNormTriangEq" (pt "RatVecConstr eV1") (pt "RatVecConstr eV2"))
; (ng 1)
; (simphyp-with 2 1)
; (ng 3)
; (use 3)
; (use "Truth")
; (save "RatVecInfNormAuxTriangEq")
; (add-rewrite-rule "~|_(eV1 ~+_ eV2) <= ~|_eV1 + ~|_eV2" "Lh eV1 = Lh eV2")

; (set-goal "all e1,e2(e1+e2 = e2+e1)")
; (cases)
; (ind)
; (cases)
; (cases)
; (ng #t)
; (use "Truth")
; (assume "a" "eV")
; (ng #t)
; (use "Truth")
; (assume "b" "eV2" "IH")
; (cases)
; (cases)
; (ng #t)
; (use "Truth")
; (assume  "a" "eV")
; (ng #t)
; (simp "NatEqSym")
; (cases (pt "(ListLength rat)eV=(ListLength rat)eV2"))
; (assume "c1")
; (ng #t)
; (split)
; (use "RatPlusComm")
; (inst-with-to "IH" (pt "RatVecConstr eV") "IHAdap")
; (ng "IHAdap")
; (simphyp-with-to "IHAdap" (pf "(ListLength rat)eV2=(ListLength rat)eV") "IHAdap2")
; (simphyp-with-to "IHAdap2" (pf "(ListLength rat)eV=(ListLength rat)eV2") "IHAdap3")
; (use "IHAdap3")
; (use "c1")
; (simp "NatEqSym")
; (use "c1")
; (assume "nc1")
; (ng #t)
; (use "Truth")
; (save "RatVecPlusComm")

; (set-goal "all eV1,eV2(eV1~+_eV2 = eV2~+_eV1)")
; (ind)
; (cases)
; (ng #t)
; (use "Truth")
; (assume "a" "eV")
; (ng #t)
; (use "Truth")
; (assume "b" "eV2" "IH")
; (cases)
; (ng #t)
; (use "Truth")
; (assume  "a" "eV")
; (ng #t)
; (simp "NatEqSym")
; (cases (pt "(ListLength rat)eV=(ListLength rat)eV2"))
; (assume "c1")
; (ng #t)
; (split)
; (use "RatPlusComm")
; (use "IH")
; (assume "nc1")
; (ng #t)
; (use "Truth")
; (save "RatVecLstPlusComm")

; (set-goal "all e1,e2(|_(e1+e2) = |_(e2+e1))")
; (cases)
; (ind)
; (cases)
; (cases)
; (ng #t)
; (use "Truth")
; (assume "a")
; (assume "eV")
; (ng #t)
; (use "Truth")
; (assume "a" "eV1" "IH")
; (ng #t)
; (cases)
; (cases)
; (ng #t)
; (use "Truth")
; (assume "a2" "eV2")
; (cases (pt "Succ((ListLength rat)eV1)=
;                   (ListLength rat)((RatVecConstr(a2::eV2)) values)"))
; (ng #t)
; (assume "C1")
; (simp "C1")
; (ng #t)
; (simp "C1")
; (ng #t)
; (inst-with "IH" (pt "RatVecConstr eV2"))
; (simp "RatPlusComm")
; (ng 3)
; (simphyp-with 3 "C1")
; (ng 4)
; (simphyp-with 4 "C1")
; (ng 5)
; (simp 5)
; (use "Truth")
; (assume "nC1")
; (ng #t)
; (ng "nC1")
; (simp "NatEqSym")
; (simp "nC1")
; (ng #t)
; (use "Truth")
; (save "RatVecMaxNormPlusComm")

; (set-goal "all eV1,eV2(~|_(eV1~+_eV2) = ~|_(eV2~+_eV1))")
; (ind)
; (cases)
; (ng #t)
; (use "Truth")
; (assume "a2" "eV2")
; (ng #t)
; (use "Truth")
; (assume "a1" "eV1")
; (assume "IH")
; (cases)
; (ng #t)
; (use "Truth")
; (assume "a2" "eV2")
; (ng #t)
; (cases (pt "(ListLength rat)eV1=(ListLength rat)eV2"))
; (ng #t)
; (assume "C1")
; (simp "NatEqSym")
; (simp "C1")
; (ng #t)
; (simp "RatPlusComm")
; (simp "IH")
; (use "Truth")
; (assume "nC1")
; (ng #t)
; (simp "NatEqSym")
; (simp "nC1")
; (ng #t)
; (use "Truth")
; (save "RatVecLstInfNormPlusComm")

; (set-goal "all eV1,eV2(eV1=eV2 -> eV1 eqd eV2)")
; (ind)
; (cases)
; (ng #t)
; (assume "Tr")
; (use "InitEqD")
; (assume "a" "eV")
; (ng #t)
; (use "Efq")
; (assume "a" "eV" "IH")
; (cases)
; (ng #t)
; (use "Efq")
; (assume "a1" "eV1")
; (ng #t)
; (assume 1)
; (use "ListConstEqdCase")
; (assert "a=a1")
; (use 2)
; (assume "A1")
; (simp "A1")
; (use "InitEqD")
; (assert "eV=eV1")
; (use 2)
; (assume "A1")
; (simp "A1")
; (use "InitEqD")
; ;;(save "ListRatEqToEqD")

; (set-goal "all eV1,eV2,eV3(~|_(eV1~+_(eV2~+_eV3)) = ~|_(eV1~+_eV2~+_eV3))")
; (ind)
; (cases)
; (cases)
; (ng #t)
; (use "Truth")
; (assume "a3" "eV3")
; (ng #t)
; (use "Truth")
; (assume "a2" "eV2")
; (assume "eV3")
; (ng #t)
; (use "Truth")
; (assume "a1" "eV1" "IH")
; (ng #t)
; (cases)
; (cases)
; (ng #t)
; (use "Truth")
; (assume "a3" "eV3")
; (ng #t)
; (use "Truth")
; (assume "a2" "eV2")
; (cases)
; (ng #t)
; (use "Truth")
; (assume "a3" "eV3")
; (ng #t)
; (cases (pt "(ListLength rat)eV2=(ListLength rat)eV3"))
; (assume "C1")
; (ng #t)
; (simp "RatVecPlusAuxLhEqVecLh")
; (cases (pt "(ListLength rat)eV1=(ListLength rat)eV2"))
; (assume "C2")
; (ng #t)
; (simp "RatVecPlusAuxLhEqVecLh")
; (simp "C2")
; (simp "C1")
; (ng #t)
; (simp "IH")
; (use "Truth")
; (use "C2")
; (assume "nC2")
; (ng #t)
; (use "Truth")
; (use "C1")
; (assume "nC1")
; (ng #t)
; (cases (pt "(ListLength rat)eV1=(ListLength rat)eV2"))
; (assume "C2")
; (ng #t)
; (simp "RatVecPlusAuxLhEqVecLh")
; (simp "C2")
; (simp "nC1")
; (ng #t)
; (use "Truth")
; (use "C2")
; (assume "nC2")
; (ng #t)
; (use "Truth")
; (save "RatVecLstInfNormPlusAssoc")

; (set-goal "all eV1,eV2,eV3(eV1~+_(eV2~+_eV3) = eV1~+_eV2~+_eV3)")
; (ind)
; (cases)
; (cases)
; (ng #t)
; (use "Truth")
; (assume "a3" "eV3")
; (ng #t)
; (use "Truth")
; (assume "a2" "eV2")
; (assume "eV3")
; (ng #t)
; (use "Truth")
; (assume "a1" "eV1" "IH")
; (ng #t)
; (cases)
; (cases)
; (ng #t)
; (use "Truth")
; (assume "a3" "eV3")
; (ng #t)
; (use "Truth")
; (assume "a2" "eV2")
; (cases)
; (ng #t)
; (use "Truth")
; (assume "a3" "eV3")
; (ng #t)
; (cases (pt "(ListLength rat)eV2=(ListLength rat)eV3"))
; (assume "C1")
; (ng #t)
; (simp "RatVecPlusAuxLhEqVecLh")
; (cases (pt "(ListLength rat)eV1=(ListLength rat)eV2"))
; (assume "C2")
; (ng #t)
; (simp "RatVecPlusAuxLhEqVecLh")
; (simp "C2")
; (simp "C1")
; (ng #t)
; (use "IH")
; (use "C2")
; (assume "nC2")
; (ng #t)
; (use "Truth")
; (use "C1")
; (assume "nC1")
; (ng #t)
; (cases (pt "(ListLength rat)eV1=(ListLength rat)eV2"))
; (assume "C2")
; (ng #t)
; (simp "RatVecPlusAuxLhEqVecLh")
; (simp "C2")
; (simp "nC1")
; (ng #t)
; (use "Truth")
; (use "C2")
; (assume "nC2")
; (ng #t)
; (use "Truth")
; (save "RatVecLstPlusAssoc")
; (add-rewrite-rule "eV1~+_(eV2~+_eV3)" "eV1~+_eV2~+_eV3")

; (set-goal "all eV1,eV2(~~_(eV1~+_eV2) = (~~_eV1 ~+_ ~~_ eV2))")
; (ind)
; (cases)
; (ng #t)
; (use "Truth")
; (assume "a2" "eV2")
; (ng #t)
; (use "Truth")
; (assume "a1" "eV1" "IH")
; (cases)
; (ng #t)
; (use "Truth")
; (assume "a2" "eV2")
; (ng #t)
; (cases (pt "(ListLength rat)eV1=(ListLength rat)eV2"))
; (assume "C1")
; (simp "RatVecUMinusAuxLhEqId")
; (simp "RatVecUMinusAuxLhEqId")
; (simp "C1")
; (ng #t)
; (use "IH")
; (assume "nC1")
; (ng #t)
; (simp "RatVecUMinusAuxLhEqId")
; (simp "RatVecUMinusAuxLhEqId")
; (simp "nC1")
; (ng #t)
; (use "Truth")
; (save "RatVecLstPlusUMinusDistr")

; (set-goal "all eV1,a,b(~|_((a~*_eV1) ~+_ (b~*_eV1)) == ~|_((a+b)~*_(eV1)))")
; (ind)
; (ng #t)
; (strip)
; (use "Truth")
; (assume "a" "eV" "IH")
; (assume "b" "c")
; (ng #t)
; (simp "RatVecSTimesAuxLhEqLhList")
; (simp "RatVecSTimesAuxLhEqLhList")
; (ng #t)
; (inst-with "RatMaxEqvCancelR" (pt "abs(b*a+c*a)") (pt "~|_(b~*_eV~+_(c~*_eV))") (pt "abs((b+c)*a)"))
; (ng 2)
; (simprat 2)
; (simp "RatMaxComm")
; (use "RatEqvSym")
; (simp "RatMaxComm")
; (inst-with "RatMaxEqvCancelR" (pt "~|_(b+c~*_eV)") (pt "abs((b+c)*a)") (pt "~|_(b~*_eV~+_(c~*_eV))"))
; (ng 3)
; (simprat 3)
; (use "Truth")
; (use "RatEqvSym")
; (use "IH")
; (simprat "RatTimesPlusDistrLeft")
; (use "Truth")
; (save "RatVecLstInfNormSTimesPlusDistrLeft")

; (set-goal "all eV1,eV2,a,b(~|_((a~*_eV1) ~+_ (b~*_eV1) ~+_ eV2) == ~|_((a+b)~*_(eV1)~+_eV2))")
; (ind)
; (cases)
; (ng #t)
; (strip)
; (use "Truth")
; (assume "a2" "eV2" "a" "b")
; (ng #t)
; (use "Truth")
; (assume "a1" "eV1" "IH")
; (cases)
; (assume "a" "b")
; (ng #t)
; (use "Truth")
; (assume "a2" "eV2")
; (assume "a" "b")
; (ng #t)
; (simp "RatVecSTimesAuxLhEqLhList")
; (simp "RatVecSTimesAuxLhEqLhList")
; (simp "RatVecSTimesAuxLhEqLhList")
; (ng #t)
; (simp "RatVecPlusAuxLhEqVecLh")
; (simp "RatVecSTimesAuxLhEqLhList")
; (cases (pt "(ListLength rat)eV1=(ListLength rat)eV2"))
; (assume "C1")
; (ng #t)
; (inst-with "RatMaxEqvCancelR" (pt "abs(a*a1+b*a1+a2)") (pt "~|_(a~*_eV1~+_(b~*_eV1)~+_eV2)") (pt "abs((a+b)*a1+a2)"))
; (simprat 3)
; (simp "RatMaxComm")
; (use "RatEqvSym")
; (simp "RatMaxComm")
; (inst-with "RatMaxEqvCancelR" (pt "~|_(a+b~*_eV1~+_eV2)") (pt "abs((a+b)*a1+a2)") (pt "~|_(a~*_eV1~+_(b~*_eV1)~+_eV2)"))
; (simprat 4)
; (use "Truth")
; (use "RatEqvSym")
; (use "IH")
; (simprat "RatTimesPlusDistrLeft")
; (use "Truth")
; (assume "nC1")
; (ng #t)
; (use "Truth")
; (simp "RatVecSTimesAuxLhEqLhList")
; (simp "RatVecSTimesAuxLhEqLhList")
; (use "Truth")
; (save "RatVecLstInfNormSTimesPlusDistrLeftPlus")

; (set-goal "all eV,a(~a~*_eV = ~~_(a~*_eV))")
; (ind)
; (ng #t)
; (assume "a")
; (use "Truth")
; (assume "a1" "eV1" "IH")
; (assume "a")
; (ng #t)
; (use "IH")
; (save "RatVecLstSTimesUMinusRatToUMinusVec")

; (set-goal "all eV1(~|_(eV1 ~+_ ~~_eV1) == (0#1))")
; (ind)
; (ng #t)
; (use "Truth")
; (assume "a" "eV1" "IH")
; (ng #t)
; (simp "RatVecUMinusAuxLhEqId")
; (ng #t)
; (use "RatLeAntiSym")
; (use "RatMaxLUB")
; (use "Truth")
; (simprat "IH")
; (use "Truth")
; (simprat (pf " (0#1) == abs(a+ ~a)"))
; (use "RatMaxUB1")
; (use "RatEqvSym")
; (simprat (pf "a+ ~a == (0#1)"))
; (use "Truth")
; (use "Truth")
; (save "RatVecLstMinIdIntNormEqdZero")

; (set-goal "all eV1,eV2,a,b(a==b -> ~|_(a~*_eV1~+_eV2) == ~|_(b~*_eV1~+_eV2) )")
; (ind)
; (cases)
; (assume "a" "b" 1)
; (ng #t)
; (use "Truth")
; (assume "a2" "eV2" "a" "b")
; (ng #t)
; (assume 1)
; (use "Truth")
; (assume "a1" "eV1" "IH")
; (cases)
; (assume "a" "b")
; (ng #t)
; (assume 1 )
; (use "Truth")
; (assume "a2" "eV2" "a" "b")
; (assume 1)
; (ng #t)
; (simp "RatVecSTimesAuxLhEqLhList")
; (cases (pt "(ListLength rat)eV1=(ListLength rat)eV2"))
; (assume "C1")
; (ng #t)
; (simp "RatVecSTimesAuxLhEqLhList")
; (simp "C1")
; (ng #t)
; (use "RatLeAntiSym")
; (use "RatMaxLUB")
; (ng #t)
; (simprat 2)
; (use "RatMaxUB1")
; (simprat "IH" (pt "b"))
; (use "RatMaxUB2")
; (use 2)
; (use "RatMaxLUB")
; (simprat "<-" 2)
; (use "RatMaxUB1")
; (simprat "IH" (pt "a"))
; (use "RatMaxUB2")
; (simprat "<-" 2)
; (use "Truth")
; (assume "nC1")
; (ng #t)
; (simp "RatVecSTimesAuxLhEqLhList")
; (simp "nC1")
; (ng #t)
; (use "Truth")
; (save "RatVecLstInfNormSTimesSW")

; (set-goal "all eV(ratListAbsMax (RatVecUMinusAux eV) == ratListAbsMax eV)")
; (ind)
; (ng #t)
; (use "Truth")
; (assume "a" "eV")
; (ng #t)
; (assume "IH")
; (use "RatLeAntiSym")
; (use "RatMaxLUB")
; (use "RatMaxUB1")
; (simprat "IH")
; (use "RatMaxUB2")
; (use "RatMaxLUB")
; (use "RatMaxUB1")
; (simprat "<-" "IH")
; (use "RatMaxUB2")
; (save "RatVecLstMaxNormUMinusId")

; (set-goal "all e(|_ ~e == |_ e)")
; (cases)
; (assume "eV")
; (use "RatVecLstMaxNormUMinusId")
; (save "RatVecMaxNormUMinusId")

(set-goal "all e1,e2 (e1==e2 -> |_ e1 == |_ e2)")
(cases)
(ind)
(cases)
(cases)
(ng #t)
(auto)
(assume "a" "rls")
(ng #t)
(use "Efq")
(assume "a" "rls")
(assume "Ih")
(cases)
(cases)
(ng #t)
(use "Efq")
(assume "b" "rls0")
(ng #t)
(assume "cond")
(use "RatLeAntiSym")
(use "RatMaxLUB")
(use "RatLeTrans" (pt "abs a"))
(cut "[if ((ListLength rat)rls=(ListLength rat)rls0) [if (a==b) (RatVecEqvAux rls rls0) False] False]")
(cases (pt "(ListLength rat)rls=(ListLength rat)rls0"))
(assume "case1")
(ng #t)
(cases (pt "a==b"))
(assume "case2")
(ng #t)
(auto)
(use "RatLeTrans" (pt "abs b"))
(cut "[if ((ListLength rat)rls=(ListLength rat)rls0)[if (a==b) (RatVecEqvAux rls rls0) False]False]")
(cases (pt "(ListLength rat)rls=(ListLength rat)rls0"))
(assume "case1")
(ng #t)
(cases (pt "a==b"))
(assume "a==b")
(ng #t)
(assume "case2")
(simprat (pf "a==b"))
(auto)
(ng #t)
(assume "case2")
(use "Efq")
(assume "case1")
(ng #t)
(use "Efq")
(auto)
(use "RatMaxUB1")
(use "RatLeTrans" (pt "ratListAbsMax rls0"))
(use "RatEqvToLe")
(inst-with-to "Ih" (pt "RatVecConstr rls0") "IhInst")
(ng "IhInst")
(use "IhInst")
(cut "[if ((ListLength rat)rls=(ListLength rat)rls0)
      [if (a==b) (RatVecEqvAux rls rls0) False]
      False]")
(cases (pt "(ListLength rat)rls=(ListLength rat)rls0"))
(assume "case1")
(ng #t)
(cases (pt "a==b"))
(assume "case2")
(auto)
(assume "case2")
(ng #t)
(use "Efq")
(ng #t)
(assume "case1")
(use "Efq")
(auto)
(use "RatMaxUB2")
(use "RatMaxLUB")
(use "RatLeTrans" (pt "abs a"))
(cut "[if ((ListLength rat)rls=(ListLength rat)rls0)
      [if (a==b) (RatVecEqvAux rls rls0) False]
      False]")
(cases (pt "(ListLength rat)rls=(ListLength rat)rls0"))
(assume "case1")
(ng #t)
(cases (pt "a==b"))
(assume "case2")
(ng #t)
(assume "rls=rls0")
(simprat "case2")
(auto)
(assume "case2")
(ng #t)
(use "Efq")
(assume "case1")
(ng #t)
(use "Efq")
(auto)
(use "RatMaxUB1")
(use "RatLeTrans" (pt "ratListAbsMax rls"))
(use "RatEqvToLe")
(use "RatEqvSym")
(inst-with-to "Ih" (pt "RatVecConstr rls0") "IhInst")
(ng "IhInst")
(use "IhInst")
(cut "[if ((ListLength rat)rls=(ListLength rat)rls0)
      [if (a==b) (RatVecEqvAux rls rls0) False]
      False]")
(cases (pt "(ListLength rat)rls=(ListLength rat)rls0"))
(assume "case1")
(ng #t)
(cases (pt "a==b"))
(assume "case2")
(ng #t)
(auto)
(assume "case2")
(ng #t)
(use "Efq")
(assume "case1")
(ng #t)
(use "Efq")
(auto)
(use "RatMaxUB2")
(save "RatVectorMaxNormCompat")

(add-program-constant "ZerosRationalAux" (py "nat=>list rat "))

(add-computation-rules "ZerosRationalAux Zero" "(Nil (rat))"
                        "ZerosRationalAux (Succ n)" "(0#1)::ZerosRationalAux n"
)

(set-totality-goal "ZerosRationalAux")
(use "AllTotalElim")
(ind)
(ng #t)
(use "ListTotalVar")
(assume "n" "Ih")
(ng #t)
(use "TotalListCons")
(use "RatTotalVar")
(use "Ih")
(save-totality)

(add-program-constant "ZerosRational" (py "nat=>ratVec"))
(add-computation-rules "ZerosRational n" "RatVecConstr(ZerosRationalAux n)")

(set-totality-goal "ZerosRational")
(use "AllTotalElim")
(assume "n")
(ng #t)
(use "TotalRatVecRatVecConstr")
(use "ListTotalVar")
(save-totality)




(set-goal "all e,e1 (e dim=e1 dim -> |_(e + e1)<= |_(e) + |_(e1))")
(cases)
(assume "rls")
(cases)
(assume "rls0")
(ng #t)
(assume "case")
(simp "case")
(ng #t)
(assert "all rls1, rls2 ((ListLength rat)rls1=(ListLength rat)rls2 -> ratListAbsMax(RatVecPlusAux rls1 rls2)<=ratListAbsMax rls1+ratListAbsMax rls2)")
(ind)
(ng #t)
(cases)
(ng #t)
(auto)
(assume "a" "rls1")
(ng #t)
(use "Efq")
(assume "a" "rls1")
(assume "Ih")
(cases)
(ng #t)
(use "Efq")
(assume "a0" "rls2")
(ng #t)
(assume "caseassertion")
(simp "caseassertion")
(ng #t)
(use "RatMaxLUB")
(use "RatLeTrans" (pt "abs a + abs a0"))
(auto)
(use "RatLeSumToCases")
(split)
(use "RatMaxUB1")
(use "RatMaxUB1")
(use "RatLeTrans" (pt "ratListAbsMax rls1+ratListAbsMax rls2"))
(use "Ih")
(use "caseassertion")
(use "RatLeSumToCases")
(split)
(use "RatMaxUB2")
(use "RatMaxUB2")
(auto)
(save "RatVecAuxOneNormTriangle")


(set-goal "all e,e0,e1 (e dim=e0 dim -> e0 dim= e1 dim -> e1==e0 -> |_(e+e0)== |_(e+e1))")
(cases)
(ind)
(ng #t)
(auto)
(assume "a" "rls")
(assume "Ih")
(cases)
(cases)
(ng #t)
(assume "e")
(use "Efq")
(assume "a0" "rls0")
(cases)
(cases)
(ng #t)
(assume "Lhcond")
(use "Efq")
(assume "a1" "rls1")
(ng #t)
(assume "Lhcond1")
(assume "Lhcond2")
(simp "Lhcond1")
(ng #t)
(simp "Lhcond2")
(ng #t)
(simp "Lhcond1")
(simp "Lhcond2")
(ng #t)
(cases (pt "a1==a0"))
(assume "case")
(ng #t)
(assume "eqv1")
(simprat "case")
(simprat "RatMaxComm" )
(simprat (pf "abs(a+a0)max ratListAbsMax(RatVecPlusAux rls rls1)== ratListAbsMax(RatVecPlusAux rls rls1)max abs(a+a0)"))
(use "RatMaxEqvCancelR")
(inst-with-to "Ih" (pt "RatVecConstr rls0") (pt "RatVecConstr rls1") "IHInst")
(ng "IHInst")
(cut "[if ((ListLength rat)rls1=(ListLength rat)rls0)
           (RatVecEqvAux rls1 rls0)
           False] ->
         ratListAbsMax
         [if ((ListLength rat)rls=(ListLength rat)rls0)
           (RatVecConstr(RatVecPlusAux rls rls0))
           (RatVecConstr(Nil rat))]values==
         ratListAbsMax
         [if ((ListLength rat)rls=(ListLength rat)rls1)
           (RatVecConstr(RatVecPlusAux rls rls1))
           (RatVecConstr(Nil rat))]values")
(simp "Lhcond1")
(simp "Lhcond2")
(ng #t)
(simp "Lhcond1")
(simp "Lhcond2")
(ng #t)
(auto)
(simprat "RatMaxComm")
(ng #t)
(auto)
(assume "case2")
(ng #t)
(use "Efq")
(save "RatVecOneNormPlusCancelR")

(set-goal "all e,e1(e==e1 -> ~e == ~e1)")
(cases)
(ind)
(cases)
(assume "rls")
(ng #t)
(assume "case")
(simp  "case")
(simp "RatVecUMinusAuxLhId")
(auto)
(assume "a" "rls")
(assume "Ih")
(cases)
(cases)
(ng #t)
(auto)
(assume "a0" "rls0")
(inst-with-to "Ih" (pt "RatVecConstr rls0") "IHInst")
(ng "IHInst")
(cut "[if ((ListLength rat)rls=(ListLength rat)rls0)
      (RatVecEqvAux rls rls0)
      False] ->
    [if ((ListLength rat)(RatVecUMinusAux rls)=
          (ListLength rat)(RatVecUMinusAux rls0))
      (RatVecEqvAux(RatVecUMinusAux rls)(RatVecUMinusAux rls0))
      False]")
(ng #t)
(cases (pt "(ListLength rat)rls=(ListLength rat)rls0"))
(assume "case")
(ng #t)
(simp "RatVecUMinusAuxLhId")
(simp "RatVecUMinusAuxLhId")
(simp "case")
(ng #t)
(cases (pt "(a==a0)"))
(ng #t)
(auto)
(assume "case2")
(ng #t)
(assume "case3")
(use "Efq")
(use "IHInst")
(save "RatVecUMinusInjEqvOne")


(set-goal "all e,e1(e dim = e1 dim-> (~e) dim = (~e1) dim)")
(cases)
(assume "rls")
(cases)
(assume "rls0")
(ng #t)
(assume "Lhcond")
(simp "RatVecUMinusAuxLhId")
(simp "RatVecUMinusAuxLhId")
(auto)
(save "RatVecUMinusInjEqvOneDim")




(set-goal "all e RealNNegS (|_(e))")
(cases)
(ind)
(ng #t)
(use "RealNNegSIntro")
(auto)
(assume "a" "rls" "Ih")
(ng)
(use "RealNNegSIntro")
(ng #t)
(assume "n")
(use "RatLeTrans" (pt "abs a"))
(auto)
(use "RatMaxUB1")
(save "RatRealRealNNegSMaxNorm")



(set-goal "all e,e0 ((e==e0)->(e0==e))")
(cases)
(ind)
(cases)
(assume "rls")
(ng #t)
(assume "1")
(simp "1")
(auto)
(assume "a" "rls")
(assume "Ih")
(cases)
(ng #t)
(cases)
(ng #t)
(auto)
(assume "a0" "rls0")
(ng #t)
(inst-with-to "Ih" (pt "RatVecConstr rls0") "IHInst")
(ng "IHInst")
(cut "[if ((ListLength rat)rls=(ListLength rat)rls0)
      (RatVecEqvAux rls rls0)
      False] ->
    [if ((ListLength rat)rls0=(ListLength rat)rls)
      (RatVecEqvAux rls0 rls)
      False]")
(cases (pt "(ListLength rat)rls=(ListLength rat)rls0"))
(assume "case")
(simp "<-" "case")
(ng #t)
(assume "IHInst1")
(cases (pt "a==a0"))
(assume "eqvcase")
(simp "RatEqvCompat" (pt "a") (pt "a0"))
(simp "eqvcase")
(auto)
(use "RatEqvSym")
(auto)
(assume "caseF")
(ng #t)
(use "Efq")
(ng #t)
(assume "lhf")
(assume "casef")
(use "Efq")
(use "IHInst")
(save "RatVecEqvSym")



(add-program-constant "OnesRationalAux" (py "nat=>list rat "))

(add-computation-rules "OnesRationalAux Zero" "(Nil (rat))"
                        "OnesRationalAux (Succ n)" "(1#1)::OnesRationalAux n"
)

(set-totality-goal "OnesRationalAux")
(use "AllTotalElim")
(ind)
(ng #t)
(use "ListTotalVar")
(assume "n" "Ih")
(ng #t)
(use "TotalListCons")
(use "RatTotalVar")
(auto)
(save-totality)
